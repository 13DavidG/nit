# Production AST nodes full definition.
# This file was generated by SableCC (http://www.sablecc.org/).
package parser_prod

import lexer
intrude import parser_nodes
private import tables

redef class ANode
	# Parent of the node in the AST
	readable writable var _parent: nullable ANode

	# Remove a child from the AST
	fun remove_child(child: ANode)
	do
		replace_child(child, null)
	end

	# Replace a child with an other node in the AST
	fun replace_child(old_child: ANode, new_child: nullable ANode) is abstract

	# Replace itself with an other node in the AST
	fun replace_with(node: ANode)
	do
		if (_parent != null) then
			_parent.replace_child(self, node)
		end
	end

	# Visit all nodes in order.
	# Thus, call "v.visit(e)" for each node e
	fun visit_all(v: Visitor) is abstract
end

redef class Token
	redef fun visit_all(v: Visitor) do end
	redef fun replace_child(old_child: ANode, new_child: nullable ANode) do end
end

redef class Prod
	redef fun replace_with(n: ANode)
        do
                super
                assert n isa Prod
                n.location = location
        end
end

# Abstract standard visitor
class Visitor
	# What the visitor do when a node is visited
        # Concrete visitors should redefine this method.
        protected fun visit(e: nullable ANode) is abstract

        # Ask the visitor to visit a given node.
        # Usually automatically called by visit_all* methods.
	# This methos should not be redefined
        fun enter_visit(e: nullable ANode)
	do
		var old = _current_node
		_current_node = e
		visit(e)
		_current_node = old
	end

	# The current visited node
	readable var _current_node: nullable ANode = null
end

redef class AModule
    private init empty_init do end

    init init_amodule (
            n_packagedecl: nullable APackagedecl,
            n_imports: Collection[Object], # Should be Collection[AImport]
            n_classdefs: Collection[Object] # Should be Collection[AClassdef]
    )
    do
        empty_init
        _n_packagedecl = n_packagedecl
	if n_packagedecl != null then
		n_packagedecl.parent = self
	end
	for n in n_imports do
		assert n isa AImport
		_n_imports.add(n)
		n.parent = self
	end
	for n in n_classdefs do
		assert n isa AClassdef
		_n_classdefs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_packagedecl == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa APackagedecl
                _n_packagedecl = new_child
	    else
		_n_packagedecl = null
            end
            return
	end
        for i in [0.._n_imports.length[ do
            if _n_imports[i] == old_child then
                if new_child != null then
		    assert new_child isa AImport
                    _n_imports[i] = new_child
                    new_child.parent = self
                else
                    _n_imports.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_classdefs.length[ do
            if _n_classdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa AClassdef
                    _n_classdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_classdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_packagedecl != null then
            v.enter_visit(_n_packagedecl.as(not null))
        end
            for n in _n_imports do
                v.enter_visit(n)
	    end
            for n in _n_classdefs do
                v.enter_visit(n)
	    end
    end
end
redef class APackagedecl
    private init empty_init do end

    init init_apackagedecl (
            n_doc: nullable ADoc,
            n_kwpackage: nullable TKwpackage,
            n_id: nullable TId
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwpackage = n_kwpackage.as(not null)
	n_kwpackage.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwpackage == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwpackage
                _n_kwpackage = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        v.enter_visit(_n_kwpackage)
        v.enter_visit(_n_id)
    end
end
redef class AStdImport
    private init empty_init do end

    init init_astdimport (
            n_visibility: nullable AVisibility,
            n_kwimport: nullable TKwimport,
            n_id: nullable TId
    )
    do
        empty_init
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwimport = n_kwimport.as(not null)
	n_kwimport.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwimport == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwimport
                _n_kwimport = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwimport)
        v.enter_visit(_n_id)
    end
end
redef class ANoImport
    private init empty_init do end

    init init_anoimport (
            n_visibility: nullable AVisibility,
            n_kwimport: nullable TKwimport,
            n_kwend: nullable TKwend
    )
    do
        empty_init
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwimport = n_kwimport.as(not null)
	n_kwimport.parent = self
        _n_kwend = n_kwend.as(not null)
	n_kwend.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwimport == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwimport
                _n_kwimport = new_child
	    else
		abort
            end
            return
	end
        if _n_kwend == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwend
                _n_kwend = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwimport)
        v.enter_visit(_n_kwend)
    end
end
redef class APublicVisibility
    private init empty_init do end

    init init_apublicvisibility
    do
        empty_init
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
    end

    redef fun visit_all(v: Visitor)
    do
    end
end
redef class APrivateVisibility
    private init empty_init do end

    init init_aprivatevisibility (
            n_kwprivate: nullable TKwprivate
    )
    do
        empty_init
        _n_kwprivate = n_kwprivate.as(not null)
	n_kwprivate.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwprivate == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwprivate
                _n_kwprivate = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwprivate)
    end
end
redef class AProtectedVisibility
    private init empty_init do end

    init init_aprotectedvisibility (
            n_kwprotected: nullable TKwprotected
    )
    do
        empty_init
        _n_kwprotected = n_kwprotected.as(not null)
	n_kwprotected.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwprotected == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwprotected
                _n_kwprotected = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwprotected)
    end
end
redef class AIntrudeVisibility
    private init empty_init do end

    init init_aintrudevisibility (
            n_kwintrude: nullable TKwintrude
    )
    do
        empty_init
        _n_kwintrude = n_kwintrude.as(not null)
	n_kwintrude.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwintrude == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwintrude
                _n_kwintrude = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwintrude)
    end
end
redef class AStdClassdef
    private init empty_init do end

    init init_astdclassdef (
            n_doc: nullable ADoc,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_classkind: nullable AClasskind,
            n_id: nullable TClassid,
            n_formaldefs: Collection[Object], # Should be Collection[AFormaldef]
            n_superclasses: Collection[Object], # Should be Collection[ASuperclass]
            n_propdefs: Collection[Object] # Should be Collection[APropdef]
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_classkind = n_classkind.as(not null)
	n_classkind.parent = self
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
	for n in n_formaldefs do
		assert n isa AFormaldef
		_n_formaldefs.add(n)
		n.parent = self
	end
	for n in n_superclasses do
		assert n isa ASuperclass
		_n_superclasses.add(n)
		n.parent = self
	end
	for n in n_propdefs do
		assert n isa APropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_classkind == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AClasskind
                _n_classkind = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_formaldefs.length[ do
            if _n_formaldefs[i] == old_child then
                if new_child != null then
		    assert new_child isa AFormaldef
                    _n_formaldefs[i] = new_child
                    new_child.parent = self
                else
                    _n_formaldefs.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_superclasses.length[ do
            if _n_superclasses[i] == old_child then
                if new_child != null then
		    assert new_child isa ASuperclass
                    _n_superclasses[i] = new_child
                    new_child.parent = self
                else
                    _n_superclasses.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa APropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_classkind)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
            for n in _n_formaldefs do
                v.enter_visit(n)
	    end
            for n in _n_superclasses do
                v.enter_visit(n)
	    end
            for n in _n_propdefs do
                v.enter_visit(n)
	    end
    end
end
redef class ATopClassdef
    private init empty_init do end

    init init_atopclassdef (
            n_propdefs: Collection[Object] # Should be Collection[APropdef]
    )
    do
        empty_init
	for n in n_propdefs do
		assert n isa APropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa APropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_propdefs do
                v.enter_visit(n)
	    end
    end
end
redef class AMainClassdef
    private init empty_init do end

    init init_amainclassdef (
            n_propdefs: Collection[Object] # Should be Collection[APropdef]
    )
    do
        empty_init
	for n in n_propdefs do
		assert n isa APropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa APropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_propdefs do
                v.enter_visit(n)
	    end
    end
end
redef class AConcreteClasskind
    private init empty_init do end

    init init_aconcreteclasskind (
            n_kwclass: nullable TKwclass
    )
    do
        empty_init
        _n_kwclass = n_kwclass.as(not null)
	n_kwclass.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwclass == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwclass
                _n_kwclass = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwclass)
    end
end
redef class AAbstractClasskind
    private init empty_init do end

    init init_aabstractclasskind (
            n_kwabstract: nullable TKwabstract,
            n_kwclass: nullable TKwclass
    )
    do
        empty_init
        _n_kwabstract = n_kwabstract.as(not null)
	n_kwabstract.parent = self
        _n_kwclass = n_kwclass.as(not null)
	n_kwclass.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwabstract == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwabstract
                _n_kwabstract = new_child
	    else
		abort
            end
            return
	end
        if _n_kwclass == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwclass
                _n_kwclass = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwabstract)
        v.enter_visit(_n_kwclass)
    end
end
redef class AInterfaceClasskind
    private init empty_init do end

    init init_ainterfaceclasskind (
            n_kwinterface: nullable TKwinterface
    )
    do
        empty_init
        _n_kwinterface = n_kwinterface.as(not null)
	n_kwinterface.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwinterface == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinterface
                _n_kwinterface = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwinterface)
    end
end
redef class AUniversalClasskind
    private init empty_init do end

    init init_auniversalclasskind (
            n_kwuniversal: nullable TKwuniversal
    )
    do
        empty_init
        _n_kwuniversal = n_kwuniversal.as(not null)
	n_kwuniversal.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwuniversal == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwuniversal
                _n_kwuniversal = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwuniversal)
    end
end
redef class AFormaldef
    private init empty_init do end

    init init_aformaldef (
            n_id: nullable TClassid,
            n_type: nullable AType
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
    end
end
redef class ASuperclass
    private init empty_init do end

    init init_asuperclass (
            n_kwspecial: nullable TKwspecial,
            n_kwsuper: nullable TKwsuper,
            n_type: nullable AType
    )
    do
        empty_init
        _n_kwspecial = n_kwspecial
	if n_kwspecial != null then
		n_kwspecial.parent = self
	end
        _n_kwsuper = n_kwsuper
	if n_kwsuper != null then
		n_kwsuper.parent = self
	end
        _n_type = n_type.as(not null)
	n_type.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwspecial == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwspecial
                _n_kwspecial = new_child
	    else
		_n_kwspecial = null
            end
            return
	end
        if _n_kwsuper == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwsuper
                _n_kwsuper = new_child
	    else
		_n_kwsuper = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwspecial != null then
            v.enter_visit(_n_kwspecial.as(not null))
        end
        if _n_kwsuper != null then
            v.enter_visit(_n_kwsuper.as(not null))
        end
        v.enter_visit(_n_type)
    end
end
redef class AAttrPropdef
    private init empty_init do end

    init init_aattrpropdef (
            n_doc: nullable ADoc,
            n_readable: nullable AAble,
            n_writable: nullable AAble,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_kwvar: nullable TKwvar,
            n_id: nullable TAttrid,
            n_id2: nullable TId,
            n_type: nullable AType,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_readable = n_readable
	if n_readable != null then
		n_readable.parent = self
	end
        _n_writable = n_writable
	if n_writable != null then
		n_writable.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwvar = n_kwvar.as(not null)
	n_kwvar.parent = self
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_id2 = n_id2
	if n_id2 != null then
		n_id2.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_readable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAble
                _n_readable = new_child
	    else
		_n_readable = null
            end
            return
	end
        if _n_writable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAble
                _n_writable = new_child
	    else
		_n_writable = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwvar == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwvar
                _n_kwvar = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_id2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id2 = new_child
	    else
		_n_id2 = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_readable != null then
            v.enter_visit(_n_readable.as(not null))
        end
        if _n_writable != null then
            v.enter_visit(_n_writable.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwvar)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
        if _n_id2 != null then
            v.enter_visit(_n_id2.as(not null))
        end
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AMethPropdef
    private init empty_init do end

    init init_amethpropdef (
            n_doc: nullable ADoc,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_methid: nullable AMethid,
            n_signature: nullable ASignature
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end
end
redef class ADeferredMethPropdef
    private init empty_init do end

    init init_adeferredmethpropdef (
            n_doc: nullable ADoc,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_kwmeth: nullable TKwmeth,
            n_methid: nullable AMethid,
            n_signature: nullable ASignature
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwmeth = n_kwmeth.as(not null)
	n_kwmeth.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end
end
redef class AInternMethPropdef
    private init empty_init do end

    init init_ainternmethpropdef (
            n_doc: nullable ADoc,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_kwmeth: nullable TKwmeth,
            n_methid: nullable AMethid,
            n_signature: nullable ASignature
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwmeth = n_kwmeth.as(not null)
	n_kwmeth.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end
end
redef class AExternMethPropdef
    private init empty_init do end

    init init_aexternmethpropdef (
            n_doc: nullable ADoc,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_kwmeth: nullable TKwmeth,
            n_methid: nullable AMethid,
            n_signature: nullable ASignature,
            n_extern: nullable TString
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwmeth = n_kwmeth.as(not null)
	n_kwmeth.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
        _n_extern = n_extern
	if n_extern != null then
		n_extern.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
        if _n_extern == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TString
                _n_extern = new_child
	    else
		_n_extern = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
        if _n_extern != null then
            v.enter_visit(_n_extern.as(not null))
        end
    end
end
redef class AConcreteMethPropdef
    private init empty_init do end

    init init_aconcretemethpropdef (
            n_doc: nullable ADoc,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_kwmeth: nullable TKwmeth,
            n_methid: nullable AMethid,
            n_signature: nullable ASignature,
            n_block: nullable AExpr
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwmeth = n_kwmeth.as(not null)
	n_kwmeth.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class AConcreteInitPropdef
    private init empty_init do end

    init init_aconcreteinitpropdef (
            n_doc: nullable ADoc,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_kwinit: nullable TKwinit,
            n_methid: nullable AMethid,
            n_signature: nullable ASignature,
            n_block: nullable AExpr
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwinit = n_kwinit.as(not null)
	n_kwinit.parent = self
        _n_methid = n_methid
	if n_methid != null then
		n_methid.parent = self
	end
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwinit == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinit
                _n_kwinit = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		_n_methid = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwinit)
        if _n_methid != null then
            v.enter_visit(_n_methid.as(not null))
        end
        v.enter_visit(_n_signature)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class AMainMethPropdef
    private init empty_init do end

    init init_amainmethpropdef (
            n_kwredef: nullable TKwredef,
            n_block: nullable AExpr
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class ATypePropdef
    private init empty_init do end

    init init_atypepropdef (
            n_doc: nullable ADoc,
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_kwtype: nullable TKwtype,
            n_id: nullable TClassid,
            n_type: nullable AType
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwtype = n_kwtype.as(not null)
	n_kwtype.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwtype == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwtype
                _n_kwtype = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwtype)
        v.enter_visit(_n_id)
        v.enter_visit(_n_type)
    end
end
redef class AReadAble
    private init empty_init do end

    init init_areadable (
            n_kwredef: nullable TKwredef,
            n_kwreadable: nullable TKwreadable
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_kwreadable = n_kwreadable.as(not null)
	n_kwreadable.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_kwreadable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwreadable
                _n_kwreadable = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_kwreadable)
    end
end
redef class AWriteAble
    private init empty_init do end

    init init_awriteable (
            n_kwredef: nullable TKwredef,
            n_visibility: nullable AVisibility,
            n_kwwritable: nullable TKwwritable
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwwritable = n_kwwritable.as(not null)
	n_kwwritable.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwwritable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwritable
                _n_kwwritable = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        if _n_visibility != null then
            v.enter_visit(_n_visibility.as(not null))
        end
        v.enter_visit(_n_kwwritable)
    end
end
redef class AIdMethid
    private init empty_init do end

    init init_aidmethid (
            n_id: nullable TId
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
    end
end
redef class APlusMethid
    private init empty_init do end

    init init_aplusmethid (
            n_plus: nullable TPlus
    )
    do
        empty_init
        _n_plus = n_plus.as(not null)
	n_plus.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_plus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPlus
                _n_plus = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_plus)
    end
end
redef class AMinusMethid
    private init empty_init do end

    init init_aminusmethid (
            n_minus: nullable TMinus
    )
    do
        empty_init
        _n_minus = n_minus.as(not null)
	n_minus.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_minus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinus
                _n_minus = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_minus)
    end
end
redef class AStarMethid
    private init empty_init do end

    init init_astarmethid (
            n_star: nullable TStar
    )
    do
        empty_init
        _n_star = n_star.as(not null)
	n_star.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_star == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStar
                _n_star = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_star)
    end
end
redef class ASlashMethid
    private init empty_init do end

    init init_aslashmethid (
            n_slash: nullable TSlash
    )
    do
        empty_init
        _n_slash = n_slash.as(not null)
	n_slash.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_slash == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TSlash
                _n_slash = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_slash)
    end
end
redef class APercentMethid
    private init empty_init do end

    init init_apercentmethid (
            n_percent: nullable TPercent
    )
    do
        empty_init
        _n_percent = n_percent.as(not null)
	n_percent.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_percent == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPercent
                _n_percent = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_percent)
    end
end
redef class AEqMethid
    private init empty_init do end

    init init_aeqmethid (
            n_eq: nullable TEq
    )
    do
        empty_init
        _n_eq = n_eq.as(not null)
	n_eq.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_eq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TEq
                _n_eq = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_eq)
    end
end
redef class ANeMethid
    private init empty_init do end

    init init_anemethid (
            n_ne: nullable TNe
    )
    do
        empty_init
        _n_ne = n_ne.as(not null)
	n_ne.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_ne == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TNe
                _n_ne = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_ne)
    end
end
redef class ALeMethid
    private init empty_init do end

    init init_alemethid (
            n_le: nullable TLe
    )
    do
        empty_init
        _n_le = n_le.as(not null)
	n_le.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_le == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TLe
                _n_le = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_le)
    end
end
redef class AGeMethid
    private init empty_init do end

    init init_agemethid (
            n_ge: nullable TGe
    )
    do
        empty_init
        _n_ge = n_ge.as(not null)
	n_ge.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_ge == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TGe
                _n_ge = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_ge)
    end
end
redef class ALtMethid
    private init empty_init do end

    init init_altmethid (
            n_lt: nullable TLt
    )
    do
        empty_init
        _n_lt = n_lt.as(not null)
	n_lt.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_lt == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TLt
                _n_lt = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_lt)
    end
end
redef class AGtMethid
    private init empty_init do end

    init init_agtmethid (
            n_gt: nullable TGt
    )
    do
        empty_init
        _n_gt = n_gt.as(not null)
	n_gt.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_gt == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TGt
                _n_gt = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_gt)
    end
end
redef class ALlMethid
    private init empty_init do end

    init init_allmethid (
            n_ll: nullable TLl
    )
    do
        empty_init
        _n_ll = n_ll.as(not null)
	n_ll.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_ll == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TLl
                _n_ll = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_ll)
    end
end
redef class AGgMethid
    private init empty_init do end

    init init_aggmethid (
            n_gg: nullable TGg
    )
    do
        empty_init
        _n_gg = n_gg.as(not null)
	n_gg.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_gg == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TGg
                _n_gg = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_gg)
    end
end
redef class ABraMethid
    private init empty_init do end

    init init_abramethid (
            n_obra: nullable TObra,
            n_cbra: nullable TCbra
    )
    do
        empty_init
        _n_obra = n_obra.as(not null)
	n_obra.parent = self
        _n_cbra = n_cbra.as(not null)
	n_cbra.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_obra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TObra
                _n_obra = new_child
	    else
		abort
            end
            return
	end
        if _n_cbra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TCbra
                _n_cbra = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_obra)
        v.enter_visit(_n_cbra)
    end
end
redef class AStarshipMethid
    private init empty_init do end

    init init_astarshipmethid (
            n_starship: nullable TStarship
    )
    do
        empty_init
        _n_starship = n_starship.as(not null)
	n_starship.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_starship == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStarship
                _n_starship = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_starship)
    end
end
redef class AAssignMethid
    private init empty_init do end

    init init_aassignmethid (
            n_id: nullable TId,
            n_assign: nullable TAssign
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
    end
end
redef class ABraassignMethid
    private init empty_init do end

    init init_abraassignmethid (
            n_obra: nullable TObra,
            n_cbra: nullable TCbra,
            n_assign: nullable TAssign
    )
    do
        empty_init
        _n_obra = n_obra.as(not null)
	n_obra.parent = self
        _n_cbra = n_cbra.as(not null)
	n_cbra.parent = self
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_obra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TObra
                _n_obra = new_child
	    else
		abort
            end
            return
	end
        if _n_cbra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TCbra
                _n_cbra = new_child
	    else
		abort
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_obra)
        v.enter_visit(_n_cbra)
        v.enter_visit(_n_assign)
    end
end
redef class ASignature
    private init empty_init do end

    init init_asignature (
            n_params: Collection[Object], # Should be Collection[AParam]
            n_type: nullable AType,
            n_closure_decls: Collection[Object] # Should be Collection[AClosureDecl]
    )
    do
        empty_init
	for n in n_params do
		assert n isa AParam
		_n_params.add(n)
		n.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
	for n in n_closure_decls do
		assert n isa AClosureDecl
		_n_closure_decls.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_params.length[ do
            if _n_params[i] == old_child then
                if new_child != null then
		    assert new_child isa AParam
                    _n_params[i] = new_child
                    new_child.parent = self
                else
                    _n_params.remove_at(i)
                end
                return
            end
        end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        for i in [0.._n_closure_decls.length[ do
            if _n_closure_decls[i] == old_child then
                if new_child != null then
		    assert new_child isa AClosureDecl
                    _n_closure_decls[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_decls.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_params do
                v.enter_visit(n)
	    end
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
            for n in _n_closure_decls do
                v.enter_visit(n)
	    end
    end
end
redef class AParam
    private init empty_init do end

    init init_aparam (
            n_id: nullable TId,
            n_type: nullable AType,
            n_dotdotdot: nullable TDotdotdot
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_dotdotdot = n_dotdotdot
	if n_dotdotdot != null then
		n_dotdotdot.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_dotdotdot == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TDotdotdot
                _n_dotdotdot = new_child
	    else
		_n_dotdotdot = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_dotdotdot != null then
            v.enter_visit(_n_dotdotdot.as(not null))
        end
    end
end
redef class AClosureDecl
    private init empty_init do end

    init init_aclosuredecl (
            n_kwbreak: nullable TKwbreak,
            n_bang: nullable TBang,
            n_id: nullable TId,
            n_signature: nullable ASignature,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_kwbreak = n_kwbreak
	if n_kwbreak != null then
		n_kwbreak.parent = self
	end
        _n_bang = n_bang.as(not null)
	n_bang.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwbreak == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwbreak
                _n_kwbreak = new_child
	    else
		_n_kwbreak = null
            end
            return
	end
        if _n_bang == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TBang
                _n_bang = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwbreak != null then
            v.enter_visit(_n_kwbreak.as(not null))
        end
        v.enter_visit(_n_bang)
        v.enter_visit(_n_id)
        v.enter_visit(_n_signature)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AType
    private init empty_init do end

    init init_atype (
            n_kwnullable: nullable TKwnullable,
            n_id: nullable TClassid,
            n_types: Collection[Object] # Should be Collection[AType]
    )
    do
        empty_init
        _n_kwnullable = n_kwnullable
	if n_kwnullable != null then
		n_kwnullable.parent = self
	end
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_types do
		assert n isa AType
		_n_types.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwnullable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnullable
                _n_kwnullable = new_child
	    else
		_n_kwnullable = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_types.length[ do
            if _n_types[i] == old_child then
                if new_child != null then
		    assert new_child isa AType
                    _n_types[i] = new_child
                    new_child.parent = self
                else
                    _n_types.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwnullable != null then
            v.enter_visit(_n_kwnullable.as(not null))
        end
        v.enter_visit(_n_id)
            for n in _n_types do
                v.enter_visit(n)
	    end
    end
end
redef class ALabel
    private init empty_init do end

    init init_alabel (
            n_kwlabel: nullable TKwlabel,
            n_id: nullable TId
    )
    do
        empty_init
        _n_kwlabel = n_kwlabel.as(not null)
	n_kwlabel.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwlabel == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwlabel
                _n_kwlabel = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwlabel)
        v.enter_visit(_n_id)
    end
end
redef class ABlockExpr
    private init empty_init do end

    init init_ablockexpr (
            n_expr: Collection[Object] # Should be Collection[AExpr]
    )
    do
        empty_init
	for n in n_expr do
		assert n isa AExpr
		_n_expr.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_expr.length[ do
            if _n_expr[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_expr[i] = new_child
                    new_child.parent = self
                else
                    _n_expr.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_expr do
                v.enter_visit(n)
	    end
    end
end
redef class AVardeclExpr
    private init empty_init do end

    init init_avardeclexpr (
            n_kwvar: nullable TKwvar,
            n_id: nullable TId,
            n_type: nullable AType,
            n_assign: nullable TAssign,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_kwvar = n_kwvar.as(not null)
	n_kwvar.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwvar == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwvar
                _n_kwvar = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwvar)
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_assign != null then
            v.enter_visit(_n_assign.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AReturnExpr
    private init empty_init do end

    init init_areturnexpr (
            n_kwreturn: nullable TKwreturn,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_kwreturn = n_kwreturn
	if n_kwreturn != null then
		n_kwreturn.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwreturn == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwreturn
                _n_kwreturn = new_child
	    else
		_n_kwreturn = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwreturn != null then
            v.enter_visit(_n_kwreturn.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class ABreakExpr
    private init empty_init do end

    init init_abreakexpr (
            n_kwbreak: nullable TKwbreak,
            n_label: nullable ALabel,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_kwbreak = n_kwbreak.as(not null)
	n_kwbreak.parent = self
        _n_label = n_label
	if n_label != null then
		n_label.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwbreak == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwbreak
                _n_kwbreak = new_child
	    else
		abort
            end
            return
	end
        if _n_label == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ALabel
                _n_label = new_child
	    else
		_n_label = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwbreak)
        if _n_label != null then
            v.enter_visit(_n_label.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AAbortExpr
    private init empty_init do end

    init init_aabortexpr (
            n_kwabort: nullable TKwabort
    )
    do
        empty_init
        _n_kwabort = n_kwabort.as(not null)
	n_kwabort.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwabort == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwabort
                _n_kwabort = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwabort)
    end
end
redef class AContinueExpr
    private init empty_init do end

    init init_acontinueexpr (
            n_kwcontinue: nullable TKwcontinue,
            n_label: nullable ALabel,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_kwcontinue = n_kwcontinue
	if n_kwcontinue != null then
		n_kwcontinue.parent = self
	end
        _n_label = n_label
	if n_label != null then
		n_label.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwcontinue == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwcontinue
                _n_kwcontinue = new_child
	    else
		_n_kwcontinue = null
            end
            return
	end
        if _n_label == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ALabel
                _n_label = new_child
	    else
		_n_label = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwcontinue != null then
            v.enter_visit(_n_kwcontinue.as(not null))
        end
        if _n_label != null then
            v.enter_visit(_n_label.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class ADoExpr
    private init empty_init do end

    init init_adoexpr (
            n_kwdo: nullable TKwdo,
            n_block: nullable AExpr,
            n_label: nullable ALabel
    )
    do
        empty_init
        _n_kwdo = n_kwdo.as(not null)
	n_kwdo.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
        _n_label = n_label
	if n_label != null then
		n_label.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
        if _n_label == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ALabel
                _n_label = new_child
	    else
		_n_label = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
        if _n_label != null then
            v.enter_visit(_n_label.as(not null))
        end
    end
end
redef class AIfExpr
    private init empty_init do end

    init init_aifexpr (
            n_kwif: nullable TKwif,
            n_expr: nullable AExpr,
            n_then: nullable AExpr,
            n_else: nullable AExpr
    )
    do
        empty_init
        _n_kwif = n_kwif.as(not null)
	n_kwif.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_then = n_then
	if n_then != null then
		n_then.parent = self
	end
        _n_else = n_else
	if n_else != null then
		n_else.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwif == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwif
                _n_kwif = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_then == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_then = new_child
	    else
		_n_then = null
            end
            return
	end
        if _n_else == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_else = new_child
	    else
		_n_else = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwif)
        v.enter_visit(_n_expr)
        if _n_then != null then
            v.enter_visit(_n_then.as(not null))
        end
        if _n_else != null then
            v.enter_visit(_n_else.as(not null))
        end
    end
end
redef class AIfexprExpr
    private init empty_init do end

    init init_aifexprexpr (
            n_kwif: nullable TKwif,
            n_expr: nullable AExpr,
            n_kwthen: nullable TKwthen,
            n_then: nullable AExpr,
            n_kwelse: nullable TKwelse,
            n_else: nullable AExpr
    )
    do
        empty_init
        _n_kwif = n_kwif.as(not null)
	n_kwif.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwthen = n_kwthen.as(not null)
	n_kwthen.parent = self
        _n_then = n_then.as(not null)
	n_then.parent = self
        _n_kwelse = n_kwelse.as(not null)
	n_kwelse.parent = self
        _n_else = n_else.as(not null)
	n_else.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwif == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwif
                _n_kwif = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwthen == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwthen
                _n_kwthen = new_child
	    else
		abort
            end
            return
	end
        if _n_then == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_then = new_child
	    else
		abort
            end
            return
	end
        if _n_kwelse == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwelse
                _n_kwelse = new_child
	    else
		abort
            end
            return
	end
        if _n_else == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_else = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwif)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwthen)
        v.enter_visit(_n_then)
        v.enter_visit(_n_kwelse)
        v.enter_visit(_n_else)
    end
end
redef class AWhileExpr
    private init empty_init do end

    init init_awhileexpr (
            n_kwwhile: nullable TKwwhile,
            n_expr: nullable AExpr,
            n_kwdo: nullable TKwdo,
            n_block: nullable AExpr,
            n_label: nullable ALabel
    )
    do
        empty_init
        _n_kwwhile = n_kwwhile.as(not null)
	n_kwwhile.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwdo = n_kwdo.as(not null)
	n_kwdo.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
        _n_label = n_label
	if n_label != null then
		n_label.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwwhile == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwhile
                _n_kwwhile = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
        if _n_label == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ALabel
                _n_label = new_child
	    else
		_n_label = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwwhile)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
        if _n_label != null then
            v.enter_visit(_n_label.as(not null))
        end
    end
end
redef class ALoopExpr
    private init empty_init do end

    init init_aloopexpr (
            n_kwloop: nullable TKwloop,
            n_block: nullable AExpr,
            n_label: nullable ALabel
    )
    do
        empty_init
        _n_kwloop = n_kwloop.as(not null)
	n_kwloop.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
        _n_label = n_label
	if n_label != null then
		n_label.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwloop == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwloop
                _n_kwloop = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
        if _n_label == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ALabel
                _n_label = new_child
	    else
		_n_label = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwloop)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
        if _n_label != null then
            v.enter_visit(_n_label.as(not null))
        end
    end
end
redef class AForExpr
    private init empty_init do end

    init init_aforexpr (
            n_kwfor: nullable TKwfor,
            n_id: nullable TId,
            n_expr: nullable AExpr,
            n_kwdo: nullable TKwdo,
            n_block: nullable AExpr,
            n_label: nullable ALabel
    )
    do
        empty_init
        _n_kwfor = n_kwfor.as(not null)
	n_kwfor.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwdo = n_kwdo.as(not null)
	n_kwdo.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
        _n_label = n_label
	if n_label != null then
		n_label.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwfor == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwfor
                _n_kwfor = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
        if _n_label == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ALabel
                _n_label = new_child
	    else
		_n_label = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwfor)
        v.enter_visit(_n_id)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
        if _n_label != null then
            v.enter_visit(_n_label.as(not null))
        end
    end
end
redef class AAssertExpr
    private init empty_init do end

    init init_aassertexpr (
            n_kwassert: nullable TKwassert,
            n_id: nullable TId,
            n_expr: nullable AExpr,
            n_else: nullable AExpr
    )
    do
        empty_init
        _n_kwassert = n_kwassert.as(not null)
	n_kwassert.parent = self
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_else = n_else
	if n_else != null then
		n_else.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwassert == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwassert
                _n_kwassert = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_else == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_else = new_child
	    else
		_n_else = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwassert)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
        v.enter_visit(_n_expr)
        if _n_else != null then
            v.enter_visit(_n_else.as(not null))
        end
    end
end
redef class AOnceExpr
    private init empty_init do end

    init init_aonceexpr (
            n_kwonce: nullable TKwonce,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_kwonce = n_kwonce.as(not null)
	n_kwonce.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwonce == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwonce
                _n_kwonce = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwonce)
        v.enter_visit(_n_expr)
    end
end
redef class ASendExpr
    private init empty_init do end

    init init_asendexpr (
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
    end
end
redef class ABinopExpr
    private init empty_init do end

    init init_abinopexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AOrExpr
    private init empty_init do end

    init init_aorexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AAndExpr
    private init empty_init do end

    init init_aandexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AOrElseExpr
    private init empty_init do end

    init init_aorelseexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ANotExpr
    private init empty_init do end

    init init_anotexpr (
            n_kwnot: nullable TKwnot,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_kwnot = n_kwnot.as(not null)
	n_kwnot.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwnot == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnot
                _n_kwnot = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwnot)
        v.enter_visit(_n_expr)
    end
end
redef class AEqExpr
    private init empty_init do end

    init init_aeqexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AEeExpr
    private init empty_init do end

    init init_aeeexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ANeExpr
    private init empty_init do end

    init init_aneexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ALtExpr
    private init empty_init do end

    init init_altexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ALeExpr
    private init empty_init do end

    init init_aleexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ALlExpr
    private init empty_init do end

    init init_allexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AGtExpr
    private init empty_init do end

    init init_agtexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AGeExpr
    private init empty_init do end

    init init_ageexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AGgExpr
    private init empty_init do end

    init init_aggexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AIsaExpr
    private init empty_init do end

    init init_aisaexpr (
            n_expr: nullable AExpr,
            n_type: nullable AType
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_type)
    end
end
redef class APlusExpr
    private init empty_init do end

    init init_aplusexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AMinusExpr
    private init empty_init do end

    init init_aminusexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AStarshipExpr
    private init empty_init do end

    init init_astarshipexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AStarExpr
    private init empty_init do end

    init init_astarexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ASlashExpr
    private init empty_init do end

    init init_aslashexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class APercentExpr
    private init empty_init do end

    init init_apercentexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AUminusExpr
    private init empty_init do end

    init init_auminusexpr (
            n_minus: nullable TMinus,
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_minus = n_minus.as(not null)
	n_minus.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_minus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinus
                _n_minus = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_minus)
        v.enter_visit(_n_expr)
    end
end
redef class ANewExpr
    private init empty_init do end

    init init_anewexpr (
            n_kwnew: nullable TKwnew,
            n_type: nullable AType,
            n_id: nullable TId,
            n_args: Collection[Object] # Should be Collection[AExpr]
    )
    do
        empty_init
        _n_kwnew = n_kwnew.as(not null)
	n_kwnew.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwnew == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnew
                _n_kwnew = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwnew)
        v.enter_visit(_n_type)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
            for n in _n_args do
                v.enter_visit(n)
	    end
    end
end
redef class AAttrExpr
    private init empty_init do end

    init init_aattrexpr (
            n_expr: nullable AExpr,
            n_id: nullable TAttrid
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
    end
end
redef class AAttrAssignExpr
    private init empty_init do end

    init init_aattrassignexpr (
            n_expr: nullable AExpr,
            n_id: nullable TAttrid,
            n_assign: nullable TAssign,
            n_value: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end
end
redef class AAttrReassignExpr
    private init empty_init do end

    init init_aattrreassignexpr (
            n_expr: nullable AExpr,
            n_id: nullable TAttrid,
            n_assign_op: nullable AAssignOp,
            n_value: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign_op = n_assign_op.as(not null)
	n_assign_op.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAssignOp
                _n_assign_op = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end
end
redef class ACallExpr
    private init empty_init do end

    init init_acallexpr (
            n_expr: nullable AExpr,
            n_id: nullable TId,
            n_args: Collection[Object], # Should be Collection[AExpr]
            n_closure_defs: Collection[Object] # Should be Collection[AClosureDef]
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
	for n in n_closure_defs do
		assert n isa AClosureDef
		_n_closure_defs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_closure_defs.length[ do
            if _n_closure_defs[i] == old_child then
                if new_child != null then
		    assert new_child isa AClosureDef
                    _n_closure_defs[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_defs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
            for n in _n_args do
                v.enter_visit(n)
	    end
            for n in _n_closure_defs do
                v.enter_visit(n)
	    end
    end
end
redef class ACallAssignExpr
    private init empty_init do end

    init init_acallassignexpr (
            n_expr: nullable AExpr,
            n_id: nullable TId,
            n_args: Collection[Object], # Should be Collection[AExpr]
            n_assign: nullable TAssign,
            n_value: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
            for n in _n_args do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end
end
redef class ACallReassignExpr
    private init empty_init do end

    init init_acallreassignexpr (
            n_expr: nullable AExpr,
            n_id: nullable TId,
            n_args: Collection[Object], # Should be Collection[AExpr]
            n_assign_op: nullable AAssignOp,
            n_value: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign_op = n_assign_op.as(not null)
	n_assign_op.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAssignOp
                _n_assign_op = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
            for n in _n_args do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end
end
redef class ASuperExpr
    private init empty_init do end

    init init_asuperexpr (
            n_qualified: nullable AQualified,
            n_kwsuper: nullable TKwsuper,
            n_args: Collection[Object] # Should be Collection[AExpr]
    )
    do
        empty_init
        _n_qualified = n_qualified
	if n_qualified != null then
		n_qualified.parent = self
	end
        _n_kwsuper = n_kwsuper.as(not null)
	n_kwsuper.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_qualified == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AQualified
                _n_qualified = new_child
	    else
		_n_qualified = null
            end
            return
	end
        if _n_kwsuper == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwsuper
                _n_kwsuper = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_qualified != null then
            v.enter_visit(_n_qualified.as(not null))
        end
        v.enter_visit(_n_kwsuper)
            for n in _n_args do
                v.enter_visit(n)
	    end
    end
end
redef class AInitExpr
    private init empty_init do end

    init init_ainitexpr (
            n_expr: nullable AExpr,
            n_kwinit: nullable TKwinit,
            n_args: Collection[Object] # Should be Collection[AExpr]
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwinit = n_kwinit.as(not null)
	n_kwinit.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwinit == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinit
                _n_kwinit = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwinit)
            for n in _n_args do
                v.enter_visit(n)
	    end
    end
end
redef class ABraExpr
    private init empty_init do end

    init init_abraexpr (
            n_expr: nullable AExpr,
            n_args: Collection[Object], # Should be Collection[AExpr]
            n_closure_defs: Collection[Object] # Should be Collection[AClosureDef]
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
	for n in n_closure_defs do
		assert n isa AClosureDef
		_n_closure_defs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_closure_defs.length[ do
            if _n_closure_defs[i] == old_child then
                if new_child != null then
		    assert new_child isa AClosureDef
                    _n_closure_defs[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_defs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
            for n in _n_args do
                v.enter_visit(n)
	    end
            for n in _n_closure_defs do
                v.enter_visit(n)
	    end
    end
end
redef class ABraAssignExpr
    private init empty_init do end

    init init_abraassignexpr (
            n_expr: nullable AExpr,
            n_args: Collection[Object], # Should be Collection[AExpr]
            n_assign: nullable TAssign,
            n_value: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
            for n in _n_args do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end
end
redef class ABraReassignExpr
    private init empty_init do end

    init init_abrareassignexpr (
            n_expr: nullable AExpr,
            n_args: Collection[Object], # Should be Collection[AExpr]
            n_assign_op: nullable AAssignOp,
            n_value: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign_op = n_assign_op.as(not null)
	n_assign_op.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAssignOp
                _n_assign_op = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
            for n in _n_args do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end
end
redef class AClosureCallExpr
    private init empty_init do end

    init init_aclosurecallexpr (
            n_id: nullable TId,
            n_args: Collection[Object], # Should be Collection[AExpr]
            n_closure_defs: Collection[Object] # Should be Collection[AClosureDef]
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
	for n in n_closure_defs do
		assert n isa AClosureDef
		_n_closure_defs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_closure_defs.length[ do
            if _n_closure_defs[i] == old_child then
                if new_child != null then
		    assert new_child isa AClosureDef
                    _n_closure_defs[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_defs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
            for n in _n_args do
                v.enter_visit(n)
	    end
            for n in _n_closure_defs do
                v.enter_visit(n)
	    end
    end
end
redef class AVarExpr
    private init empty_init do end

    init init_avarexpr (
            n_id: nullable TId
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
    end
end
redef class AVarAssignExpr
    private init empty_init do end

    init init_avarassignexpr (
            n_id: nullable TId,
            n_assign: nullable TAssign,
            n_value: nullable AExpr
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end
end
redef class AVarReassignExpr
    private init empty_init do end

    init init_avarreassignexpr (
            n_id: nullable TId,
            n_assign_op: nullable AAssignOp,
            n_value: nullable AExpr
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign_op = n_assign_op.as(not null)
	n_assign_op.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAssignOp
                _n_assign_op = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end
end
redef class ARangeExpr
    private init empty_init do end

    init init_arangeexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ACrangeExpr
    private init empty_init do end

    init init_acrangeexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AOrangeExpr
    private init empty_init do end

    init init_aorangeexpr (
            n_expr: nullable AExpr,
            n_expr2: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AArrayExpr
    private init empty_init do end

    init init_aarrayexpr (
            n_exprs: Collection[Object] # Should be Collection[AExpr]
    )
    do
        empty_init
	for n in n_exprs do
		assert n isa AExpr
		_n_exprs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_exprs.length[ do
            if _n_exprs[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_exprs[i] = new_child
                    new_child.parent = self
                else
                    _n_exprs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_exprs do
                v.enter_visit(n)
	    end
    end
end
redef class ASelfExpr
    private init empty_init do end

    init init_aselfexpr (
            n_kwself: nullable TKwself
    )
    do
        empty_init
        _n_kwself = n_kwself.as(not null)
	n_kwself.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwself == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwself
                _n_kwself = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwself)
    end
end
redef class AImplicitSelfExpr
    private init empty_init do end

    init init_aimplicitselfexpr
    do
        empty_init
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
    end

    redef fun visit_all(v: Visitor)
    do
    end
end
redef class ATrueExpr
    private init empty_init do end

    init init_atrueexpr (
            n_kwtrue: nullable TKwtrue
    )
    do
        empty_init
        _n_kwtrue = n_kwtrue.as(not null)
	n_kwtrue.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwtrue == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwtrue
                _n_kwtrue = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwtrue)
    end
end
redef class AFalseExpr
    private init empty_init do end

    init init_afalseexpr (
            n_kwfalse: nullable TKwfalse
    )
    do
        empty_init
        _n_kwfalse = n_kwfalse.as(not null)
	n_kwfalse.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwfalse == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwfalse
                _n_kwfalse = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwfalse)
    end
end
redef class ANullExpr
    private init empty_init do end

    init init_anullexpr (
            n_kwnull: nullable TKwnull
    )
    do
        empty_init
        _n_kwnull = n_kwnull.as(not null)
	n_kwnull.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwnull == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnull
                _n_kwnull = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwnull)
    end
end
redef class AIntExpr
    private init empty_init do end

    init init_aintexpr (
            n_number: nullable TNumber
    )
    do
        empty_init
        _n_number = n_number.as(not null)
	n_number.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_number == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TNumber
                _n_number = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_number)
    end
end
redef class AFloatExpr
    private init empty_init do end

    init init_afloatexpr (
            n_float: nullable TFloat
    )
    do
        empty_init
        _n_float = n_float.as(not null)
	n_float.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_float == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TFloat
                _n_float = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_float)
    end
end
redef class ACharExpr
    private init empty_init do end

    init init_acharexpr (
            n_char: nullable TChar
    )
    do
        empty_init
        _n_char = n_char.as(not null)
	n_char.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_char == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TChar
                _n_char = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_char)
    end
end
redef class AStringExpr
    private init empty_init do end

    init init_astringexpr (
            n_string: nullable TString
    )
    do
        empty_init
        _n_string = n_string.as(not null)
	n_string.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TString
                _n_string = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_string)
    end
end
redef class AStartStringExpr
    private init empty_init do end

    init init_astartstringexpr (
            n_string: nullable TStartString
    )
    do
        empty_init
        _n_string = n_string.as(not null)
	n_string.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStartString
                _n_string = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_string)
    end
end
redef class AMidStringExpr
    private init empty_init do end

    init init_amidstringexpr (
            n_string: nullable TMidString
    )
    do
        empty_init
        _n_string = n_string.as(not null)
	n_string.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMidString
                _n_string = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_string)
    end
end
redef class AEndStringExpr
    private init empty_init do end

    init init_aendstringexpr (
            n_string: nullable TEndString
    )
    do
        empty_init
        _n_string = n_string.as(not null)
	n_string.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TEndString
                _n_string = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_string)
    end
end
redef class ASuperstringExpr
    private init empty_init do end

    init init_asuperstringexpr (
            n_exprs: Collection[Object] # Should be Collection[AExpr]
    )
    do
        empty_init
	for n in n_exprs do
		assert n isa AExpr
		_n_exprs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_exprs.length[ do
            if _n_exprs[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_exprs[i] = new_child
                    new_child.parent = self
                else
                    _n_exprs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_exprs do
                v.enter_visit(n)
	    end
    end
end
redef class AParExpr
    private init empty_init do end

    init init_aparexpr (
            n_expr: nullable AExpr
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
    end
end
redef class AAsCastExpr
    private init empty_init do end

    init init_aascastexpr (
            n_expr: nullable AExpr,
            n_kwas: nullable TKwas,
            n_type: nullable AType
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwas = n_kwas.as(not null)
	n_kwas.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwas == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwas
                _n_kwas = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwas)
        v.enter_visit(_n_type)
    end
end
redef class AAsNotnullExpr
    private init empty_init do end

    init init_aasnotnullexpr (
            n_expr: nullable AExpr,
            n_kwas: nullable TKwas,
            n_kwnot: nullable TKwnot,
            n_kwnull: nullable TKwnull
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwas = n_kwas.as(not null)
	n_kwas.parent = self
        _n_kwnot = n_kwnot.as(not null)
	n_kwnot.parent = self
        _n_kwnull = n_kwnull.as(not null)
	n_kwnull.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwas == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwas
                _n_kwas = new_child
	    else
		abort
            end
            return
	end
        if _n_kwnot == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnot
                _n_kwnot = new_child
	    else
		abort
            end
            return
	end
        if _n_kwnull == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnull
                _n_kwnull = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwas)
        v.enter_visit(_n_kwnot)
        v.enter_visit(_n_kwnull)
    end
end
redef class AIssetAttrExpr
    private init empty_init do end

    init init_aissetattrexpr (
            n_kwisset: nullable TKwisset,
            n_expr: nullable AExpr,
            n_id: nullable TAttrid
    )
    do
        empty_init
        _n_kwisset = n_kwisset.as(not null)
	n_kwisset.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwisset == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwisset
                _n_kwisset = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwisset)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
    end
end
redef class APlusAssignOp
    private init empty_init do end

    init init_aplusassignop (
            n_pluseq: nullable TPluseq
    )
    do
        empty_init
        _n_pluseq = n_pluseq.as(not null)
	n_pluseq.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_pluseq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPluseq
                _n_pluseq = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_pluseq)
    end
end
redef class AMinusAssignOp
    private init empty_init do end

    init init_aminusassignop (
            n_minuseq: nullable TMinuseq
    )
    do
        empty_init
        _n_minuseq = n_minuseq.as(not null)
	n_minuseq.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_minuseq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinuseq
                _n_minuseq = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_minuseq)
    end
end
redef class AClosureDef
    private init empty_init do end

    init init_aclosuredef (
            n_bang: nullable TBang,
            n_id: nullable AClosureId,
            n_ids: Collection[Object], # Should be Collection[TId]
            n_kwdo: nullable TKwdo,
            n_expr: nullable AExpr,
            n_label: nullable ALabel
    )
    do
        empty_init
        _n_bang = n_bang.as(not null)
	n_bang.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_ids do
		assert n isa TId
		_n_ids.add(n)
		n.parent = self
	end
        _n_kwdo = n_kwdo
	if n_kwdo != null then
		n_kwdo.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_label = n_label
	if n_label != null then
		n_label.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_bang == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TBang
                _n_bang = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AClosureId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_ids.length[ do
            if _n_ids[i] == old_child then
                if new_child != null then
		    assert new_child isa TId
                    _n_ids[i] = new_child
                    new_child.parent = self
                else
                    _n_ids.remove_at(i)
                end
                return
            end
        end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		_n_kwdo = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_label == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ALabel
                _n_label = new_child
	    else
		_n_label = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_bang)
        v.enter_visit(_n_id)
            for n in _n_ids do
                v.enter_visit(n)
	    end
        if _n_kwdo != null then
            v.enter_visit(_n_kwdo.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
        if _n_label != null then
            v.enter_visit(_n_label.as(not null))
        end
    end
end
redef class ASimpleClosureId
    private init empty_init do end

    init init_asimpleclosureid (
            n_id: nullable TId
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
    end
end
redef class ABreakClosureId
    private init empty_init do end

    init init_abreakclosureid (
            n_kwbreak: nullable TKwbreak
    )
    do
        empty_init
        _n_kwbreak = n_kwbreak.as(not null)
	n_kwbreak.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwbreak == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwbreak
                _n_kwbreak = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwbreak)
    end
end
redef class AQualified
    private init empty_init do end

    init init_aqualified (
            n_id: Collection[Object], # Should be Collection[TId]
            n_classid: nullable TClassid
    )
    do
        empty_init
	for n in n_id do
		assert n isa TId
		_n_id.add(n)
		n.parent = self
	end
        _n_classid = n_classid
	if n_classid != null then
		n_classid.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_id.length[ do
            if _n_id[i] == old_child then
                if new_child != null then
		    assert new_child isa TId
                    _n_id[i] = new_child
                    new_child.parent = self
                else
                    _n_id.remove_at(i)
                end
                return
            end
        end
        if _n_classid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_classid = new_child
	    else
		_n_classid = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_id do
                v.enter_visit(n)
	    end
        if _n_classid != null then
            v.enter_visit(_n_classid.as(not null))
        end
    end
end
redef class ADoc
    private init empty_init do end

    init init_adoc (
            n_comment: Collection[Object] # Should be Collection[TComment]
    )
    do
        empty_init
	for n in n_comment do
		assert n isa TComment
		_n_comment.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_comment.length[ do
            if _n_comment[i] == old_child then
                if new_child != null then
		    assert new_child isa TComment
                    _n_comment[i] = new_child
                    new_child.parent = self
                else
                    _n_comment.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_comment do
                v.enter_visit(n)
	    end
    end
end

redef class Start
    init(
        n_base: nullable AModule,
        n_eof: EOF)
    do
        _n_base = n_base
        _n_eof = n_eof
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_base == old_child then
            if new_child == null then
            else
                new_child.parent = self
		assert new_child isa AModule
                _n_base = new_child
            end
            old_child.parent = null
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_base != null then
            v.enter_visit(_n_base.as(not null))
        end
	v.enter_visit(_n_eof)
    end
end
