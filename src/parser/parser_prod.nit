# Production AST nodes full definition.
# This file was generated by SableCC (http://www.sablecc.org/). 
package parser_prod

import lexer
intrude import parser_nodes

redef class PNode
	# Parent of the node in the AST
	readable writable attr _parent: PNode 

	# Remove a child from the AST
	meth remove_child(child: PNode)
	do
		replace_child(child, null)
	end

	# Replace a child with an other node in the AST
	meth replace_child(old_child: PNode, new_child: PNode) is abstract

	# Replace itself with an other node in the AST
	meth replace_with(node: PNode)
	do
		if (_parent != null) then
			_parent.replace_child(self, node)
		end
	end

	# Visit all nodes in order.
	# Thus, call "v.visit(e)" for each node e
	meth visit_all(v: Visitor) is abstract

	# Visit all nodes in reverse order.
	# Thus, call "v.visit(e)" for each node e starting from the last child
	meth visit_all_reverse(v: Visitor) is abstract

	# Give a human readable location of the node.
	meth locate: String is abstract

	# Return only the line number of the node
	meth line_number: Int is abstract

	# Debug method: output a message prefixed with the location.
	meth printl(str: String)
	do
		print("{locate}: {str}\n")
	end
end

redef class Token
	redef meth visit_all(v: Visitor) do end
	redef meth visit_all_reverse(v: Visitor) do end
	redef meth replace_child(old_child: PNode, new_child: PNode) do end

	redef meth locate: String
	do
		return "{filename}:{line},{pos}"
	end

	redef meth line_number do return line
end

redef class Prod
	# The first token of the production node
	readable writable attr _first_token: Token 

	# The last token of the production node
	readable writable attr _last_token: Token 

	redef meth locate: String
	do
		if first_token == null then
			return "????"
		end
		if last_token == null then
			return "{first_token.locate}--????"
		end
		var lastpos = last_token.pos + last_token.text.length - 1
		if first_token.line == last_token.line then
			return "{first_token.locate}--{lastpos}"
		else
			return "{first_token.locate}--{last_token.line}:{lastpos}"
		end
	end

	redef meth replace_with(n: PNode)
        do
                super
                assert n isa Prod
                n.first_token = first_token
                n.last_token = last_token
        end

	redef meth line_number
	do
		if first_token != null then
			return first_token.line
		else
			return 0
		end
	end
end

# Abstract standard visitor
class Visitor
        # Ask the visitor to visit a given node.
        # Usually automatically called by visit_all* methods.
        # Concrete visitors should redefine this method.
        meth visit(e: PNode) is abstract
end

redef class AModule
    redef meth n_packagedecl=(n: PPackagedecl)
    do
        _n_packagedecl = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_amodule (
            n_packagedecl: PPackagedecl ,
            n_imports: Collection[Object] , # Should be Collection[PImport]
            n_classdefs: Collection[Object]  # Should be Collection[PClassdef]
    )
    do
        empty_init
        _n_packagedecl = n_packagedecl
	if n_packagedecl != null then
		n_packagedecl.parent = self
	end
        _n_imports = new List[PImport]
	for n in n_imports do
		assert n isa PImport
		_n_imports.add(n)
		n.parent = self
	end
        _n_classdefs = new List[PClassdef]
	for n in n_classdefs do
		assert n isa PClassdef
		_n_classdefs.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_packagedecl == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PPackagedecl
                _n_packagedecl = new_child
	    else
		_n_packagedecl = null
            end
            return
	end
        for i in [0.._n_imports.length[ do
            if _n_imports[i] == old_child then
                if new_child != null then
		    assert new_child isa PImport
                    _n_imports[i] = new_child
                    new_child.parent = self
                else
                    _n_imports.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_classdefs.length[ do
            if _n_classdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa PClassdef
                    _n_classdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_classdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_packagedecl != null then
            v.visit(_n_packagedecl)
        end
            for n in _n_imports do
                v.visit(n)
	    end
            for n in _n_classdefs do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_packagedecl != null then
            v.visit(_n_packagedecl)
        end
	do
	    var i = _n_imports.length
            while i >= 0 do
                v.visit(_n_imports[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_classdefs.length
            while i >= 0 do
                v.visit(_n_classdefs[i])
		i = i - 1
	    end
	end
    end
end
redef class APackagedecl
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwpackage=(n: TKwpackage)
    do
        _n_kwpackage = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_apackagedecl (
            n_doc: PDoc ,
            n_kwpackage: TKwpackage ,
            n_id: TId 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwpackage = n_kwpackage
	if n_kwpackage != null then
		n_kwpackage.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwpackage == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwpackage
                _n_kwpackage = new_child
	    else
		_n_kwpackage = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwpackage != null then
            v.visit(_n_kwpackage)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwpackage != null then
            v.visit(_n_kwpackage)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
    end
end
redef class AImport
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwimport=(n: TKwimport)
    do
        _n_kwimport = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aimport (
            n_visibility: PVisibility ,
            n_kwimport: TKwimport ,
            n_id: TId 
    )
    do
        empty_init
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwimport = n_kwimport
	if n_kwimport != null then
		n_kwimport.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwimport == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwimport
                _n_kwimport = new_child
	    else
		_n_kwimport = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwimport != null then
            v.visit(_n_kwimport)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwimport != null then
            v.visit(_n_kwimport)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
    end
end
redef class ANoImport
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwimport=(n: TKwimport)
    do
        _n_kwimport = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwend=(n: TKwend)
    do
        _n_kwend = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_anoimport (
            n_visibility: PVisibility ,
            n_kwimport: TKwimport ,
            n_kwend: TKwend 
    )
    do
        empty_init
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwimport = n_kwimport
	if n_kwimport != null then
		n_kwimport.parent = self
	end
        _n_kwend = n_kwend
	if n_kwend != null then
		n_kwend.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwimport == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwimport
                _n_kwimport = new_child
	    else
		_n_kwimport = null
            end
            return
	end
        if _n_kwend == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwend
                _n_kwend = new_child
	    else
		_n_kwend = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwimport != null then
            v.visit(_n_kwimport)
        end
        if _n_kwend != null then
            v.visit(_n_kwend)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwimport != null then
            v.visit(_n_kwimport)
        end
        if _n_kwend != null then
            v.visit(_n_kwend)
        end
    end
end
redef class APublicVisibility

    private init empty_init do end

    init init_apublicvisibility
    do
        empty_init
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
    end

    redef meth visit_all(v: Visitor)
    do
    end

    redef meth visit_all_reverse(v: Visitor)
    do
    end
end
redef class APrivateVisibility
    redef meth n_kwprivate=(n: TKwprivate)
    do
        _n_kwprivate = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aprivatevisibility (
            n_kwprivate: TKwprivate 
    )
    do
        empty_init
        _n_kwprivate = n_kwprivate
	if n_kwprivate != null then
		n_kwprivate.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwprivate == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwprivate
                _n_kwprivate = new_child
	    else
		_n_kwprivate = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwprivate != null then
            v.visit(_n_kwprivate)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwprivate != null then
            v.visit(_n_kwprivate)
        end
    end
end
redef class AProtectedVisibility
    redef meth n_kwprotected=(n: TKwprotected)
    do
        _n_kwprotected = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aprotectedvisibility (
            n_kwprotected: TKwprotected 
    )
    do
        empty_init
        _n_kwprotected = n_kwprotected
	if n_kwprotected != null then
		n_kwprotected.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwprotected == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwprotected
                _n_kwprotected = new_child
	    else
		_n_kwprotected = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwprotected != null then
            v.visit(_n_kwprotected)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwprotected != null then
            v.visit(_n_kwprotected)
        end
    end
end
redef class AIntrudeVisibility
    redef meth n_kwintrude=(n: TKwintrude)
    do
        _n_kwintrude = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aintrudevisibility (
            n_kwintrude: TKwintrude 
    )
    do
        empty_init
        _n_kwintrude = n_kwintrude
	if n_kwintrude != null then
		n_kwintrude.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwintrude == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwintrude
                _n_kwintrude = new_child
	    else
		_n_kwintrude = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwintrude != null then
            v.visit(_n_kwintrude)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwintrude != null then
            v.visit(_n_kwintrude)
        end
    end
end
redef class AClassdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_classkind=(n: PClasskind)
    do
        _n_classkind = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TClassid)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aclassdef (
            n_doc: PDoc ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_classkind: PClasskind ,
            n_id: TClassid ,
            n_formaldefs: Collection[Object] , # Should be Collection[PFormaldef]
            n_superclasses: Collection[Object] , # Should be Collection[PSuperclass]
            n_propdefs: Collection[Object]  # Should be Collection[PPropdef]
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_classkind = n_classkind
	if n_classkind != null then
		n_classkind.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_formaldefs = new List[PFormaldef]
	for n in n_formaldefs do
		assert n isa PFormaldef
		_n_formaldefs.add(n)
		n.parent = self
	end
        _n_superclasses = new List[PSuperclass]
	for n in n_superclasses do
		assert n isa PSuperclass
		_n_superclasses.add(n)
		n.parent = self
	end
        _n_propdefs = new List[PPropdef]
	for n in n_propdefs do
		assert n isa PPropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_classkind == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PClasskind
                _n_classkind = new_child
	    else
		_n_classkind = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_formaldefs.length[ do
            if _n_formaldefs[i] == old_child then
                if new_child != null then
		    assert new_child isa PFormaldef
                    _n_formaldefs[i] = new_child
                    new_child.parent = self
                else
                    _n_formaldefs.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_superclasses.length[ do
            if _n_superclasses[i] == old_child then
                if new_child != null then
		    assert new_child isa PSuperclass
                    _n_superclasses[i] = new_child
                    new_child.parent = self
                else
                    _n_superclasses.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa PPropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_classkind != null then
            v.visit(_n_classkind)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
            for n in _n_formaldefs do
                v.visit(n)
	    end
            for n in _n_superclasses do
                v.visit(n)
	    end
            for n in _n_propdefs do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_classkind != null then
            v.visit(_n_classkind)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
	do
	    var i = _n_formaldefs.length
            while i >= 0 do
                v.visit(_n_formaldefs[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_superclasses.length
            while i >= 0 do
                v.visit(_n_superclasses[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_propdefs.length
            while i >= 0 do
                v.visit(_n_propdefs[i])
		i = i - 1
	    end
	end
    end
end
redef class ATopClassdef

    private init empty_init do end

    init init_atopclassdef (
            n_propdefs: Collection[Object]  # Should be Collection[PPropdef]
    )
    do
        empty_init
        _n_propdefs = new List[PPropdef]
	for n in n_propdefs do
		assert n isa PPropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa PPropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
            for n in _n_propdefs do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_propdefs.length
            while i >= 0 do
                v.visit(_n_propdefs[i])
		i = i - 1
	    end
	end
    end
end
redef class AMainClassdef

    private init empty_init do end

    init init_amainclassdef (
            n_propdefs: Collection[Object]  # Should be Collection[PPropdef]
    )
    do
        empty_init
        _n_propdefs = new List[PPropdef]
	for n in n_propdefs do
		assert n isa PPropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa PPropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
            for n in _n_propdefs do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_propdefs.length
            while i >= 0 do
                v.visit(_n_propdefs[i])
		i = i - 1
	    end
	end
    end
end
redef class AConcreteClasskind
    redef meth n_kwclass=(n: TKwclass)
    do
        _n_kwclass = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aconcreteclasskind (
            n_kwclass: TKwclass 
    )
    do
        empty_init
        _n_kwclass = n_kwclass
	if n_kwclass != null then
		n_kwclass.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwclass == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwclass
                _n_kwclass = new_child
	    else
		_n_kwclass = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwclass != null then
            v.visit(_n_kwclass)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwclass != null then
            v.visit(_n_kwclass)
        end
    end
end
redef class AAbstractClasskind
    redef meth n_kwabstract=(n: TKwabstract)
    do
        _n_kwabstract = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwclass=(n: TKwclass)
    do
        _n_kwclass = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aabstractclasskind (
            n_kwabstract: TKwabstract ,
            n_kwclass: TKwclass 
    )
    do
        empty_init
        _n_kwabstract = n_kwabstract
	if n_kwabstract != null then
		n_kwabstract.parent = self
	end
        _n_kwclass = n_kwclass
	if n_kwclass != null then
		n_kwclass.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwabstract == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwabstract
                _n_kwabstract = new_child
	    else
		_n_kwabstract = null
            end
            return
	end
        if _n_kwclass == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwclass
                _n_kwclass = new_child
	    else
		_n_kwclass = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwabstract != null then
            v.visit(_n_kwabstract)
        end
        if _n_kwclass != null then
            v.visit(_n_kwclass)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwabstract != null then
            v.visit(_n_kwabstract)
        end
        if _n_kwclass != null then
            v.visit(_n_kwclass)
        end
    end
end
redef class AInterfaceClasskind
    redef meth n_kwinterface=(n: TKwinterface)
    do
        _n_kwinterface = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_ainterfaceclasskind (
            n_kwinterface: TKwinterface 
    )
    do
        empty_init
        _n_kwinterface = n_kwinterface
	if n_kwinterface != null then
		n_kwinterface.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwinterface == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinterface
                _n_kwinterface = new_child
	    else
		_n_kwinterface = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwinterface != null then
            v.visit(_n_kwinterface)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwinterface != null then
            v.visit(_n_kwinterface)
        end
    end
end
redef class AUniversalClasskind
    redef meth n_kwuniversal=(n: TKwuniversal)
    do
        _n_kwuniversal = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_auniversalclasskind (
            n_kwuniversal: TKwuniversal 
    )
    do
        empty_init
        _n_kwuniversal = n_kwuniversal
	if n_kwuniversal != null then
		n_kwuniversal.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwuniversal == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwuniversal
                _n_kwuniversal = new_child
	    else
		_n_kwuniversal = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwuniversal != null then
            v.visit(_n_kwuniversal)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwuniversal != null then
            v.visit(_n_kwuniversal)
        end
    end
end
redef class AFormaldef
    redef meth n_id=(n: TClassid)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aformaldef (
            n_id: TClassid ,
            n_type: PType 
    )
    do
        empty_init
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end
end
redef class ASuperclass
    redef meth n_kwspecial=(n: TKwspecial)
    do
        _n_kwspecial = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_asuperclass (
            n_kwspecial: TKwspecial ,
            n_type: PType 
    )
    do
        empty_init
        _n_kwspecial = n_kwspecial
	if n_kwspecial != null then
		n_kwspecial.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwspecial == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwspecial
                _n_kwspecial = new_child
	    else
		_n_kwspecial = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwspecial != null then
            v.visit(_n_kwspecial)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwspecial != null then
            v.visit(_n_kwspecial)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end
end
redef class AAttrPropdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_readable=(n: PAble)
    do
        _n_readable = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_writable=(n: PAble)
    do
        _n_writable = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwattr=(n: TKwattr)
    do
        _n_kwattr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwvar=(n: TKwvar)
    do
        _n_kwvar = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TAttrid)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aattrpropdef (
            n_doc: PDoc ,
            n_readable: PAble ,
            n_writable: PAble ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_kwattr: TKwattr ,
            n_kwvar: TKwvar ,
            n_id: TAttrid ,
            n_type: PType ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_readable = n_readable
	if n_readable != null then
		n_readable.parent = self
	end
        _n_writable = n_writable
	if n_writable != null then
		n_writable.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwattr = n_kwattr
	if n_kwattr != null then
		n_kwattr.parent = self
	end
        _n_kwvar = n_kwvar
	if n_kwvar != null then
		n_kwvar.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_readable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PAble
                _n_readable = new_child
	    else
		_n_readable = null
            end
            return
	end
        if _n_writable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PAble
                _n_writable = new_child
	    else
		_n_writable = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwattr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwattr
                _n_kwattr = new_child
	    else
		_n_kwattr = null
            end
            return
	end
        if _n_kwvar == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwvar
                _n_kwvar = new_child
	    else
		_n_kwvar = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_readable != null then
            v.visit(_n_readable)
        end
        if _n_writable != null then
            v.visit(_n_writable)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwattr != null then
            v.visit(_n_kwattr)
        end
        if _n_kwvar != null then
            v.visit(_n_kwvar)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_readable != null then
            v.visit(_n_readable)
        end
        if _n_writable != null then
            v.visit(_n_writable)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwattr != null then
            v.visit(_n_kwattr)
        end
        if _n_kwvar != null then
            v.visit(_n_kwvar)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class AMethPropdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_methid=(n: PMethid)
    do
        _n_methid = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_signature=(n: PSignature)
    do
        _n_signature = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_amethpropdef (
            n_doc: PDoc ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_methid: PMethid ,
            n_signature: PSignature 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_methid = n_methid
	if n_methid != null then
		n_methid.parent = self
	end
        _n_signature = n_signature
	if n_signature != null then
		n_signature.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PMethid
                _n_methid = new_child
	    else
		_n_methid = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PSignature
                _n_signature = new_child
	    else
		_n_signature = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
    end
end
redef class ADeferredMethPropdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwmeth=(n: TKwmeth)
    do
        _n_kwmeth = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_methid=(n: PMethid)
    do
        _n_methid = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_signature=(n: PSignature)
    do
        _n_signature = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_adeferredmethpropdef (
            n_doc: PDoc ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_kwmeth: TKwmeth ,
            n_methid: PMethid ,
            n_signature: PSignature 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwmeth = n_kwmeth
	if n_kwmeth != null then
		n_kwmeth.parent = self
	end
        _n_methid = n_methid
	if n_methid != null then
		n_methid.parent = self
	end
        _n_signature = n_signature
	if n_signature != null then
		n_signature.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		_n_kwmeth = null
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PMethid
                _n_methid = new_child
	    else
		_n_methid = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PSignature
                _n_signature = new_child
	    else
		_n_signature = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwmeth != null then
            v.visit(_n_kwmeth)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwmeth != null then
            v.visit(_n_kwmeth)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
    end
end
redef class AInternMethPropdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwmeth=(n: TKwmeth)
    do
        _n_kwmeth = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_methid=(n: PMethid)
    do
        _n_methid = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_signature=(n: PSignature)
    do
        _n_signature = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_ainternmethpropdef (
            n_doc: PDoc ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_kwmeth: TKwmeth ,
            n_methid: PMethid ,
            n_signature: PSignature 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwmeth = n_kwmeth
	if n_kwmeth != null then
		n_kwmeth.parent = self
	end
        _n_methid = n_methid
	if n_methid != null then
		n_methid.parent = self
	end
        _n_signature = n_signature
	if n_signature != null then
		n_signature.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		_n_kwmeth = null
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PMethid
                _n_methid = new_child
	    else
		_n_methid = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PSignature
                _n_signature = new_child
	    else
		_n_signature = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwmeth != null then
            v.visit(_n_kwmeth)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwmeth != null then
            v.visit(_n_kwmeth)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
    end
end
redef class AExternMethPropdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwmeth=(n: TKwmeth)
    do
        _n_kwmeth = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_methid=(n: PMethid)
    do
        _n_methid = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_signature=(n: PSignature)
    do
        _n_signature = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_extern=(n: TString)
    do
        _n_extern = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aexternmethpropdef (
            n_doc: PDoc ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_kwmeth: TKwmeth ,
            n_methid: PMethid ,
            n_signature: PSignature ,
            n_extern: TString 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwmeth = n_kwmeth
	if n_kwmeth != null then
		n_kwmeth.parent = self
	end
        _n_methid = n_methid
	if n_methid != null then
		n_methid.parent = self
	end
        _n_signature = n_signature
	if n_signature != null then
		n_signature.parent = self
	end
        _n_extern = n_extern
	if n_extern != null then
		n_extern.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		_n_kwmeth = null
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PMethid
                _n_methid = new_child
	    else
		_n_methid = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PSignature
                _n_signature = new_child
	    else
		_n_signature = null
            end
            return
	end
        if _n_extern == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TString
                _n_extern = new_child
	    else
		_n_extern = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwmeth != null then
            v.visit(_n_kwmeth)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
        if _n_extern != null then
            v.visit(_n_extern)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwmeth != null then
            v.visit(_n_kwmeth)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
        if _n_extern != null then
            v.visit(_n_extern)
        end
    end
end
redef class AConcreteMethPropdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwmeth=(n: TKwmeth)
    do
        _n_kwmeth = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_methid=(n: PMethid)
    do
        _n_methid = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_signature=(n: PSignature)
    do
        _n_signature = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_block=(n: PExpr)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aconcretemethpropdef (
            n_doc: PDoc ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_kwmeth: TKwmeth ,
            n_methid: PMethid ,
            n_signature: PSignature ,
            n_block: PExpr 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwmeth = n_kwmeth
	if n_kwmeth != null then
		n_kwmeth.parent = self
	end
        _n_methid = n_methid
	if n_methid != null then
		n_methid.parent = self
	end
        _n_signature = n_signature
	if n_signature != null then
		n_signature.parent = self
	end
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		_n_kwmeth = null
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PMethid
                _n_methid = new_child
	    else
		_n_methid = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PSignature
                _n_signature = new_child
	    else
		_n_signature = null
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwmeth != null then
            v.visit(_n_kwmeth)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwmeth != null then
            v.visit(_n_kwmeth)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end
end
redef class AConcreteInitPropdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwinit=(n: TKwinit)
    do
        _n_kwinit = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_methid=(n: PMethid)
    do
        _n_methid = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_signature=(n: PSignature)
    do
        _n_signature = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_block=(n: PExpr)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aconcreteinitpropdef (
            n_doc: PDoc ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_kwinit: TKwinit ,
            n_methid: PMethid ,
            n_signature: PSignature ,
            n_block: PExpr 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwinit = n_kwinit
	if n_kwinit != null then
		n_kwinit.parent = self
	end
        _n_methid = n_methid
	if n_methid != null then
		n_methid.parent = self
	end
        _n_signature = n_signature
	if n_signature != null then
		n_signature.parent = self
	end
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwinit == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinit
                _n_kwinit = new_child
	    else
		_n_kwinit = null
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PMethid
                _n_methid = new_child
	    else
		_n_methid = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PSignature
                _n_signature = new_child
	    else
		_n_signature = null
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwinit != null then
            v.visit(_n_kwinit)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwinit != null then
            v.visit(_n_kwinit)
        end
        if _n_methid != null then
            v.visit(_n_methid)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end
end
redef class AMainMethPropdef
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_block=(n: PExpr)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_amainmethpropdef (
            n_kwredef: TKwredef ,
            n_block: PExpr 
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end
end
redef class ATypePropdef
    redef meth n_doc=(n: PDoc)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_visibility=(n: PVisibility)
    do
        _n_visibility = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwtype=(n: TKwtype)
    do
        _n_kwtype = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TClassid)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_atypepropdef (
            n_doc: PDoc ,
            n_kwredef: TKwredef ,
            n_visibility: PVisibility ,
            n_kwtype: TKwtype ,
            n_id: TClassid ,
            n_type: PType 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility
	if n_visibility != null then
		n_visibility.parent = self
	end
        _n_kwtype = n_kwtype
	if n_kwtype != null then
		n_kwtype.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PDoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PVisibility
                _n_visibility = new_child
	    else
		_n_visibility = null
            end
            return
	end
        if _n_kwtype == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwtype
                _n_kwtype = new_child
	    else
		_n_kwtype = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwtype != null then
            v.visit(_n_kwtype)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.visit(_n_doc)
        end
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_visibility != null then
            v.visit(_n_visibility)
        end
        if _n_kwtype != null then
            v.visit(_n_kwtype)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end
end
redef class AReadAble
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwreadable=(n: TKwreadable)
    do
        _n_kwreadable = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_areadable (
            n_kwredef: TKwredef ,
            n_kwreadable: TKwreadable 
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_kwreadable = n_kwreadable
	if n_kwreadable != null then
		n_kwreadable.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_kwreadable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwreadable
                _n_kwreadable = new_child
	    else
		_n_kwreadable = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_kwreadable != null then
            v.visit(_n_kwreadable)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_kwreadable != null then
            v.visit(_n_kwreadable)
        end
    end
end
redef class AWriteAble
    redef meth n_kwredef=(n: TKwredef)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwwritable=(n: TKwwritable)
    do
        _n_kwwritable = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_awriteable (
            n_kwredef: TKwredef ,
            n_kwwritable: TKwwritable 
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_kwwritable = n_kwwritable
	if n_kwwritable != null then
		n_kwwritable.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_kwwritable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwritable
                _n_kwwritable = new_child
	    else
		_n_kwwritable = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_kwwritable != null then
            v.visit(_n_kwwritable)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwredef != null then
            v.visit(_n_kwredef)
        end
        if _n_kwwritable != null then
            v.visit(_n_kwwritable)
        end
    end
end
redef class AIdMethid
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aidmethid (
            n_id: TId 
    )
    do
        empty_init
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
    end
end
redef class APlusMethid
    redef meth n_plus=(n: TPlus)
    do
        _n_plus = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aplusmethid (
            n_plus: TPlus 
    )
    do
        empty_init
        _n_plus = n_plus
	if n_plus != null then
		n_plus.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_plus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPlus
                _n_plus = new_child
	    else
		_n_plus = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_plus != null then
            v.visit(_n_plus)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_plus != null then
            v.visit(_n_plus)
        end
    end
end
redef class AMinusMethid
    redef meth n_minus=(n: TMinus)
    do
        _n_minus = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aminusmethid (
            n_minus: TMinus 
    )
    do
        empty_init
        _n_minus = n_minus
	if n_minus != null then
		n_minus.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_minus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinus
                _n_minus = new_child
	    else
		_n_minus = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_minus != null then
            v.visit(_n_minus)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_minus != null then
            v.visit(_n_minus)
        end
    end
end
redef class AStarMethid
    redef meth n_star=(n: TStar)
    do
        _n_star = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_astarmethid (
            n_star: TStar 
    )
    do
        empty_init
        _n_star = n_star
	if n_star != null then
		n_star.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_star == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStar
                _n_star = new_child
	    else
		_n_star = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_star != null then
            v.visit(_n_star)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_star != null then
            v.visit(_n_star)
        end
    end
end
redef class ASlashMethid
    redef meth n_slash=(n: TSlash)
    do
        _n_slash = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aslashmethid (
            n_slash: TSlash 
    )
    do
        empty_init
        _n_slash = n_slash
	if n_slash != null then
		n_slash.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_slash == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TSlash
                _n_slash = new_child
	    else
		_n_slash = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_slash != null then
            v.visit(_n_slash)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_slash != null then
            v.visit(_n_slash)
        end
    end
end
redef class APercentMethid
    redef meth n_percent=(n: TPercent)
    do
        _n_percent = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_apercentmethid (
            n_percent: TPercent 
    )
    do
        empty_init
        _n_percent = n_percent
	if n_percent != null then
		n_percent.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_percent == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPercent
                _n_percent = new_child
	    else
		_n_percent = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_percent != null then
            v.visit(_n_percent)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_percent != null then
            v.visit(_n_percent)
        end
    end
end
redef class AEqMethid
    redef meth n_eq=(n: TEq)
    do
        _n_eq = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aeqmethid (
            n_eq: TEq 
    )
    do
        empty_init
        _n_eq = n_eq
	if n_eq != null then
		n_eq.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_eq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TEq
                _n_eq = new_child
	    else
		_n_eq = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_eq != null then
            v.visit(_n_eq)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_eq != null then
            v.visit(_n_eq)
        end
    end
end
redef class ANeMethid
    redef meth n_ne=(n: TNe)
    do
        _n_ne = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_anemethid (
            n_ne: TNe 
    )
    do
        empty_init
        _n_ne = n_ne
	if n_ne != null then
		n_ne.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_ne == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TNe
                _n_ne = new_child
	    else
		_n_ne = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_ne != null then
            v.visit(_n_ne)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_ne != null then
            v.visit(_n_ne)
        end
    end
end
redef class ALeMethid
    redef meth n_le=(n: TLe)
    do
        _n_le = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_alemethid (
            n_le: TLe 
    )
    do
        empty_init
        _n_le = n_le
	if n_le != null then
		n_le.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_le == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TLe
                _n_le = new_child
	    else
		_n_le = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_le != null then
            v.visit(_n_le)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_le != null then
            v.visit(_n_le)
        end
    end
end
redef class AGeMethid
    redef meth n_ge=(n: TGe)
    do
        _n_ge = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_agemethid (
            n_ge: TGe 
    )
    do
        empty_init
        _n_ge = n_ge
	if n_ge != null then
		n_ge.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_ge == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TGe
                _n_ge = new_child
	    else
		_n_ge = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_ge != null then
            v.visit(_n_ge)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_ge != null then
            v.visit(_n_ge)
        end
    end
end
redef class ALtMethid
    redef meth n_lt=(n: TLt)
    do
        _n_lt = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_altmethid (
            n_lt: TLt 
    )
    do
        empty_init
        _n_lt = n_lt
	if n_lt != null then
		n_lt.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_lt == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TLt
                _n_lt = new_child
	    else
		_n_lt = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_lt != null then
            v.visit(_n_lt)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_lt != null then
            v.visit(_n_lt)
        end
    end
end
redef class AGtMethid
    redef meth n_gt=(n: TGt)
    do
        _n_gt = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_agtmethid (
            n_gt: TGt 
    )
    do
        empty_init
        _n_gt = n_gt
	if n_gt != null then
		n_gt.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_gt == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TGt
                _n_gt = new_child
	    else
		_n_gt = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_gt != null then
            v.visit(_n_gt)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_gt != null then
            v.visit(_n_gt)
        end
    end
end
redef class ABraMethid
    redef meth n_obra=(n: TObra)
    do
        _n_obra = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_cbra=(n: TCbra)
    do
        _n_cbra = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_abramethid (
            n_obra: TObra ,
            n_cbra: TCbra 
    )
    do
        empty_init
        _n_obra = n_obra
	if n_obra != null then
		n_obra.parent = self
	end
        _n_cbra = n_cbra
	if n_cbra != null then
		n_cbra.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_obra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TObra
                _n_obra = new_child
	    else
		_n_obra = null
            end
            return
	end
        if _n_cbra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TCbra
                _n_cbra = new_child
	    else
		_n_cbra = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_obra != null then
            v.visit(_n_obra)
        end
        if _n_cbra != null then
            v.visit(_n_cbra)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_obra != null then
            v.visit(_n_obra)
        end
        if _n_cbra != null then
            v.visit(_n_cbra)
        end
    end
end
redef class AStarshipMethid
    redef meth n_starship=(n: TStarship)
    do
        _n_starship = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_astarshipmethid (
            n_starship: TStarship 
    )
    do
        empty_init
        _n_starship = n_starship
	if n_starship != null then
		n_starship.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_starship == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStarship
                _n_starship = new_child
	    else
		_n_starship = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_starship != null then
            v.visit(_n_starship)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_starship != null then
            v.visit(_n_starship)
        end
    end
end
redef class AAssignMethid
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign=(n: TAssign)
    do
        _n_assign = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aassignmethid (
            n_id: TId ,
            n_assign: TAssign 
    )
    do
        empty_init
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
    end
end
redef class ABraassignMethid
    redef meth n_obra=(n: TObra)
    do
        _n_obra = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_cbra=(n: TCbra)
    do
        _n_cbra = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign=(n: TAssign)
    do
        _n_assign = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_abraassignmethid (
            n_obra: TObra ,
            n_cbra: TCbra ,
            n_assign: TAssign 
    )
    do
        empty_init
        _n_obra = n_obra
	if n_obra != null then
		n_obra.parent = self
	end
        _n_cbra = n_cbra
	if n_cbra != null then
		n_cbra.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_obra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TObra
                _n_obra = new_child
	    else
		_n_obra = null
            end
            return
	end
        if _n_cbra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TCbra
                _n_cbra = new_child
	    else
		_n_cbra = null
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_obra != null then
            v.visit(_n_obra)
        end
        if _n_cbra != null then
            v.visit(_n_cbra)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_obra != null then
            v.visit(_n_obra)
        end
        if _n_cbra != null then
            v.visit(_n_cbra)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
    end
end
redef class ASignature
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_asignature (
            n_params: Collection[Object] , # Should be Collection[PParam]
            n_type: PType ,
            n_closure_decls: Collection[Object]  # Should be Collection[PClosureDecl]
    )
    do
        empty_init
        _n_params = new List[PParam]
	for n in n_params do
		assert n isa PParam
		_n_params.add(n)
		n.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_closure_decls = new List[PClosureDecl]
	for n in n_closure_decls do
		assert n isa PClosureDecl
		_n_closure_decls.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        for i in [0.._n_params.length[ do
            if _n_params[i] == old_child then
                if new_child != null then
		    assert new_child isa PParam
                    _n_params[i] = new_child
                    new_child.parent = self
                else
                    _n_params.remove_at(i)
                end
                return
            end
        end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        for i in [0.._n_closure_decls.length[ do
            if _n_closure_decls[i] == old_child then
                if new_child != null then
		    assert new_child isa PClosureDecl
                    _n_closure_decls[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_decls.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
            for n in _n_params do
                v.visit(n)
	    end
        if _n_type != null then
            v.visit(_n_type)
        end
            for n in _n_closure_decls do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_params.length
            while i >= 0 do
                v.visit(_n_params[i])
		i = i - 1
	    end
	end
        if _n_type != null then
            v.visit(_n_type)
        end
	do
	    var i = _n_closure_decls.length
            while i >= 0 do
                v.visit(_n_closure_decls[i])
		i = i - 1
	    end
	end
    end
end
redef class AParam
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_dotdotdot=(n: TDotdotdot)
    do
        _n_dotdotdot = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aparam (
            n_id: TId ,
            n_type: PType ,
            n_dotdotdot: TDotdotdot 
    )
    do
        empty_init
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_dotdotdot = n_dotdotdot
	if n_dotdotdot != null then
		n_dotdotdot.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_dotdotdot == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TDotdotdot
                _n_dotdotdot = new_child
	    else
		_n_dotdotdot = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
        if _n_dotdotdot != null then
            v.visit(_n_dotdotdot)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
        if _n_dotdotdot != null then
            v.visit(_n_dotdotdot)
        end
    end
end
redef class AClosureDecl
    redef meth n_kwwith=(n: TKwwith)
    do
        _n_kwwith = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwbreak=(n: TKwbreak)
    do
        _n_kwbreak = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_signature=(n: PSignature)
    do
        _n_signature = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aclosuredecl (
            n_kwwith: TKwwith ,
            n_kwbreak: TKwbreak ,
            n_id: TId ,
            n_signature: PSignature ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwwith = n_kwwith
	if n_kwwith != null then
		n_kwwith.parent = self
	end
        _n_kwbreak = n_kwbreak
	if n_kwbreak != null then
		n_kwbreak.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_signature = n_signature
	if n_signature != null then
		n_signature.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwwith == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwith
                _n_kwwith = new_child
	    else
		_n_kwwith = null
            end
            return
	end
        if _n_kwbreak == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwbreak
                _n_kwbreak = new_child
	    else
		_n_kwbreak = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PSignature
                _n_signature = new_child
	    else
		_n_signature = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwwith != null then
            v.visit(_n_kwwith)
        end
        if _n_kwbreak != null then
            v.visit(_n_kwbreak)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwwith != null then
            v.visit(_n_kwwith)
        end
        if _n_kwbreak != null then
            v.visit(_n_kwbreak)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_signature != null then
            v.visit(_n_signature)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class AType
    redef meth n_id=(n: TClassid)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_atype (
            n_id: TClassid ,
            n_types: Collection[Object]  # Should be Collection[PType]
    )
    do
        empty_init
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_types = new List[PType]
	for n in n_types do
		assert n isa PType
		_n_types.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_types.length[ do
            if _n_types[i] == old_child then
                if new_child != null then
		    assert new_child isa PType
                    _n_types[i] = new_child
                    new_child.parent = self
                else
                    _n_types.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
            for n in _n_types do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
	do
	    var i = _n_types.length
            while i >= 0 do
                v.visit(_n_types[i])
		i = i - 1
	    end
	end
    end
end
redef class ABlockExpr

    private init empty_init do end

    init init_ablockexpr (
            n_expr: Collection[Object]  # Should be Collection[PExpr]
    )
    do
        empty_init
        _n_expr = new List[PExpr]
	for n in n_expr do
		assert n isa PExpr
		_n_expr.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        for i in [0.._n_expr.length[ do
            if _n_expr[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_expr[i] = new_child
                    new_child.parent = self
                else
                    _n_expr.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
            for n in _n_expr do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_expr.length
            while i >= 0 do
                v.visit(_n_expr[i])
		i = i - 1
	    end
	end
    end
end
redef class AVardeclExpr
    redef meth n_kwvar=(n: TKwvar)
    do
        _n_kwvar = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign=(n: TAssign)
    do
        _n_assign = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_avardeclexpr (
            n_kwvar: TKwvar ,
            n_id: TId ,
            n_type: PType ,
            n_assign: TAssign ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwvar = n_kwvar
	if n_kwvar != null then
		n_kwvar.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwvar == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwvar
                _n_kwvar = new_child
	    else
		_n_kwvar = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwvar != null then
            v.visit(_n_kwvar)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwvar != null then
            v.visit(_n_kwvar)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class AReturnExpr
    redef meth n_kwreturn=(n: TKwreturn)
    do
        _n_kwreturn = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_areturnexpr (
            n_kwreturn: TKwreturn ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwreturn = n_kwreturn
	if n_kwreturn != null then
		n_kwreturn.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwreturn == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwreturn
                _n_kwreturn = new_child
	    else
		_n_kwreturn = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwreturn != null then
            v.visit(_n_kwreturn)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwreturn != null then
            v.visit(_n_kwreturn)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class ABreakExpr
    redef meth n_kwbreak=(n: TKwbreak)
    do
        _n_kwbreak = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_abreakexpr (
            n_kwbreak: TKwbreak ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwbreak = n_kwbreak
	if n_kwbreak != null then
		n_kwbreak.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwbreak == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwbreak
                _n_kwbreak = new_child
	    else
		_n_kwbreak = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwbreak != null then
            v.visit(_n_kwbreak)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwbreak != null then
            v.visit(_n_kwbreak)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class AAbortExpr
    redef meth n_kwabort=(n: TKwabort)
    do
        _n_kwabort = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aabortexpr (
            n_kwabort: TKwabort 
    )
    do
        empty_init
        _n_kwabort = n_kwabort
	if n_kwabort != null then
		n_kwabort.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwabort == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwabort
                _n_kwabort = new_child
	    else
		_n_kwabort = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwabort != null then
            v.visit(_n_kwabort)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwabort != null then
            v.visit(_n_kwabort)
        end
    end
end
redef class AContinueExpr
    redef meth n_kwcontinue=(n: TKwcontinue)
    do
        _n_kwcontinue = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_acontinueexpr (
            n_kwcontinue: TKwcontinue ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwcontinue = n_kwcontinue
	if n_kwcontinue != null then
		n_kwcontinue.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwcontinue == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwcontinue
                _n_kwcontinue = new_child
	    else
		_n_kwcontinue = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwcontinue != null then
            v.visit(_n_kwcontinue)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwcontinue != null then
            v.visit(_n_kwcontinue)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class ADoExpr
    redef meth n_kwdo=(n: TKwdo)
    do
        _n_kwdo = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_block=(n: PExpr)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_adoexpr (
            n_kwdo: TKwdo ,
            n_block: PExpr 
    )
    do
        empty_init
        _n_kwdo = n_kwdo
	if n_kwdo != null then
		n_kwdo.parent = self
	end
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		_n_kwdo = null
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwdo != null then
            v.visit(_n_kwdo)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwdo != null then
            v.visit(_n_kwdo)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end
end
redef class AIfExpr
    redef meth n_kwif=(n: TKwif)
    do
        _n_kwif = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_then=(n: PExpr)
    do
        _n_then = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_else=(n: PExpr)
    do
        _n_else = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aifexpr (
            n_kwif: TKwif ,
            n_expr: PExpr ,
            n_then: PExpr ,
            n_else: PExpr 
    )
    do
        empty_init
        _n_kwif = n_kwif
	if n_kwif != null then
		n_kwif.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_then = n_then
	if n_then != null then
		n_then.parent = self
	end
        _n_else = n_else
	if n_else != null then
		n_else.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwif == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwif
                _n_kwif = new_child
	    else
		_n_kwif = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_then == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_then = new_child
	    else
		_n_then = null
            end
            return
	end
        if _n_else == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_else = new_child
	    else
		_n_else = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwif != null then
            v.visit(_n_kwif)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_then != null then
            v.visit(_n_then)
        end
        if _n_else != null then
            v.visit(_n_else)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwif != null then
            v.visit(_n_kwif)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_then != null then
            v.visit(_n_then)
        end
        if _n_else != null then
            v.visit(_n_else)
        end
    end
end
redef class AIfexprExpr
    redef meth n_kwif=(n: TKwif)
    do
        _n_kwif = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwthen=(n: TKwthen)
    do
        _n_kwthen = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_then=(n: PExpr)
    do
        _n_then = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwelse=(n: TKwelse)
    do
        _n_kwelse = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_else=(n: PExpr)
    do
        _n_else = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aifexprexpr (
            n_kwif: TKwif ,
            n_expr: PExpr ,
            n_kwthen: TKwthen ,
            n_then: PExpr ,
            n_kwelse: TKwelse ,
            n_else: PExpr 
    )
    do
        empty_init
        _n_kwif = n_kwif
	if n_kwif != null then
		n_kwif.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_kwthen = n_kwthen
	if n_kwthen != null then
		n_kwthen.parent = self
	end
        _n_then = n_then
	if n_then != null then
		n_then.parent = self
	end
        _n_kwelse = n_kwelse
	if n_kwelse != null then
		n_kwelse.parent = self
	end
        _n_else = n_else
	if n_else != null then
		n_else.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwif == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwif
                _n_kwif = new_child
	    else
		_n_kwif = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_kwthen == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwthen
                _n_kwthen = new_child
	    else
		_n_kwthen = null
            end
            return
	end
        if _n_then == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_then = new_child
	    else
		_n_then = null
            end
            return
	end
        if _n_kwelse == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwelse
                _n_kwelse = new_child
	    else
		_n_kwelse = null
            end
            return
	end
        if _n_else == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_else = new_child
	    else
		_n_else = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwif != null then
            v.visit(_n_kwif)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwthen != null then
            v.visit(_n_kwthen)
        end
        if _n_then != null then
            v.visit(_n_then)
        end
        if _n_kwelse != null then
            v.visit(_n_kwelse)
        end
        if _n_else != null then
            v.visit(_n_else)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwif != null then
            v.visit(_n_kwif)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwthen != null then
            v.visit(_n_kwthen)
        end
        if _n_then != null then
            v.visit(_n_then)
        end
        if _n_kwelse != null then
            v.visit(_n_kwelse)
        end
        if _n_else != null then
            v.visit(_n_else)
        end
    end
end
redef class AWhileExpr
    redef meth n_kwwhile=(n: TKwwhile)
    do
        _n_kwwhile = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwdo=(n: TKwdo)
    do
        _n_kwdo = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_block=(n: PExpr)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_awhileexpr (
            n_kwwhile: TKwwhile ,
            n_expr: PExpr ,
            n_kwdo: TKwdo ,
            n_block: PExpr 
    )
    do
        empty_init
        _n_kwwhile = n_kwwhile
	if n_kwwhile != null then
		n_kwwhile.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_kwdo = n_kwdo
	if n_kwdo != null then
		n_kwdo.parent = self
	end
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwwhile == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwhile
                _n_kwwhile = new_child
	    else
		_n_kwwhile = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		_n_kwdo = null
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwwhile != null then
            v.visit(_n_kwwhile)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwdo != null then
            v.visit(_n_kwdo)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwwhile != null then
            v.visit(_n_kwwhile)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwdo != null then
            v.visit(_n_kwdo)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end
end
redef class AForExpr
    redef meth n_kwfor=(n: TKwfor)
    do
        _n_kwfor = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwdo=(n: TKwdo)
    do
        _n_kwdo = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_block=(n: PExpr)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aforexpr (
            n_kwfor: TKwfor ,
            n_id: TId ,
            n_expr: PExpr ,
            n_kwdo: TKwdo ,
            n_block: PExpr 
    )
    do
        empty_init
        _n_kwfor = n_kwfor
	if n_kwfor != null then
		n_kwfor.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_kwdo = n_kwdo
	if n_kwdo != null then
		n_kwdo.parent = self
	end
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwfor == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwfor
                _n_kwfor = new_child
	    else
		_n_kwfor = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		_n_kwdo = null
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwfor != null then
            v.visit(_n_kwfor)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwdo != null then
            v.visit(_n_kwdo)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwfor != null then
            v.visit(_n_kwfor)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwdo != null then
            v.visit(_n_kwdo)
        end
        if _n_block != null then
            v.visit(_n_block)
        end
    end
end
redef class AAssertExpr
    redef meth n_kwassert=(n: TKwassert)
    do
        _n_kwassert = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aassertexpr (
            n_kwassert: TKwassert ,
            n_id: TId ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwassert = n_kwassert
	if n_kwassert != null then
		n_kwassert.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwassert == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwassert
                _n_kwassert = new_child
	    else
		_n_kwassert = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwassert != null then
            v.visit(_n_kwassert)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwassert != null then
            v.visit(_n_kwassert)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class AOnceExpr
    redef meth n_kwonce=(n: TKwonce)
    do
        _n_kwonce = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aonceexpr (
            n_kwonce: TKwonce ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwonce = n_kwonce
	if n_kwonce != null then
		n_kwonce.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwonce == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwonce
                _n_kwonce = new_child
	    else
		_n_kwonce = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwonce != null then
            v.visit(_n_kwonce)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwonce != null then
            v.visit(_n_kwonce)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class ASendExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_asendexpr (
            n_expr: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class ABinopExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_abinopexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AOrExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aorexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AAndExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aandexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class ANotExpr
    redef meth n_kwnot=(n: TKwnot)
    do
        _n_kwnot = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_anotexpr (
            n_kwnot: TKwnot ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwnot = n_kwnot
	if n_kwnot != null then
		n_kwnot.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwnot == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnot
                _n_kwnot = new_child
	    else
		_n_kwnot = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwnot != null then
            v.visit(_n_kwnot)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwnot != null then
            v.visit(_n_kwnot)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class AEqExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aeqexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AEeExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aeeexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class ANeExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aneexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class ALtExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_altexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class ALeExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aleexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AGtExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_agtexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AGeExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_ageexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AIsaExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aisaexpr (
            n_expr: PExpr ,
            n_type: PType 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end
end
redef class APlusExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aplusexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AMinusExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aminusexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AStarshipExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_astarshipexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AStarExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_astarexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class ASlashExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aslashexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class APercentExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_apercentexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AUminusExpr
    redef meth n_minus=(n: TMinus)
    do
        _n_minus = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_auminusexpr (
            n_minus: TMinus ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_minus = n_minus
	if n_minus != null then
		n_minus.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_minus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinus
                _n_minus = new_child
	    else
		_n_minus = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_minus != null then
            v.visit(_n_minus)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_minus != null then
            v.visit(_n_minus)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class ANewExpr
    redef meth n_kwnew=(n: TKwnew)
    do
        _n_kwnew = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_anewexpr (
            n_kwnew: TKwnew ,
            n_type: PType ,
            n_id: TId ,
            n_args: Collection[Object]  # Should be Collection[PExpr]
    )
    do
        empty_init
        _n_kwnew = n_kwnew
	if n_kwnew != null then
		n_kwnew.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwnew == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnew
                _n_kwnew = new_child
	    else
		_n_kwnew = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwnew != null then
            v.visit(_n_kwnew)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
            for n in _n_args do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwnew != null then
            v.visit(_n_kwnew)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
    end
end
redef class AAttrExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TAttrid)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aattrexpr (
            n_expr: PExpr ,
            n_id: TAttrid 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
    end
end
redef class AAttrAssignExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TAttrid)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign=(n: TAssign)
    do
        _n_assign = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_value=(n: PExpr)
    do
        _n_value = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aattrassignexpr (
            n_expr: PExpr ,
            n_id: TAttrid ,
            n_assign: TAssign ,
            n_value: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
        _n_value = n_value
	if n_value != null then
		n_value.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_value = new_child
	    else
		_n_value = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end
end
redef class AAttrReassignExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TAttrid)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign_op=(n: PAssignOp)
    do
        _n_assign_op = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_value=(n: PExpr)
    do
        _n_value = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aattrreassignexpr (
            n_expr: PExpr ,
            n_id: TAttrid ,
            n_assign_op: PAssignOp ,
            n_value: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_assign_op = n_assign_op
	if n_assign_op != null then
		n_assign_op.parent = self
	end
        _n_value = n_value
	if n_value != null then
		n_value.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PAssignOp
                _n_assign_op = new_child
	    else
		_n_assign_op = null
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_value = new_child
	    else
		_n_value = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign_op != null then
            v.visit(_n_assign_op)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign_op != null then
            v.visit(_n_assign_op)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end
end
redef class ACallExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_acallexpr (
            n_expr: PExpr ,
            n_id: TId ,
            n_args: Collection[Object] , # Should be Collection[PExpr]
            n_closure_defs: Collection[Object]  # Should be Collection[PClosureDef]
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_closure_defs = new List[PClosureDef]
	for n in n_closure_defs do
		assert n isa PClosureDef
		_n_closure_defs.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_closure_defs.length[ do
            if _n_closure_defs[i] == old_child then
                if new_child != null then
		    assert new_child isa PClosureDef
                    _n_closure_defs[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_defs.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
            for n in _n_args do
                v.visit(n)
	    end
            for n in _n_closure_defs do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_closure_defs.length
            while i >= 0 do
                v.visit(_n_closure_defs[i])
		i = i - 1
	    end
	end
    end
end
redef class ACallAssignExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign=(n: TAssign)
    do
        _n_assign = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_value=(n: PExpr)
    do
        _n_value = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_acallassignexpr (
            n_expr: PExpr ,
            n_id: TId ,
            n_args: Collection[Object] , # Should be Collection[PExpr]
            n_assign: TAssign ,
            n_value: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
        _n_value = n_value
	if n_value != null then
		n_value.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_value = new_child
	    else
		_n_value = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
            for n in _n_args do
                v.visit(n)
	    end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end
end
redef class ACallReassignExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign_op=(n: PAssignOp)
    do
        _n_assign_op = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_value=(n: PExpr)
    do
        _n_value = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_acallreassignexpr (
            n_expr: PExpr ,
            n_id: TId ,
            n_args: Collection[Object] , # Should be Collection[PExpr]
            n_assign_op: PAssignOp ,
            n_value: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign_op = n_assign_op
	if n_assign_op != null then
		n_assign_op.parent = self
	end
        _n_value = n_value
	if n_value != null then
		n_value.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PAssignOp
                _n_assign_op = new_child
	    else
		_n_assign_op = null
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_value = new_child
	    else
		_n_value = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
            for n in _n_args do
                v.visit(n)
	    end
        if _n_assign_op != null then
            v.visit(_n_assign_op)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_id != null then
            v.visit(_n_id)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
        if _n_assign_op != null then
            v.visit(_n_assign_op)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end
end
redef class ASuperExpr
    redef meth n_qualified=(n: PQualified)
    do
        _n_qualified = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwsuper=(n: TKwsuper)
    do
        _n_kwsuper = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_asuperexpr (
            n_qualified: PQualified ,
            n_kwsuper: TKwsuper ,
            n_args: Collection[Object]  # Should be Collection[PExpr]
    )
    do
        empty_init
        _n_qualified = n_qualified
	if n_qualified != null then
		n_qualified.parent = self
	end
        _n_kwsuper = n_kwsuper
	if n_kwsuper != null then
		n_kwsuper.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_qualified == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PQualified
                _n_qualified = new_child
	    else
		_n_qualified = null
            end
            return
	end
        if _n_kwsuper == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwsuper
                _n_kwsuper = new_child
	    else
		_n_kwsuper = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_qualified != null then
            v.visit(_n_qualified)
        end
        if _n_kwsuper != null then
            v.visit(_n_kwsuper)
        end
            for n in _n_args do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_qualified != null then
            v.visit(_n_qualified)
        end
        if _n_kwsuper != null then
            v.visit(_n_kwsuper)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
    end
end
redef class AInitExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwinit=(n: TKwinit)
    do
        _n_kwinit = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_ainitexpr (
            n_expr: PExpr ,
            n_kwinit: TKwinit ,
            n_args: Collection[Object]  # Should be Collection[PExpr]
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_kwinit = n_kwinit
	if n_kwinit != null then
		n_kwinit.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_kwinit == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinit
                _n_kwinit = new_child
	    else
		_n_kwinit = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwinit != null then
            v.visit(_n_kwinit)
        end
            for n in _n_args do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwinit != null then
            v.visit(_n_kwinit)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
    end
end
redef class ABraExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_abraexpr (
            n_expr: PExpr ,
            n_args: Collection[Object] , # Should be Collection[PExpr]
            n_closure_defs: Collection[Object]  # Should be Collection[PClosureDef]
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_closure_defs = new List[PClosureDef]
	for n in n_closure_defs do
		assert n isa PClosureDef
		_n_closure_defs.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_closure_defs.length[ do
            if _n_closure_defs[i] == old_child then
                if new_child != null then
		    assert new_child isa PClosureDef
                    _n_closure_defs[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_defs.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
            for n in _n_args do
                v.visit(n)
	    end
            for n in _n_closure_defs do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_closure_defs.length
            while i >= 0 do
                v.visit(_n_closure_defs[i])
		i = i - 1
	    end
	end
    end
end
redef class ABraAssignExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign=(n: TAssign)
    do
        _n_assign = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_value=(n: PExpr)
    do
        _n_value = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_abraassignexpr (
            n_expr: PExpr ,
            n_args: Collection[Object] , # Should be Collection[PExpr]
            n_assign: TAssign ,
            n_value: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
        _n_value = n_value
	if n_value != null then
		n_value.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_value = new_child
	    else
		_n_value = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
            for n in _n_args do
                v.visit(n)
	    end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end
end
redef class ABraReassignExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign_op=(n: PAssignOp)
    do
        _n_assign_op = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_value=(n: PExpr)
    do
        _n_value = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_abrareassignexpr (
            n_expr: PExpr ,
            n_args: Collection[Object] , # Should be Collection[PExpr]
            n_assign_op: PAssignOp ,
            n_value: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_args = new List[PExpr]
	for n in n_args do
		assert n isa PExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign_op = n_assign_op
	if n_assign_op != null then
		n_assign_op.parent = self
	end
        _n_value = n_value
	if n_value != null then
		n_value.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PAssignOp
                _n_assign_op = new_child
	    else
		_n_assign_op = null
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_value = new_child
	    else
		_n_value = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
            for n in _n_args do
                v.visit(n)
	    end
        if _n_assign_op != null then
            v.visit(_n_assign_op)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.visit(_n_args[i])
		i = i - 1
	    end
	end
        if _n_assign_op != null then
            v.visit(_n_assign_op)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end
end
redef class AVarExpr
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_avarexpr (
            n_id: TId 
    )
    do
        empty_init
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
    end
end
redef class AVarAssignExpr
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign=(n: TAssign)
    do
        _n_assign = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_value=(n: PExpr)
    do
        _n_value = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_avarassignexpr (
            n_id: TId ,
            n_assign: TAssign ,
            n_value: PExpr 
    )
    do
        empty_init
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
        _n_value = n_value
	if n_value != null then
		n_value.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_value = new_child
	    else
		_n_value = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign != null then
            v.visit(_n_assign)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end
end
redef class AVarReassignExpr
    redef meth n_id=(n: TId)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_assign_op=(n: PAssignOp)
    do
        _n_assign_op = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_value=(n: PExpr)
    do
        _n_value = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_avarreassignexpr (
            n_id: TId ,
            n_assign_op: PAssignOp ,
            n_value: PExpr 
    )
    do
        empty_init
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_assign_op = n_assign_op
	if n_assign_op != null then
		n_assign_op.parent = self
	end
        _n_value = n_value
	if n_value != null then
		n_value.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PAssignOp
                _n_assign_op = new_child
	    else
		_n_assign_op = null
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_value = new_child
	    else
		_n_value = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign_op != null then
            v.visit(_n_assign_op)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_id != null then
            v.visit(_n_id)
        end
        if _n_assign_op != null then
            v.visit(_n_assign_op)
        end
        if _n_value != null then
            v.visit(_n_value)
        end
    end
end
redef class ARangeExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_arangeexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class ACrangeExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_acrangeexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AOrangeExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr2=(n: PExpr)
    do
        _n_expr2 = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aorangeexpr (
            n_expr: PExpr ,
            n_expr2: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_expr2 = n_expr2
	if n_expr2 != null then
		n_expr2.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr2 = new_child
	    else
		_n_expr2 = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_expr2 != null then
            v.visit(_n_expr2)
        end
    end
end
redef class AArrayExpr

    private init empty_init do end

    init init_aarrayexpr (
            n_exprs: Collection[Object]  # Should be Collection[PExpr]
    )
    do
        empty_init
        _n_exprs = new List[PExpr]
	for n in n_exprs do
		assert n isa PExpr
		_n_exprs.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        for i in [0.._n_exprs.length[ do
            if _n_exprs[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_exprs[i] = new_child
                    new_child.parent = self
                else
                    _n_exprs.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
            for n in _n_exprs do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_exprs.length
            while i >= 0 do
                v.visit(_n_exprs[i])
		i = i - 1
	    end
	end
    end
end
redef class ASelfExpr
    redef meth n_kwself=(n: TKwself)
    do
        _n_kwself = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aselfexpr (
            n_kwself: TKwself 
    )
    do
        empty_init
        _n_kwself = n_kwself
	if n_kwself != null then
		n_kwself.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwself == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwself
                _n_kwself = new_child
	    else
		_n_kwself = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwself != null then
            v.visit(_n_kwself)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwself != null then
            v.visit(_n_kwself)
        end
    end
end
redef class AImplicitSelfExpr

    private init empty_init do end

    init init_aimplicitselfexpr
    do
        empty_init
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
    end

    redef meth visit_all(v: Visitor)
    do
    end

    redef meth visit_all_reverse(v: Visitor)
    do
    end
end
redef class ATrueExpr
    redef meth n_kwtrue=(n: TKwtrue)
    do
        _n_kwtrue = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_atrueexpr (
            n_kwtrue: TKwtrue 
    )
    do
        empty_init
        _n_kwtrue = n_kwtrue
	if n_kwtrue != null then
		n_kwtrue.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwtrue == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwtrue
                _n_kwtrue = new_child
	    else
		_n_kwtrue = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwtrue != null then
            v.visit(_n_kwtrue)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwtrue != null then
            v.visit(_n_kwtrue)
        end
    end
end
redef class AFalseExpr
    redef meth n_kwfalse=(n: TKwfalse)
    do
        _n_kwfalse = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_afalseexpr (
            n_kwfalse: TKwfalse 
    )
    do
        empty_init
        _n_kwfalse = n_kwfalse
	if n_kwfalse != null then
		n_kwfalse.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwfalse == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwfalse
                _n_kwfalse = new_child
	    else
		_n_kwfalse = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwfalse != null then
            v.visit(_n_kwfalse)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwfalse != null then
            v.visit(_n_kwfalse)
        end
    end
end
redef class ANullExpr
    redef meth n_kwnull=(n: TKwnull)
    do
        _n_kwnull = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_anullexpr (
            n_kwnull: TKwnull 
    )
    do
        empty_init
        _n_kwnull = n_kwnull
	if n_kwnull != null then
		n_kwnull.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwnull == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnull
                _n_kwnull = new_child
	    else
		_n_kwnull = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwnull != null then
            v.visit(_n_kwnull)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwnull != null then
            v.visit(_n_kwnull)
        end
    end
end
redef class AIntExpr
    redef meth n_number=(n: TNumber)
    do
        _n_number = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aintexpr (
            n_number: TNumber 
    )
    do
        empty_init
        _n_number = n_number
	if n_number != null then
		n_number.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_number == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TNumber
                _n_number = new_child
	    else
		_n_number = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_number != null then
            v.visit(_n_number)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_number != null then
            v.visit(_n_number)
        end
    end
end
redef class AFloatExpr
    redef meth n_float=(n: TFloat)
    do
        _n_float = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_afloatexpr (
            n_float: TFloat 
    )
    do
        empty_init
        _n_float = n_float
	if n_float != null then
		n_float.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_float == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TFloat
                _n_float = new_child
	    else
		_n_float = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_float != null then
            v.visit(_n_float)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_float != null then
            v.visit(_n_float)
        end
    end
end
redef class ACharExpr
    redef meth n_char=(n: TChar)
    do
        _n_char = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_acharexpr (
            n_char: TChar 
    )
    do
        empty_init
        _n_char = n_char
	if n_char != null then
		n_char.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_char == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TChar
                _n_char = new_child
	    else
		_n_char = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_char != null then
            v.visit(_n_char)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_char != null then
            v.visit(_n_char)
        end
    end
end
redef class AStringExpr
    redef meth n_string=(n: TString)
    do
        _n_string = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_astringexpr (
            n_string: TString 
    )
    do
        empty_init
        _n_string = n_string
	if n_string != null then
		n_string.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TString
                _n_string = new_child
	    else
		_n_string = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_string != null then
            v.visit(_n_string)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_string != null then
            v.visit(_n_string)
        end
    end
end
redef class AStartStringExpr
    redef meth n_string=(n: TStartString)
    do
        _n_string = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_astartstringexpr (
            n_string: TStartString 
    )
    do
        empty_init
        _n_string = n_string
	if n_string != null then
		n_string.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStartString
                _n_string = new_child
	    else
		_n_string = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_string != null then
            v.visit(_n_string)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_string != null then
            v.visit(_n_string)
        end
    end
end
redef class AMidStringExpr
    redef meth n_string=(n: TMidString)
    do
        _n_string = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_amidstringexpr (
            n_string: TMidString 
    )
    do
        empty_init
        _n_string = n_string
	if n_string != null then
		n_string.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMidString
                _n_string = new_child
	    else
		_n_string = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_string != null then
            v.visit(_n_string)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_string != null then
            v.visit(_n_string)
        end
    end
end
redef class AEndStringExpr
    redef meth n_string=(n: TEndString)
    do
        _n_string = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aendstringexpr (
            n_string: TEndString 
    )
    do
        empty_init
        _n_string = n_string
	if n_string != null then
		n_string.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TEndString
                _n_string = new_child
	    else
		_n_string = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_string != null then
            v.visit(_n_string)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_string != null then
            v.visit(_n_string)
        end
    end
end
redef class ASuperstringExpr

    private init empty_init do end

    init init_asuperstringexpr (
            n_exprs: Collection[Object]  # Should be Collection[PExpr]
    )
    do
        empty_init
        _n_exprs = new List[PExpr]
	for n in n_exprs do
		assert n isa PExpr
		_n_exprs.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        for i in [0.._n_exprs.length[ do
            if _n_exprs[i] == old_child then
                if new_child != null then
		    assert new_child isa PExpr
                    _n_exprs[i] = new_child
                    new_child.parent = self
                else
                    _n_exprs.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
            for n in _n_exprs do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_exprs.length
            while i >= 0 do
                v.visit(_n_exprs[i])
		i = i - 1
	    end
	end
    end
end
redef class AParExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aparexpr (
            n_expr: PExpr 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class AAsCastExpr
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwas=(n: TKwas)
    do
        _n_kwas = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_type=(n: PType)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aascastexpr (
            n_expr: PExpr ,
            n_kwas: TKwas ,
            n_type: PType 
    )
    do
        empty_init
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
        _n_kwas = n_kwas
	if n_kwas != null then
		n_kwas.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
        if _n_kwas == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwas
                _n_kwas = new_child
	    else
		_n_kwas = null
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwas != null then
            v.visit(_n_kwas)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_expr != null then
            v.visit(_n_expr)
        end
        if _n_kwas != null then
            v.visit(_n_kwas)
        end
        if _n_type != null then
            v.visit(_n_type)
        end
    end
end
redef class APlusAssignOp
    redef meth n_pluseq=(n: TPluseq)
    do
        _n_pluseq = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aplusassignop (
            n_pluseq: TPluseq 
    )
    do
        empty_init
        _n_pluseq = n_pluseq
	if n_pluseq != null then
		n_pluseq.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_pluseq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPluseq
                _n_pluseq = new_child
	    else
		_n_pluseq = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_pluseq != null then
            v.visit(_n_pluseq)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_pluseq != null then
            v.visit(_n_pluseq)
        end
    end
end
redef class AMinusAssignOp
    redef meth n_minuseq=(n: TMinuseq)
    do
        _n_minuseq = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aminusassignop (
            n_minuseq: TMinuseq 
    )
    do
        empty_init
        _n_minuseq = n_minuseq
	if n_minuseq != null then
		n_minuseq.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_minuseq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinuseq
                _n_minuseq = new_child
	    else
		_n_minuseq = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_minuseq != null then
            v.visit(_n_minuseq)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_minuseq != null then
            v.visit(_n_minuseq)
        end
    end
end
redef class AClosureDef
    redef meth n_kwwith=(n: TKwwith)
    do
        _n_kwwith = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_kwdo=(n: TKwdo)
    do
        _n_kwdo = n
        if n != null then
	    n.parent = self
        end
    end
    redef meth n_expr=(n: PExpr)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aclosuredef (
            n_kwwith: TKwwith ,
            n_id: Collection[Object] , # Should be Collection[TId]
            n_kwdo: TKwdo ,
            n_expr: PExpr 
    )
    do
        empty_init
        _n_kwwith = n_kwwith
	if n_kwwith != null then
		n_kwwith.parent = self
	end
        _n_id = new List[TId]
	for n in n_id do
		assert n isa TId
		_n_id.add(n)
		n.parent = self
	end
        _n_kwdo = n_kwdo
	if n_kwdo != null then
		n_kwdo.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_kwwith == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwith
                _n_kwwith = new_child
	    else
		_n_kwwith = null
            end
            return
	end
        for i in [0.._n_id.length[ do
            if _n_id[i] == old_child then
                if new_child != null then
		    assert new_child isa TId
                    _n_id[i] = new_child
                    new_child.parent = self
                else
                    _n_id.remove_at(i)
                end
                return
            end
        end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		_n_kwdo = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa PExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_kwwith != null then
            v.visit(_n_kwwith)
        end
            for n in _n_id do
                v.visit(n)
	    end
        if _n_kwdo != null then
            v.visit(_n_kwdo)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_kwwith != null then
            v.visit(_n_kwwith)
        end
	do
	    var i = _n_id.length
            while i >= 0 do
                v.visit(_n_id[i])
		i = i - 1
	    end
	end
        if _n_kwdo != null then
            v.visit(_n_kwdo)
        end
        if _n_expr != null then
            v.visit(_n_expr)
        end
    end
end
redef class AQualified
    redef meth n_classid=(n: TClassid)
    do
        _n_classid = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aqualified (
            n_id: Collection[Object] , # Should be Collection[TId]
            n_classid: TClassid 
    )
    do
        empty_init
        _n_id = new List[TId]
	for n in n_id do
		assert n isa TId
		_n_id.add(n)
		n.parent = self
	end
        _n_classid = n_classid
	if n_classid != null then
		n_classid.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        for i in [0.._n_id.length[ do
            if _n_id[i] == old_child then
                if new_child != null then
		    assert new_child isa TId
                    _n_id[i] = new_child
                    new_child.parent = self
                else
                    _n_id.remove_at(i)
                end
                return
            end
        end
        if _n_classid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_classid = new_child
	    else
		_n_classid = null
            end
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
            for n in _n_id do
                v.visit(n)
	    end
        if _n_classid != null then
            v.visit(_n_classid)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_id.length
            while i >= 0 do
                v.visit(_n_id[i])
		i = i - 1
	    end
	end
        if _n_classid != null then
            v.visit(_n_classid)
        end
    end
end
redef class ADoc

    private init empty_init do end

    init init_adoc (
            n_comment: Collection[Object]  # Should be Collection[TComment]
    )
    do
        empty_init
        _n_comment = new List[TComment]
	for n in n_comment do
		assert n isa TComment
		_n_comment.add(n)
		n.parent = self
	end
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        for i in [0.._n_comment.length[ do
            if _n_comment[i] == old_child then
                if new_child != null then
		    assert new_child isa TComment
                    _n_comment[i] = new_child
                    new_child.parent = self
                else
                    _n_comment.remove_at(i)
                end
                return
            end
        end
    end

    redef meth visit_all(v: Visitor)
    do
            for n in _n_comment do
                v.visit(n)
	    end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_comment.length
            while i >= 0 do
                v.visit(_n_comment[i])
		i = i - 1
	    end
	end
    end
end

redef class Start
    init(
        n_base: PModule,
        n_eof: EOF)
    do
        _n_base = n_base
        _n_eof = n_eof
    end

    redef meth replace_child(old_child: PNode, new_child: PNode)
    do
        assert old_child != null
        if _n_base == old_child then
            if new_child == null then
            else
                new_child.parent = self
		assert new_child isa PModule
                _n_base = new_child
            end
            old_child.parent = null
            return
	end
    end

    redef meth visit_all(v: Visitor)
    do
        if _n_base != null then
            v.visit(_n_base)
        end
    end

    redef meth visit_all_reverse(v: Visitor)
    do
        if _n_base != null then
            v.visit(_n_base)
        end
    end
end
