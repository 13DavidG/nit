# Production AST nodes full definition.
# This file was generated by SableCC (http://www.sablecc.org/). 
package parser_prod

import lexer
intrude import parser_nodes

redef class ANode
	# Parent of the node in the AST
	readable writable var _parent: nullable ANode

	# Remove a child from the AST
	fun remove_child(child: ANode)
	do
		replace_child(child, null)
	end

	# Replace a child with an other node in the AST
	fun replace_child(old_child: ANode, new_child: nullable ANode) is abstract

	# Replace itself with an other node in the AST
	fun replace_with(node: ANode)
	do
		if (_parent != null) then
			_parent.replace_child(self, node)
		end
	end

	# Visit all nodes in order.
	# Thus, call "v.visit(e)" for each node e
	fun visit_all(v: Visitor) is abstract

	# Visit all nodes in reverse order.
	# Thus, call "v.visit(e)" for each node e starting from the last child
	fun visit_all_reverse(v: Visitor) is abstract

	# Debug method: output a message prefixed with the location.
	fun printl(str: String)
	do
		if location == null then
			print("???: {str}\n")
		else
			print("{location}: {str}\n")
		end
	end
end

redef class Token
	redef fun visit_all(v: Visitor) do end
	redef fun visit_all_reverse(v: Visitor) do end
	redef fun replace_child(old_child: ANode, new_child: nullable ANode) do end
end

redef class Prod
	# The first token of the production node
	readable writable var _first_token: nullable Token

	# The last token of the production node
	readable writable var _last_token: nullable Token

	redef fun replace_with(n: ANode)
        do
                super
                assert n isa Prod
                n.first_token = first_token
                n.last_token = last_token
                n.location = location
        end
end

# Abstract standard visitor
class Visitor
	# What the visitor do when a node is visited
        # Concrete visitors should redefine this method.
        protected fun visit(e: nullable ANode) is abstract

        # Ask the visitor to visit a given node.
        # Usually automatically called by visit_all* methods.
	# This methos should not be redefined
        fun enter_visit(e: nullable ANode)
	do
		var old = _current_node
		_current_node = e
		visit(e)
		_current_node = old
	end

	# The current visited node
	readable var _current_node: nullable ANode = null
end

redef class AModule
    redef fun n_packagedecl=(n)
    do
        _n_packagedecl = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_amodule (
            n_packagedecl: nullable APackagedecl ,
            n_imports: Collection[Object] , # Should be Collection[AImport]
            n_classdefs: Collection[Object]  # Should be Collection[AClassdef]
    )
    do
        empty_init
        _n_packagedecl = n_packagedecl
	if n_packagedecl != null then
		n_packagedecl.parent = self
	end
	for n in n_imports do
		assert n isa AImport
		_n_imports.add(n)
		n.parent = self
	end
	for n in n_classdefs do
		assert n isa AClassdef
		_n_classdefs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_packagedecl == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa APackagedecl
                _n_packagedecl = new_child
	    else
		_n_packagedecl = null
            end
            return
	end
        for i in [0.._n_imports.length[ do
            if _n_imports[i] == old_child then
                if new_child != null then
		    assert new_child isa AImport
                    _n_imports[i] = new_child
                    new_child.parent = self
                else
                    _n_imports.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_classdefs.length[ do
            if _n_classdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa AClassdef
                    _n_classdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_classdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_packagedecl != null then
            v.enter_visit(_n_packagedecl.as(not null))
        end
            for n in _n_imports do
                v.enter_visit(n)
	    end
            for n in _n_classdefs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_packagedecl != null then
            v.enter_visit(_n_packagedecl.as(not null))
        end
	do
	    var i = _n_imports.length
            while i >= 0 do
                v.enter_visit(_n_imports[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_classdefs.length
            while i >= 0 do
                v.enter_visit(_n_classdefs[i])
		i = i - 1
	    end
	end
    end
end
redef class APackagedecl
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwpackage=(n)
    do
        _n_kwpackage = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_apackagedecl (
            n_doc: nullable ADoc ,
            n_kwpackage: nullable TKwpackage ,
            n_id: nullable TId 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwpackage = n_kwpackage.as(not null)
	n_kwpackage.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwpackage == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwpackage
                _n_kwpackage = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        v.enter_visit(_n_kwpackage)
        v.enter_visit(_n_id)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        v.enter_visit(_n_kwpackage)
        v.enter_visit(_n_id)
    end
end
redef class AStdImport
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwimport=(n)
    do
        _n_kwimport = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_astdimport (
            n_visibility: nullable AVisibility ,
            n_kwimport: nullable TKwimport ,
            n_id: nullable TId 
    )
    do
        empty_init
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwimport = n_kwimport.as(not null)
	n_kwimport.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwimport == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwimport
                _n_kwimport = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwimport)
        v.enter_visit(_n_id)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwimport)
        v.enter_visit(_n_id)
    end
end
redef class ANoImport
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwimport=(n)
    do
        _n_kwimport = n
	n.parent = self
    end
    redef fun n_kwend=(n)
    do
        _n_kwend = n
	n.parent = self
    end

    private init empty_init do end

    init init_anoimport (
            n_visibility: nullable AVisibility ,
            n_kwimport: nullable TKwimport ,
            n_kwend: nullable TKwend 
    )
    do
        empty_init
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwimport = n_kwimport.as(not null)
	n_kwimport.parent = self
        _n_kwend = n_kwend.as(not null)
	n_kwend.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwimport == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwimport
                _n_kwimport = new_child
	    else
		abort
            end
            return
	end
        if _n_kwend == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwend
                _n_kwend = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwimport)
        v.enter_visit(_n_kwend)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwimport)
        v.enter_visit(_n_kwend)
    end
end
redef class APublicVisibility

    private init empty_init do end

    init init_apublicvisibility
    do
        empty_init
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
    end

    redef fun visit_all(v: Visitor)
    do
    end

    redef fun visit_all_reverse(v: Visitor)
    do
    end
end
redef class APrivateVisibility
    redef fun n_kwprivate=(n)
    do
        _n_kwprivate = n
	n.parent = self
    end

    private init empty_init do end

    init init_aprivatevisibility (
            n_kwprivate: nullable TKwprivate 
    )
    do
        empty_init
        _n_kwprivate = n_kwprivate.as(not null)
	n_kwprivate.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwprivate == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwprivate
                _n_kwprivate = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwprivate)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwprivate)
    end
end
redef class AProtectedVisibility
    redef fun n_kwprotected=(n)
    do
        _n_kwprotected = n
	n.parent = self
    end

    private init empty_init do end

    init init_aprotectedvisibility (
            n_kwprotected: nullable TKwprotected 
    )
    do
        empty_init
        _n_kwprotected = n_kwprotected.as(not null)
	n_kwprotected.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwprotected == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwprotected
                _n_kwprotected = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwprotected)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwprotected)
    end
end
redef class AIntrudeVisibility
    redef fun n_kwintrude=(n)
    do
        _n_kwintrude = n
	n.parent = self
    end

    private init empty_init do end

    init init_aintrudevisibility (
            n_kwintrude: nullable TKwintrude 
    )
    do
        empty_init
        _n_kwintrude = n_kwintrude.as(not null)
	n_kwintrude.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwintrude == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwintrude
                _n_kwintrude = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwintrude)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwintrude)
    end
end
redef class AStdClassdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_classkind=(n)
    do
        _n_classkind = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_astdclassdef (
            n_doc: nullable ADoc ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_classkind: nullable AClasskind ,
            n_id: nullable TClassid ,
            n_formaldefs: Collection[Object] , # Should be Collection[AFormaldef]
            n_superclasses: Collection[Object] , # Should be Collection[ASuperclass]
            n_propdefs: Collection[Object]  # Should be Collection[APropdef]
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_classkind = n_classkind.as(not null)
	n_classkind.parent = self
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
	for n in n_formaldefs do
		assert n isa AFormaldef
		_n_formaldefs.add(n)
		n.parent = self
	end
	for n in n_superclasses do
		assert n isa ASuperclass
		_n_superclasses.add(n)
		n.parent = self
	end
	for n in n_propdefs do
		assert n isa APropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_classkind == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AClasskind
                _n_classkind = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_formaldefs.length[ do
            if _n_formaldefs[i] == old_child then
                if new_child != null then
		    assert new_child isa AFormaldef
                    _n_formaldefs[i] = new_child
                    new_child.parent = self
                else
                    _n_formaldefs.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_superclasses.length[ do
            if _n_superclasses[i] == old_child then
                if new_child != null then
		    assert new_child isa ASuperclass
                    _n_superclasses[i] = new_child
                    new_child.parent = self
                else
                    _n_superclasses.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa APropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_classkind)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
            for n in _n_formaldefs do
                v.enter_visit(n)
	    end
            for n in _n_superclasses do
                v.enter_visit(n)
	    end
            for n in _n_propdefs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_classkind)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
	do
	    var i = _n_formaldefs.length
            while i >= 0 do
                v.enter_visit(_n_formaldefs[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_superclasses.length
            while i >= 0 do
                v.enter_visit(_n_superclasses[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_propdefs.length
            while i >= 0 do
                v.enter_visit(_n_propdefs[i])
		i = i - 1
	    end
	end
    end
end
redef class ATopClassdef

    private init empty_init do end

    init init_atopclassdef (
            n_propdefs: Collection[Object]  # Should be Collection[APropdef]
    )
    do
        empty_init
	for n in n_propdefs do
		assert n isa APropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa APropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_propdefs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_propdefs.length
            while i >= 0 do
                v.enter_visit(_n_propdefs[i])
		i = i - 1
	    end
	end
    end
end
redef class AMainClassdef

    private init empty_init do end

    init init_amainclassdef (
            n_propdefs: Collection[Object]  # Should be Collection[APropdef]
    )
    do
        empty_init
	for n in n_propdefs do
		assert n isa APropdef
		_n_propdefs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_propdefs.length[ do
            if _n_propdefs[i] == old_child then
                if new_child != null then
		    assert new_child isa APropdef
                    _n_propdefs[i] = new_child
                    new_child.parent = self
                else
                    _n_propdefs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_propdefs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_propdefs.length
            while i >= 0 do
                v.enter_visit(_n_propdefs[i])
		i = i - 1
	    end
	end
    end
end
redef class AConcreteClasskind
    redef fun n_kwclass=(n)
    do
        _n_kwclass = n
	n.parent = self
    end

    private init empty_init do end

    init init_aconcreteclasskind (
            n_kwclass: nullable TKwclass 
    )
    do
        empty_init
        _n_kwclass = n_kwclass.as(not null)
	n_kwclass.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwclass == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwclass
                _n_kwclass = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwclass)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwclass)
    end
end
redef class AAbstractClasskind
    redef fun n_kwabstract=(n)
    do
        _n_kwabstract = n
	n.parent = self
    end
    redef fun n_kwclass=(n)
    do
        _n_kwclass = n
	n.parent = self
    end

    private init empty_init do end

    init init_aabstractclasskind (
            n_kwabstract: nullable TKwabstract ,
            n_kwclass: nullable TKwclass 
    )
    do
        empty_init
        _n_kwabstract = n_kwabstract.as(not null)
	n_kwabstract.parent = self
        _n_kwclass = n_kwclass.as(not null)
	n_kwclass.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwabstract == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwabstract
                _n_kwabstract = new_child
	    else
		abort
            end
            return
	end
        if _n_kwclass == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwclass
                _n_kwclass = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwabstract)
        v.enter_visit(_n_kwclass)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwabstract)
        v.enter_visit(_n_kwclass)
    end
end
redef class AInterfaceClasskind
    redef fun n_kwinterface=(n)
    do
        _n_kwinterface = n
	n.parent = self
    end

    private init empty_init do end

    init init_ainterfaceclasskind (
            n_kwinterface: nullable TKwinterface 
    )
    do
        empty_init
        _n_kwinterface = n_kwinterface.as(not null)
	n_kwinterface.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwinterface == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinterface
                _n_kwinterface = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwinterface)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwinterface)
    end
end
redef class AUniversalClasskind
    redef fun n_kwuniversal=(n)
    do
        _n_kwuniversal = n
	n.parent = self
    end

    private init empty_init do end

    init init_auniversalclasskind (
            n_kwuniversal: nullable TKwuniversal 
    )
    do
        empty_init
        _n_kwuniversal = n_kwuniversal.as(not null)
	n_kwuniversal.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwuniversal == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwuniversal
                _n_kwuniversal = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwuniversal)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwuniversal)
    end
end
redef class AFormaldef
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aformaldef (
            n_id: nullable TClassid ,
            n_type: nullable AType 
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
    end
end
redef class ASuperclass
    redef fun n_kwspecial=(n)
    do
        _n_kwspecial = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
	n.parent = self
    end

    private init empty_init do end

    init init_asuperclass (
            n_kwspecial: nullable TKwspecial ,
            n_type: nullable AType 
    )
    do
        empty_init
        _n_kwspecial = n_kwspecial.as(not null)
	n_kwspecial.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwspecial == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwspecial
                _n_kwspecial = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwspecial)
        v.enter_visit(_n_type)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwspecial)
        v.enter_visit(_n_type)
    end
end
redef class AAttrPropdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_readable=(n)
    do
        _n_readable = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_writable=(n)
    do
        _n_writable = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwattr=(n)
    do
        _n_kwattr = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwvar=(n)
    do
        _n_kwvar = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aattrpropdef (
            n_doc: nullable ADoc ,
            n_readable: nullable AAble ,
            n_writable: nullable AAble ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_kwattr: nullable TKwattr ,
            n_kwvar: nullable TKwvar ,
            n_id: nullable TAttrid ,
            n_type: nullable AType ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_readable = n_readable
	if n_readable != null then
		n_readable.parent = self
	end
        _n_writable = n_writable
	if n_writable != null then
		n_writable.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwattr = n_kwattr
	if n_kwattr != null then
		n_kwattr.parent = self
	end
        _n_kwvar = n_kwvar
	if n_kwvar != null then
		n_kwvar.parent = self
	end
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_readable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAble
                _n_readable = new_child
	    else
		_n_readable = null
            end
            return
	end
        if _n_writable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAble
                _n_writable = new_child
	    else
		_n_writable = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwattr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwattr
                _n_kwattr = new_child
	    else
		_n_kwattr = null
            end
            return
	end
        if _n_kwvar == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwvar
                _n_kwvar = new_child
	    else
		_n_kwvar = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_readable != null then
            v.enter_visit(_n_readable.as(not null))
        end
        if _n_writable != null then
            v.enter_visit(_n_writable.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        if _n_kwattr != null then
            v.enter_visit(_n_kwattr.as(not null))
        end
        if _n_kwvar != null then
            v.enter_visit(_n_kwvar.as(not null))
        end
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_readable != null then
            v.enter_visit(_n_readable.as(not null))
        end
        if _n_writable != null then
            v.enter_visit(_n_writable.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        if _n_kwattr != null then
            v.enter_visit(_n_kwattr.as(not null))
        end
        if _n_kwvar != null then
            v.enter_visit(_n_kwvar.as(not null))
        end
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AMethPropdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_methid=(n)
    do
        _n_methid = n
	n.parent = self
    end
    redef fun n_signature=(n)
    do
        _n_signature = n
	n.parent = self
    end

    private init empty_init do end

    init init_amethpropdef (
            n_doc: nullable ADoc ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_methid: nullable AMethid ,
            n_signature: nullable ASignature 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end
end
redef class ADeferredMethPropdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwmeth=(n)
    do
        _n_kwmeth = n
	n.parent = self
    end
    redef fun n_methid=(n)
    do
        _n_methid = n
	n.parent = self
    end
    redef fun n_signature=(n)
    do
        _n_signature = n
	n.parent = self
    end

    private init empty_init do end

    init init_adeferredmethpropdef (
            n_doc: nullable ADoc ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_kwmeth: nullable TKwmeth ,
            n_methid: nullable AMethid ,
            n_signature: nullable ASignature 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwmeth = n_kwmeth.as(not null)
	n_kwmeth.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end
end
redef class AInternMethPropdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwmeth=(n)
    do
        _n_kwmeth = n
	n.parent = self
    end
    redef fun n_methid=(n)
    do
        _n_methid = n
	n.parent = self
    end
    redef fun n_signature=(n)
    do
        _n_signature = n
	n.parent = self
    end

    private init empty_init do end

    init init_ainternmethpropdef (
            n_doc: nullable ADoc ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_kwmeth: nullable TKwmeth ,
            n_methid: nullable AMethid ,
            n_signature: nullable ASignature 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwmeth = n_kwmeth.as(not null)
	n_kwmeth.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
    end
end
redef class AExternMethPropdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwmeth=(n)
    do
        _n_kwmeth = n
	n.parent = self
    end
    redef fun n_methid=(n)
    do
        _n_methid = n
	n.parent = self
    end
    redef fun n_signature=(n)
    do
        _n_signature = n
	n.parent = self
    end
    redef fun n_extern=(n)
    do
        _n_extern = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aexternmethpropdef (
            n_doc: nullable ADoc ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_kwmeth: nullable TKwmeth ,
            n_methid: nullable AMethid ,
            n_signature: nullable ASignature ,
            n_extern: nullable TString 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwmeth = n_kwmeth.as(not null)
	n_kwmeth.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
        _n_extern = n_extern
	if n_extern != null then
		n_extern.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
        if _n_extern == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TString
                _n_extern = new_child
	    else
		_n_extern = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
        if _n_extern != null then
            v.enter_visit(_n_extern.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
        if _n_extern != null then
            v.enter_visit(_n_extern.as(not null))
        end
    end
end
redef class AConcreteMethPropdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwmeth=(n)
    do
        _n_kwmeth = n
	n.parent = self
    end
    redef fun n_methid=(n)
    do
        _n_methid = n
	n.parent = self
    end
    redef fun n_signature=(n)
    do
        _n_signature = n
	n.parent = self
    end
    redef fun n_block=(n)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aconcretemethpropdef (
            n_doc: nullable ADoc ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_kwmeth: nullable TKwmeth ,
            n_methid: nullable AMethid ,
            n_signature: nullable ASignature ,
            n_block: nullable AExpr 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwmeth = n_kwmeth.as(not null)
	n_kwmeth.parent = self
        _n_methid = n_methid.as(not null)
	n_methid.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwmeth == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwmeth
                _n_kwmeth = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwmeth)
        v.enter_visit(_n_methid)
        v.enter_visit(_n_signature)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class AConcreteInitPropdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwinit=(n)
    do
        _n_kwinit = n
	n.parent = self
    end
    redef fun n_methid=(n)
    do
        _n_methid = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_signature=(n)
    do
        _n_signature = n
	n.parent = self
    end
    redef fun n_block=(n)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aconcreteinitpropdef (
            n_doc: nullable ADoc ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_kwinit: nullable TKwinit ,
            n_methid: nullable AMethid ,
            n_signature: nullable ASignature ,
            n_block: nullable AExpr 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwinit = n_kwinit.as(not null)
	n_kwinit.parent = self
        _n_methid = n_methid
	if n_methid != null then
		n_methid.parent = self
	end
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwinit == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinit
                _n_kwinit = new_child
	    else
		abort
            end
            return
	end
        if _n_methid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AMethid
                _n_methid = new_child
	    else
		_n_methid = null
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwinit)
        if _n_methid != null then
            v.enter_visit(_n_methid.as(not null))
        end
        v.enter_visit(_n_signature)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwinit)
        if _n_methid != null then
            v.enter_visit(_n_methid.as(not null))
        end
        v.enter_visit(_n_signature)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class AMainMethPropdef
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_block=(n)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_amainmethpropdef (
            n_kwredef: nullable TKwredef ,
            n_block: nullable AExpr 
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class ATypePropdef
    redef fun n_doc=(n)
    do
        _n_doc = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_visibility=(n)
    do
        _n_visibility = n
	n.parent = self
    end
    redef fun n_kwtype=(n)
    do
        _n_kwtype = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
	n.parent = self
    end

    private init empty_init do end

    init init_atypepropdef (
            n_doc: nullable ADoc ,
            n_kwredef: nullable TKwredef ,
            n_visibility: nullable AVisibility ,
            n_kwtype: nullable TKwtype ,
            n_id: nullable TClassid ,
            n_type: nullable AType 
    )
    do
        empty_init
        _n_doc = n_doc
	if n_doc != null then
		n_doc.parent = self
	end
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_visibility = n_visibility.as(not null)
	n_visibility.parent = self
        _n_kwtype = n_kwtype.as(not null)
	n_kwtype.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_doc == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ADoc
                _n_doc = new_child
	    else
		_n_doc = null
            end
            return
	end
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_visibility == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AVisibility
                _n_visibility = new_child
	    else
		abort
            end
            return
	end
        if _n_kwtype == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwtype
                _n_kwtype = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwtype)
        v.enter_visit(_n_id)
        v.enter_visit(_n_type)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_doc != null then
            v.enter_visit(_n_doc.as(not null))
        end
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_visibility)
        v.enter_visit(_n_kwtype)
        v.enter_visit(_n_id)
        v.enter_visit(_n_type)
    end
end
redef class AReadAble
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwreadable=(n)
    do
        _n_kwreadable = n
	n.parent = self
    end

    private init empty_init do end

    init init_areadable (
            n_kwredef: nullable TKwredef ,
            n_kwreadable: nullable TKwreadable 
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_kwreadable = n_kwreadable.as(not null)
	n_kwreadable.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_kwreadable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwreadable
                _n_kwreadable = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_kwreadable)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_kwreadable)
    end
end
redef class AWriteAble
    redef fun n_kwredef=(n)
    do
        _n_kwredef = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwwritable=(n)
    do
        _n_kwwritable = n
	n.parent = self
    end

    private init empty_init do end

    init init_awriteable (
            n_kwredef: nullable TKwredef ,
            n_kwwritable: nullable TKwwritable 
    )
    do
        empty_init
        _n_kwredef = n_kwredef
	if n_kwredef != null then
		n_kwredef.parent = self
	end
        _n_kwwritable = n_kwwritable.as(not null)
	n_kwwritable.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwredef == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwredef
                _n_kwredef = new_child
	    else
		_n_kwredef = null
            end
            return
	end
        if _n_kwwritable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwritable
                _n_kwwritable = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_kwwritable)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_kwredef != null then
            v.enter_visit(_n_kwredef.as(not null))
        end
        v.enter_visit(_n_kwwritable)
    end
end
redef class AIdMethid
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_aidmethid (
            n_id: nullable TId 
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_id)
    end
end
redef class APlusMethid
    redef fun n_plus=(n)
    do
        _n_plus = n
	n.parent = self
    end

    private init empty_init do end

    init init_aplusmethid (
            n_plus: nullable TPlus 
    )
    do
        empty_init
        _n_plus = n_plus.as(not null)
	n_plus.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_plus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPlus
                _n_plus = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_plus)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_plus)
    end
end
redef class AMinusMethid
    redef fun n_minus=(n)
    do
        _n_minus = n
	n.parent = self
    end

    private init empty_init do end

    init init_aminusmethid (
            n_minus: nullable TMinus 
    )
    do
        empty_init
        _n_minus = n_minus.as(not null)
	n_minus.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_minus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinus
                _n_minus = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_minus)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_minus)
    end
end
redef class AStarMethid
    redef fun n_star=(n)
    do
        _n_star = n
	n.parent = self
    end

    private init empty_init do end

    init init_astarmethid (
            n_star: nullable TStar 
    )
    do
        empty_init
        _n_star = n_star.as(not null)
	n_star.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_star == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStar
                _n_star = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_star)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_star)
    end
end
redef class ASlashMethid
    redef fun n_slash=(n)
    do
        _n_slash = n
	n.parent = self
    end

    private init empty_init do end

    init init_aslashmethid (
            n_slash: nullable TSlash 
    )
    do
        empty_init
        _n_slash = n_slash.as(not null)
	n_slash.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_slash == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TSlash
                _n_slash = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_slash)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_slash)
    end
end
redef class APercentMethid
    redef fun n_percent=(n)
    do
        _n_percent = n
	n.parent = self
    end

    private init empty_init do end

    init init_apercentmethid (
            n_percent: nullable TPercent 
    )
    do
        empty_init
        _n_percent = n_percent.as(not null)
	n_percent.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_percent == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPercent
                _n_percent = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_percent)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_percent)
    end
end
redef class AEqMethid
    redef fun n_eq=(n)
    do
        _n_eq = n
	n.parent = self
    end

    private init empty_init do end

    init init_aeqmethid (
            n_eq: nullable TEq 
    )
    do
        empty_init
        _n_eq = n_eq.as(not null)
	n_eq.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_eq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TEq
                _n_eq = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_eq)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_eq)
    end
end
redef class ANeMethid
    redef fun n_ne=(n)
    do
        _n_ne = n
	n.parent = self
    end

    private init empty_init do end

    init init_anemethid (
            n_ne: nullable TNe 
    )
    do
        empty_init
        _n_ne = n_ne.as(not null)
	n_ne.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_ne == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TNe
                _n_ne = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_ne)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_ne)
    end
end
redef class ALeMethid
    redef fun n_le=(n)
    do
        _n_le = n
	n.parent = self
    end

    private init empty_init do end

    init init_alemethid (
            n_le: nullable TLe 
    )
    do
        empty_init
        _n_le = n_le.as(not null)
	n_le.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_le == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TLe
                _n_le = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_le)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_le)
    end
end
redef class AGeMethid
    redef fun n_ge=(n)
    do
        _n_ge = n
	n.parent = self
    end

    private init empty_init do end

    init init_agemethid (
            n_ge: nullable TGe 
    )
    do
        empty_init
        _n_ge = n_ge.as(not null)
	n_ge.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_ge == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TGe
                _n_ge = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_ge)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_ge)
    end
end
redef class ALtMethid
    redef fun n_lt=(n)
    do
        _n_lt = n
	n.parent = self
    end

    private init empty_init do end

    init init_altmethid (
            n_lt: nullable TLt 
    )
    do
        empty_init
        _n_lt = n_lt.as(not null)
	n_lt.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_lt == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TLt
                _n_lt = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_lt)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_lt)
    end
end
redef class AGtMethid
    redef fun n_gt=(n)
    do
        _n_gt = n
	n.parent = self
    end

    private init empty_init do end

    init init_agtmethid (
            n_gt: nullable TGt 
    )
    do
        empty_init
        _n_gt = n_gt.as(not null)
	n_gt.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_gt == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TGt
                _n_gt = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_gt)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_gt)
    end
end
redef class ABraMethid
    redef fun n_obra=(n)
    do
        _n_obra = n
	n.parent = self
    end
    redef fun n_cbra=(n)
    do
        _n_cbra = n
	n.parent = self
    end

    private init empty_init do end

    init init_abramethid (
            n_obra: nullable TObra ,
            n_cbra: nullable TCbra 
    )
    do
        empty_init
        _n_obra = n_obra.as(not null)
	n_obra.parent = self
        _n_cbra = n_cbra.as(not null)
	n_cbra.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_obra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TObra
                _n_obra = new_child
	    else
		abort
            end
            return
	end
        if _n_cbra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TCbra
                _n_cbra = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_obra)
        v.enter_visit(_n_cbra)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_obra)
        v.enter_visit(_n_cbra)
    end
end
redef class AStarshipMethid
    redef fun n_starship=(n)
    do
        _n_starship = n
	n.parent = self
    end

    private init empty_init do end

    init init_astarshipmethid (
            n_starship: nullable TStarship 
    )
    do
        empty_init
        _n_starship = n_starship.as(not null)
	n_starship.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_starship == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStarship
                _n_starship = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_starship)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_starship)
    end
end
redef class AAssignMethid
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_assign=(n)
    do
        _n_assign = n
	n.parent = self
    end

    private init empty_init do end

    init init_aassignmethid (
            n_id: nullable TId ,
            n_assign: nullable TAssign 
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
    end
end
redef class ABraassignMethid
    redef fun n_obra=(n)
    do
        _n_obra = n
	n.parent = self
    end
    redef fun n_cbra=(n)
    do
        _n_cbra = n
	n.parent = self
    end
    redef fun n_assign=(n)
    do
        _n_assign = n
	n.parent = self
    end

    private init empty_init do end

    init init_abraassignmethid (
            n_obra: nullable TObra ,
            n_cbra: nullable TCbra ,
            n_assign: nullable TAssign 
    )
    do
        empty_init
        _n_obra = n_obra.as(not null)
	n_obra.parent = self
        _n_cbra = n_cbra.as(not null)
	n_cbra.parent = self
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_obra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TObra
                _n_obra = new_child
	    else
		abort
            end
            return
	end
        if _n_cbra == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TCbra
                _n_cbra = new_child
	    else
		abort
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_obra)
        v.enter_visit(_n_cbra)
        v.enter_visit(_n_assign)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_obra)
        v.enter_visit(_n_cbra)
        v.enter_visit(_n_assign)
    end
end
redef class ASignature
    redef fun n_type=(n)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_asignature (
            n_params: Collection[Object] , # Should be Collection[AParam]
            n_type: nullable AType ,
            n_closure_decls: Collection[Object]  # Should be Collection[AClosureDecl]
    )
    do
        empty_init
	for n in n_params do
		assert n isa AParam
		_n_params.add(n)
		n.parent = self
	end
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
	for n in n_closure_decls do
		assert n isa AClosureDecl
		_n_closure_decls.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_params.length[ do
            if _n_params[i] == old_child then
                if new_child != null then
		    assert new_child isa AParam
                    _n_params[i] = new_child
                    new_child.parent = self
                else
                    _n_params.remove_at(i)
                end
                return
            end
        end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        for i in [0.._n_closure_decls.length[ do
            if _n_closure_decls[i] == old_child then
                if new_child != null then
		    assert new_child isa AClosureDecl
                    _n_closure_decls[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_decls.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_params do
                v.enter_visit(n)
	    end
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
            for n in _n_closure_decls do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_params.length
            while i >= 0 do
                v.enter_visit(_n_params[i])
		i = i - 1
	    end
	end
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
	do
	    var i = _n_closure_decls.length
            while i >= 0 do
                v.enter_visit(_n_closure_decls[i])
		i = i - 1
	    end
	end
    end
end
redef class AParam
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_dotdotdot=(n)
    do
        _n_dotdotdot = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aparam (
            n_id: nullable TId ,
            n_type: nullable AType ,
            n_dotdotdot: nullable TDotdotdot 
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_dotdotdot = n_dotdotdot
	if n_dotdotdot != null then
		n_dotdotdot.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_dotdotdot == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TDotdotdot
                _n_dotdotdot = new_child
	    else
		_n_dotdotdot = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_dotdotdot != null then
            v.enter_visit(_n_dotdotdot.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_dotdotdot != null then
            v.enter_visit(_n_dotdotdot.as(not null))
        end
    end
end
redef class AClosureDecl
    redef fun n_kwwith=(n)
    do
        _n_kwwith = n
	n.parent = self
    end
    redef fun n_kwbreak=(n)
    do
        _n_kwbreak = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_signature=(n)
    do
        _n_signature = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aclosuredecl (
            n_kwwith: nullable TKwwith ,
            n_kwbreak: nullable TKwbreak ,
            n_id: nullable TId ,
            n_signature: nullable ASignature ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwwith = n_kwwith.as(not null)
	n_kwwith.parent = self
        _n_kwbreak = n_kwbreak
	if n_kwbreak != null then
		n_kwbreak.parent = self
	end
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_signature = n_signature.as(not null)
	n_signature.parent = self
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwwith == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwith
                _n_kwwith = new_child
	    else
		abort
            end
            return
	end
        if _n_kwbreak == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwbreak
                _n_kwbreak = new_child
	    else
		_n_kwbreak = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_signature == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa ASignature
                _n_signature = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwwith)
        if _n_kwbreak != null then
            v.enter_visit(_n_kwbreak.as(not null))
        end
        v.enter_visit(_n_id)
        v.enter_visit(_n_signature)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwwith)
        if _n_kwbreak != null then
            v.enter_visit(_n_kwbreak.as(not null))
        end
        v.enter_visit(_n_id)
        v.enter_visit(_n_signature)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AType
    redef fun n_kwnullable=(n)
    do
        _n_kwnullable = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_atype (
            n_kwnullable: nullable TKwnullable ,
            n_id: nullable TClassid ,
            n_types: Collection[Object]  # Should be Collection[AType]
    )
    do
        empty_init
        _n_kwnullable = n_kwnullable
	if n_kwnullable != null then
		n_kwnullable.parent = self
	end
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_types do
		assert n isa AType
		_n_types.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwnullable == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnullable
                _n_kwnullable = new_child
	    else
		_n_kwnullable = null
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_types.length[ do
            if _n_types[i] == old_child then
                if new_child != null then
		    assert new_child isa AType
                    _n_types[i] = new_child
                    new_child.parent = self
                else
                    _n_types.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_kwnullable != null then
            v.enter_visit(_n_kwnullable.as(not null))
        end
        v.enter_visit(_n_id)
            for n in _n_types do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_kwnullable != null then
            v.enter_visit(_n_kwnullable.as(not null))
        end
        v.enter_visit(_n_id)
	do
	    var i = _n_types.length
            while i >= 0 do
                v.enter_visit(_n_types[i])
		i = i - 1
	    end
	end
    end
end
redef class ABlockExpr

    private init empty_init do end

    init init_ablockexpr (
            n_expr: Collection[Object]  # Should be Collection[AExpr]
    )
    do
        empty_init
	for n in n_expr do
		assert n isa AExpr
		_n_expr.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_expr.length[ do
            if _n_expr[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_expr[i] = new_child
                    new_child.parent = self
                else
                    _n_expr.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_expr do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_expr.length
            while i >= 0 do
                v.enter_visit(_n_expr[i])
		i = i - 1
	    end
	end
    end
end
redef class AVardeclExpr
    redef fun n_kwvar=(n)
    do
        _n_kwvar = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_assign=(n)
    do
        _n_assign = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_avardeclexpr (
            n_kwvar: nullable TKwvar ,
            n_id: nullable TId ,
            n_type: nullable AType ,
            n_assign: nullable TAssign ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwvar = n_kwvar.as(not null)
	n_kwvar.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_type = n_type
	if n_type != null then
		n_type.parent = self
	end
        _n_assign = n_assign
	if n_assign != null then
		n_assign.parent = self
	end
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwvar == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwvar
                _n_kwvar = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		_n_type = null
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		_n_assign = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwvar)
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_assign != null then
            v.enter_visit(_n_assign.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwvar)
        v.enter_visit(_n_id)
        if _n_type != null then
            v.enter_visit(_n_type.as(not null))
        end
        if _n_assign != null then
            v.enter_visit(_n_assign.as(not null))
        end
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AReturnExpr
    redef fun n_kwreturn=(n)
    do
        _n_kwreturn = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_areturnexpr (
            n_kwreturn: nullable TKwreturn ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwreturn = n_kwreturn.as(not null)
	n_kwreturn.parent = self
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwreturn == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwreturn
                _n_kwreturn = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwreturn)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwreturn)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class ABreakExpr
    redef fun n_kwbreak=(n)
    do
        _n_kwbreak = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_abreakexpr (
            n_kwbreak: nullable TKwbreak ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwbreak = n_kwbreak.as(not null)
	n_kwbreak.parent = self
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwbreak == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwbreak
                _n_kwbreak = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwbreak)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwbreak)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AAbortExpr
    redef fun n_kwabort=(n)
    do
        _n_kwabort = n
	n.parent = self
    end

    private init empty_init do end

    init init_aabortexpr (
            n_kwabort: nullable TKwabort 
    )
    do
        empty_init
        _n_kwabort = n_kwabort.as(not null)
	n_kwabort.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwabort == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwabort
                _n_kwabort = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwabort)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwabort)
    end
end
redef class AContinueExpr
    redef fun n_kwcontinue=(n)
    do
        _n_kwcontinue = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_acontinueexpr (
            n_kwcontinue: nullable TKwcontinue ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwcontinue = n_kwcontinue.as(not null)
	n_kwcontinue.parent = self
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwcontinue == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwcontinue
                _n_kwcontinue = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwcontinue)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwcontinue)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class ADoExpr
    redef fun n_kwdo=(n)
    do
        _n_kwdo = n
	n.parent = self
    end
    redef fun n_block=(n)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_adoexpr (
            n_kwdo: nullable TKwdo ,
            n_block: nullable AExpr 
    )
    do
        empty_init
        _n_kwdo = n_kwdo.as(not null)
	n_kwdo.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class AIfExpr
    redef fun n_kwif=(n)
    do
        _n_kwif = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_then=(n)
    do
        _n_then = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_else=(n)
    do
        _n_else = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aifexpr (
            n_kwif: nullable TKwif ,
            n_expr: nullable AExpr ,
            n_then: nullable AExpr ,
            n_else: nullable AExpr 
    )
    do
        empty_init
        _n_kwif = n_kwif.as(not null)
	n_kwif.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_then = n_then
	if n_then != null then
		n_then.parent = self
	end
        _n_else = n_else
	if n_else != null then
		n_else.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwif == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwif
                _n_kwif = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_then == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_then = new_child
	    else
		_n_then = null
            end
            return
	end
        if _n_else == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_else = new_child
	    else
		_n_else = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwif)
        v.enter_visit(_n_expr)
        if _n_then != null then
            v.enter_visit(_n_then.as(not null))
        end
        if _n_else != null then
            v.enter_visit(_n_else.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwif)
        v.enter_visit(_n_expr)
        if _n_then != null then
            v.enter_visit(_n_then.as(not null))
        end
        if _n_else != null then
            v.enter_visit(_n_else.as(not null))
        end
    end
end
redef class AIfexprExpr
    redef fun n_kwif=(n)
    do
        _n_kwif = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_kwthen=(n)
    do
        _n_kwthen = n
	n.parent = self
    end
    redef fun n_then=(n)
    do
        _n_then = n
	n.parent = self
    end
    redef fun n_kwelse=(n)
    do
        _n_kwelse = n
	n.parent = self
    end
    redef fun n_else=(n)
    do
        _n_else = n
	n.parent = self
    end

    private init empty_init do end

    init init_aifexprexpr (
            n_kwif: nullable TKwif ,
            n_expr: nullable AExpr ,
            n_kwthen: nullable TKwthen ,
            n_then: nullable AExpr ,
            n_kwelse: nullable TKwelse ,
            n_else: nullable AExpr 
    )
    do
        empty_init
        _n_kwif = n_kwif.as(not null)
	n_kwif.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwthen = n_kwthen.as(not null)
	n_kwthen.parent = self
        _n_then = n_then.as(not null)
	n_then.parent = self
        _n_kwelse = n_kwelse.as(not null)
	n_kwelse.parent = self
        _n_else = n_else.as(not null)
	n_else.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwif == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwif
                _n_kwif = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwthen == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwthen
                _n_kwthen = new_child
	    else
		abort
            end
            return
	end
        if _n_then == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_then = new_child
	    else
		abort
            end
            return
	end
        if _n_kwelse == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwelse
                _n_kwelse = new_child
	    else
		abort
            end
            return
	end
        if _n_else == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_else = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwif)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwthen)
        v.enter_visit(_n_then)
        v.enter_visit(_n_kwelse)
        v.enter_visit(_n_else)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwif)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwthen)
        v.enter_visit(_n_then)
        v.enter_visit(_n_kwelse)
        v.enter_visit(_n_else)
    end
end
redef class AWhileExpr
    redef fun n_kwwhile=(n)
    do
        _n_kwwhile = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_kwdo=(n)
    do
        _n_kwdo = n
	n.parent = self
    end
    redef fun n_block=(n)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_awhileexpr (
            n_kwwhile: nullable TKwwhile ,
            n_expr: nullable AExpr ,
            n_kwdo: nullable TKwdo ,
            n_block: nullable AExpr 
    )
    do
        empty_init
        _n_kwwhile = n_kwwhile.as(not null)
	n_kwwhile.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwdo = n_kwdo.as(not null)
	n_kwdo.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwwhile == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwhile
                _n_kwwhile = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwwhile)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwwhile)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class AForExpr
    redef fun n_kwfor=(n)
    do
        _n_kwfor = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_kwdo=(n)
    do
        _n_kwdo = n
	n.parent = self
    end
    redef fun n_block=(n)
    do
        _n_block = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aforexpr (
            n_kwfor: nullable TKwfor ,
            n_id: nullable TId ,
            n_expr: nullable AExpr ,
            n_kwdo: nullable TKwdo ,
            n_block: nullable AExpr 
    )
    do
        empty_init
        _n_kwfor = n_kwfor.as(not null)
	n_kwfor.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwdo = n_kwdo.as(not null)
	n_kwdo.parent = self
        _n_block = n_block
	if n_block != null then
		n_block.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwfor == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwfor
                _n_kwfor = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		abort
            end
            return
	end
        if _n_block == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_block = new_child
	    else
		_n_block = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwfor)
        v.enter_visit(_n_id)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwfor)
        v.enter_visit(_n_id)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwdo)
        if _n_block != null then
            v.enter_visit(_n_block.as(not null))
        end
    end
end
redef class AAssertExpr
    redef fun n_kwassert=(n)
    do
        _n_kwassert = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end

    private init empty_init do end

    init init_aassertexpr (
            n_kwassert: nullable TKwassert ,
            n_id: nullable TId ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwassert = n_kwassert.as(not null)
	n_kwassert.parent = self
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwassert == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwassert
                _n_kwassert = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwassert)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
        v.enter_visit(_n_expr)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwassert)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
        v.enter_visit(_n_expr)
    end
end
redef class AOnceExpr
    redef fun n_kwonce=(n)
    do
        _n_kwonce = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end

    private init empty_init do end

    init init_aonceexpr (
            n_kwonce: nullable TKwonce ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwonce = n_kwonce.as(not null)
	n_kwonce.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwonce == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwonce
                _n_kwonce = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwonce)
        v.enter_visit(_n_expr)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwonce)
        v.enter_visit(_n_expr)
    end
end
redef class ASendExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end

    private init empty_init do end

    init init_asendexpr (
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
    end
end
redef class ABinopExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_abinopexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AOrExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aorexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AAndExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aandexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ANotExpr
    redef fun n_kwnot=(n)
    do
        _n_kwnot = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end

    private init empty_init do end

    init init_anotexpr (
            n_kwnot: nullable TKwnot ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwnot = n_kwnot.as(not null)
	n_kwnot.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwnot == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnot
                _n_kwnot = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwnot)
        v.enter_visit(_n_expr)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwnot)
        v.enter_visit(_n_expr)
    end
end
redef class AEqExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aeqexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AEeExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aeeexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ANeExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aneexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ALtExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_altexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ALeExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aleexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AGtExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_agtexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AGeExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_ageexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AIsaExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
	n.parent = self
    end

    private init empty_init do end

    init init_aisaexpr (
            n_expr: nullable AExpr ,
            n_type: nullable AType 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_type)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_type)
    end
end
redef class APlusExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aplusexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AMinusExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aminusexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AStarshipExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_astarshipexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AStarExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_astarexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ASlashExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aslashexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class APercentExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_apercentexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AUminusExpr
    redef fun n_minus=(n)
    do
        _n_minus = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end

    private init empty_init do end

    init init_auminusexpr (
            n_minus: nullable TMinus ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_minus = n_minus.as(not null)
	n_minus.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_minus == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinus
                _n_minus = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_minus)
        v.enter_visit(_n_expr)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_minus)
        v.enter_visit(_n_expr)
    end
end
redef class ANewExpr
    redef fun n_kwnew=(n)
    do
        _n_kwnew = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_anewexpr (
            n_kwnew: nullable TKwnew ,
            n_type: nullable AType ,
            n_id: nullable TId ,
            n_args: Collection[Object]  # Should be Collection[AExpr]
    )
    do
        empty_init
        _n_kwnew = n_kwnew.as(not null)
	n_kwnew.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
        _n_id = n_id
	if n_id != null then
		n_id.parent = self
	end
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwnew == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnew
                _n_kwnew = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		_n_id = null
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwnew)
        v.enter_visit(_n_type)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
            for n in _n_args do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwnew)
        v.enter_visit(_n_type)
        if _n_id != null then
            v.enter_visit(_n_id.as(not null))
        end
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
    end
end
redef class AAttrExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_aattrexpr (
            n_expr: nullable AExpr ,
            n_id: nullable TAttrid 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
    end
end
redef class AAttrAssignExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_assign=(n)
    do
        _n_assign = n
	n.parent = self
    end
    redef fun n_value=(n)
    do
        _n_value = n
	n.parent = self
    end

    private init empty_init do end

    init init_aattrassignexpr (
            n_expr: nullable AExpr ,
            n_id: nullable TAttrid ,
            n_assign: nullable TAssign ,
            n_value: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end
end
redef class AAttrReassignExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_assign_op=(n)
    do
        _n_assign_op = n
	n.parent = self
    end
    redef fun n_value=(n)
    do
        _n_value = n
	n.parent = self
    end

    private init empty_init do end

    init init_aattrreassignexpr (
            n_expr: nullable AExpr ,
            n_id: nullable TAttrid ,
            n_assign_op: nullable AAssignOp ,
            n_value: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign_op = n_assign_op.as(not null)
	n_assign_op.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAssignOp
                _n_assign_op = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end
end
redef class ACallExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_acallexpr (
            n_expr: nullable AExpr ,
            n_id: nullable TId ,
            n_args: Collection[Object] , # Should be Collection[AExpr]
            n_closure_defs: Collection[Object]  # Should be Collection[AClosureDef]
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
	for n in n_closure_defs do
		assert n isa AClosureDef
		_n_closure_defs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_closure_defs.length[ do
            if _n_closure_defs[i] == old_child then
                if new_child != null then
		    assert new_child isa AClosureDef
                    _n_closure_defs[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_defs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
            for n in _n_args do
                v.enter_visit(n)
	    end
            for n in _n_closure_defs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_closure_defs.length
            while i >= 0 do
                v.enter_visit(_n_closure_defs[i])
		i = i - 1
	    end
	end
    end
end
redef class ACallAssignExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_assign=(n)
    do
        _n_assign = n
	n.parent = self
    end
    redef fun n_value=(n)
    do
        _n_value = n
	n.parent = self
    end

    private init empty_init do end

    init init_acallassignexpr (
            n_expr: nullable AExpr ,
            n_id: nullable TId ,
            n_args: Collection[Object] , # Should be Collection[AExpr]
            n_assign: nullable TAssign ,
            n_value: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
            for n in _n_args do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end
end
redef class ACallReassignExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_assign_op=(n)
    do
        _n_assign_op = n
	n.parent = self
    end
    redef fun n_value=(n)
    do
        _n_value = n
	n.parent = self
    end

    private init empty_init do end

    init init_acallreassignexpr (
            n_expr: nullable AExpr ,
            n_id: nullable TId ,
            n_args: Collection[Object] , # Should be Collection[AExpr]
            n_assign_op: nullable AAssignOp ,
            n_value: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign_op = n_assign_op.as(not null)
	n_assign_op.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAssignOp
                _n_assign_op = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
            for n in _n_args do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end
end
redef class ASuperExpr
    redef fun n_qualified=(n)
    do
        _n_qualified = n
        if n != null then
	    n.parent = self
        end
    end
    redef fun n_kwsuper=(n)
    do
        _n_kwsuper = n
	n.parent = self
    end

    private init empty_init do end

    init init_asuperexpr (
            n_qualified: nullable AQualified ,
            n_kwsuper: nullable TKwsuper ,
            n_args: Collection[Object]  # Should be Collection[AExpr]
    )
    do
        empty_init
        _n_qualified = n_qualified
	if n_qualified != null then
		n_qualified.parent = self
	end
        _n_kwsuper = n_kwsuper.as(not null)
	n_kwsuper.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_qualified == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AQualified
                _n_qualified = new_child
	    else
		_n_qualified = null
            end
            return
	end
        if _n_kwsuper == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwsuper
                _n_kwsuper = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_qualified != null then
            v.enter_visit(_n_qualified.as(not null))
        end
        v.enter_visit(_n_kwsuper)
            for n in _n_args do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_qualified != null then
            v.enter_visit(_n_qualified.as(not null))
        end
        v.enter_visit(_n_kwsuper)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
    end
end
redef class AInitExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_kwinit=(n)
    do
        _n_kwinit = n
	n.parent = self
    end

    private init empty_init do end

    init init_ainitexpr (
            n_expr: nullable AExpr ,
            n_kwinit: nullable TKwinit ,
            n_args: Collection[Object]  # Should be Collection[AExpr]
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwinit = n_kwinit.as(not null)
	n_kwinit.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwinit == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwinit
                _n_kwinit = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwinit)
            for n in _n_args do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwinit)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
    end
end
redef class ABraExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end

    private init empty_init do end

    init init_abraexpr (
            n_expr: nullable AExpr ,
            n_args: Collection[Object] , # Should be Collection[AExpr]
            n_closure_defs: Collection[Object]  # Should be Collection[AClosureDef]
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
	for n in n_closure_defs do
		assert n isa AClosureDef
		_n_closure_defs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_closure_defs.length[ do
            if _n_closure_defs[i] == old_child then
                if new_child != null then
		    assert new_child isa AClosureDef
                    _n_closure_defs[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_defs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
            for n in _n_args do
                v.enter_visit(n)
	    end
            for n in _n_closure_defs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_closure_defs.length
            while i >= 0 do
                v.enter_visit(_n_closure_defs[i])
		i = i - 1
	    end
	end
    end
end
redef class ABraAssignExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_assign=(n)
    do
        _n_assign = n
	n.parent = self
    end
    redef fun n_value=(n)
    do
        _n_value = n
	n.parent = self
    end

    private init empty_init do end

    init init_abraassignexpr (
            n_expr: nullable AExpr ,
            n_args: Collection[Object] , # Should be Collection[AExpr]
            n_assign: nullable TAssign ,
            n_value: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
            for n in _n_args do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end
end
redef class ABraReassignExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_assign_op=(n)
    do
        _n_assign_op = n
	n.parent = self
    end
    redef fun n_value=(n)
    do
        _n_value = n
	n.parent = self
    end

    private init empty_init do end

    init init_abrareassignexpr (
            n_expr: nullable AExpr ,
            n_args: Collection[Object] , # Should be Collection[AExpr]
            n_assign_op: nullable AAssignOp ,
            n_value: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
        _n_assign_op = n_assign_op.as(not null)
	n_assign_op.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAssignOp
                _n_assign_op = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
            for n in _n_args do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end
end
redef class AClosureCallExpr
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_aclosurecallexpr (
            n_id: nullable TId ,
            n_args: Collection[Object] , # Should be Collection[AExpr]
            n_closure_defs: Collection[Object]  # Should be Collection[AClosureDef]
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
	for n in n_args do
		assert n isa AExpr
		_n_args.add(n)
		n.parent = self
	end
	for n in n_closure_defs do
		assert n isa AClosureDef
		_n_closure_defs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_args.length[ do
            if _n_args[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_args[i] = new_child
                    new_child.parent = self
                else
                    _n_args.remove_at(i)
                end
                return
            end
        end
        for i in [0.._n_closure_defs.length[ do
            if _n_closure_defs[i] == old_child then
                if new_child != null then
		    assert new_child isa AClosureDef
                    _n_closure_defs[i] = new_child
                    new_child.parent = self
                else
                    _n_closure_defs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
            for n in _n_args do
                v.enter_visit(n)
	    end
            for n in _n_closure_defs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_id)
	do
	    var i = _n_args.length
            while i >= 0 do
                v.enter_visit(_n_args[i])
		i = i - 1
	    end
	end
	do
	    var i = _n_closure_defs.length
            while i >= 0 do
                v.enter_visit(_n_closure_defs[i])
		i = i - 1
	    end
	end
    end
end
redef class AVarExpr
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_avarexpr (
            n_id: nullable TId 
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_id)
    end
end
redef class AVarAssignExpr
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_assign=(n)
    do
        _n_assign = n
	n.parent = self
    end
    redef fun n_value=(n)
    do
        _n_value = n
	n.parent = self
    end

    private init empty_init do end

    init init_avarassignexpr (
            n_id: nullable TId ,
            n_assign: nullable TAssign ,
            n_value: nullable AExpr 
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign = n_assign.as(not null)
	n_assign.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAssign
                _n_assign = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign)
        v.enter_visit(_n_value)
    end
end
redef class AVarReassignExpr
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end
    redef fun n_assign_op=(n)
    do
        _n_assign_op = n
	n.parent = self
    end
    redef fun n_value=(n)
    do
        _n_value = n
	n.parent = self
    end

    private init empty_init do end

    init init_avarreassignexpr (
            n_id: nullable TId ,
            n_assign_op: nullable AAssignOp ,
            n_value: nullable AExpr 
    )
    do
        empty_init
        _n_id = n_id.as(not null)
	n_id.parent = self
        _n_assign_op = n_assign_op.as(not null)
	n_assign_op.parent = self
        _n_value = n_value.as(not null)
	n_value.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TId
                _n_id = new_child
	    else
		abort
            end
            return
	end
        if _n_assign_op == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AAssignOp
                _n_assign_op = new_child
	    else
		abort
            end
            return
	end
        if _n_value == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_value = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_id)
        v.enter_visit(_n_assign_op)
        v.enter_visit(_n_value)
    end
end
redef class ARangeExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_arangeexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class ACrangeExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_acrangeexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AOrangeExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_expr2=(n)
    do
        _n_expr2 = n
	n.parent = self
    end

    private init empty_init do end

    init init_aorangeexpr (
            n_expr: nullable AExpr ,
            n_expr2: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_expr2 = n_expr2.as(not null)
	n_expr2.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_expr2 == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr2 = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_expr2)
    end
end
redef class AArrayExpr

    private init empty_init do end

    init init_aarrayexpr (
            n_exprs: Collection[Object]  # Should be Collection[AExpr]
    )
    do
        empty_init
	for n in n_exprs do
		assert n isa AExpr
		_n_exprs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_exprs.length[ do
            if _n_exprs[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_exprs[i] = new_child
                    new_child.parent = self
                else
                    _n_exprs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_exprs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_exprs.length
            while i >= 0 do
                v.enter_visit(_n_exprs[i])
		i = i - 1
	    end
	end
    end
end
redef class ASelfExpr
    redef fun n_kwself=(n)
    do
        _n_kwself = n
	n.parent = self
    end

    private init empty_init do end

    init init_aselfexpr (
            n_kwself: nullable TKwself 
    )
    do
        empty_init
        _n_kwself = n_kwself.as(not null)
	n_kwself.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwself == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwself
                _n_kwself = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwself)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwself)
    end
end
redef class AImplicitSelfExpr

    private init empty_init do end

    init init_aimplicitselfexpr
    do
        empty_init
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
    end

    redef fun visit_all(v: Visitor)
    do
    end

    redef fun visit_all_reverse(v: Visitor)
    do
    end
end
redef class ATrueExpr
    redef fun n_kwtrue=(n)
    do
        _n_kwtrue = n
	n.parent = self
    end

    private init empty_init do end

    init init_atrueexpr (
            n_kwtrue: nullable TKwtrue 
    )
    do
        empty_init
        _n_kwtrue = n_kwtrue.as(not null)
	n_kwtrue.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwtrue == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwtrue
                _n_kwtrue = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwtrue)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwtrue)
    end
end
redef class AFalseExpr
    redef fun n_kwfalse=(n)
    do
        _n_kwfalse = n
	n.parent = self
    end

    private init empty_init do end

    init init_afalseexpr (
            n_kwfalse: nullable TKwfalse 
    )
    do
        empty_init
        _n_kwfalse = n_kwfalse.as(not null)
	n_kwfalse.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwfalse == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwfalse
                _n_kwfalse = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwfalse)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwfalse)
    end
end
redef class ANullExpr
    redef fun n_kwnull=(n)
    do
        _n_kwnull = n
	n.parent = self
    end

    private init empty_init do end

    init init_anullexpr (
            n_kwnull: nullable TKwnull 
    )
    do
        empty_init
        _n_kwnull = n_kwnull.as(not null)
	n_kwnull.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwnull == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnull
                _n_kwnull = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwnull)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwnull)
    end
end
redef class AIntExpr
    redef fun n_number=(n)
    do
        _n_number = n
	n.parent = self
    end

    private init empty_init do end

    init init_aintexpr (
            n_number: nullable TNumber 
    )
    do
        empty_init
        _n_number = n_number.as(not null)
	n_number.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_number == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TNumber
                _n_number = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_number)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_number)
    end
end
redef class AFloatExpr
    redef fun n_float=(n)
    do
        _n_float = n
	n.parent = self
    end

    private init empty_init do end

    init init_afloatexpr (
            n_float: nullable TFloat 
    )
    do
        empty_init
        _n_float = n_float.as(not null)
	n_float.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_float == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TFloat
                _n_float = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_float)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_float)
    end
end
redef class ACharExpr
    redef fun n_char=(n)
    do
        _n_char = n
	n.parent = self
    end

    private init empty_init do end

    init init_acharexpr (
            n_char: nullable TChar 
    )
    do
        empty_init
        _n_char = n_char.as(not null)
	n_char.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_char == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TChar
                _n_char = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_char)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_char)
    end
end
redef class AStringExpr
    redef fun n_string=(n)
    do
        _n_string = n
	n.parent = self
    end

    private init empty_init do end

    init init_astringexpr (
            n_string: nullable TString 
    )
    do
        empty_init
        _n_string = n_string.as(not null)
	n_string.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TString
                _n_string = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_string)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_string)
    end
end
redef class AStartStringExpr
    redef fun n_string=(n)
    do
        _n_string = n
	n.parent = self
    end

    private init empty_init do end

    init init_astartstringexpr (
            n_string: nullable TStartString 
    )
    do
        empty_init
        _n_string = n_string.as(not null)
	n_string.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TStartString
                _n_string = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_string)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_string)
    end
end
redef class AMidStringExpr
    redef fun n_string=(n)
    do
        _n_string = n
	n.parent = self
    end

    private init empty_init do end

    init init_amidstringexpr (
            n_string: nullable TMidString 
    )
    do
        empty_init
        _n_string = n_string.as(not null)
	n_string.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMidString
                _n_string = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_string)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_string)
    end
end
redef class AEndStringExpr
    redef fun n_string=(n)
    do
        _n_string = n
	n.parent = self
    end

    private init empty_init do end

    init init_aendstringexpr (
            n_string: nullable TEndString 
    )
    do
        empty_init
        _n_string = n_string.as(not null)
	n_string.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_string == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TEndString
                _n_string = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_string)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_string)
    end
end
redef class ASuperstringExpr

    private init empty_init do end

    init init_asuperstringexpr (
            n_exprs: Collection[Object]  # Should be Collection[AExpr]
    )
    do
        empty_init
	for n in n_exprs do
		assert n isa AExpr
		_n_exprs.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_exprs.length[ do
            if _n_exprs[i] == old_child then
                if new_child != null then
		    assert new_child isa AExpr
                    _n_exprs[i] = new_child
                    new_child.parent = self
                else
                    _n_exprs.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_exprs do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_exprs.length
            while i >= 0 do
                v.enter_visit(_n_exprs[i])
		i = i - 1
	    end
	end
    end
end
redef class AParExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end

    private init empty_init do end

    init init_aparexpr (
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
    end
end
redef class AAsCastExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_kwas=(n)
    do
        _n_kwas = n
	n.parent = self
    end
    redef fun n_type=(n)
    do
        _n_type = n
	n.parent = self
    end

    private init empty_init do end

    init init_aascastexpr (
            n_expr: nullable AExpr ,
            n_kwas: nullable TKwas ,
            n_type: nullable AType 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwas = n_kwas.as(not null)
	n_kwas.parent = self
        _n_type = n_type.as(not null)
	n_type.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwas == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwas
                _n_kwas = new_child
	    else
		abort
            end
            return
	end
        if _n_type == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AType
                _n_type = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwas)
        v.enter_visit(_n_type)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwas)
        v.enter_visit(_n_type)
    end
end
redef class AAsNotnullExpr
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_kwas=(n)
    do
        _n_kwas = n
	n.parent = self
    end
    redef fun n_kwnot=(n)
    do
        _n_kwnot = n
	n.parent = self
    end
    redef fun n_kwnull=(n)
    do
        _n_kwnull = n
	n.parent = self
    end

    private init empty_init do end

    init init_aasnotnullexpr (
            n_expr: nullable AExpr ,
            n_kwas: nullable TKwas ,
            n_kwnot: nullable TKwnot ,
            n_kwnull: nullable TKwnull 
    )
    do
        empty_init
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_kwas = n_kwas.as(not null)
	n_kwas.parent = self
        _n_kwnot = n_kwnot.as(not null)
	n_kwnot.parent = self
        _n_kwnull = n_kwnull.as(not null)
	n_kwnull.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_kwas == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwas
                _n_kwas = new_child
	    else
		abort
            end
            return
	end
        if _n_kwnot == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnot
                _n_kwnot = new_child
	    else
		abort
            end
            return
	end
        if _n_kwnull == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwnull
                _n_kwnull = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwas)
        v.enter_visit(_n_kwnot)
        v.enter_visit(_n_kwnull)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_expr)
        v.enter_visit(_n_kwas)
        v.enter_visit(_n_kwnot)
        v.enter_visit(_n_kwnull)
    end
end
redef class AIssetAttrExpr
    redef fun n_kwisset=(n)
    do
        _n_kwisset = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
	n.parent = self
    end
    redef fun n_id=(n)
    do
        _n_id = n
	n.parent = self
    end

    private init empty_init do end

    init init_aissetattrexpr (
            n_kwisset: nullable TKwisset ,
            n_expr: nullable AExpr ,
            n_id: nullable TAttrid 
    )
    do
        empty_init
        _n_kwisset = n_kwisset.as(not null)
	n_kwisset.parent = self
        _n_expr = n_expr.as(not null)
	n_expr.parent = self
        _n_id = n_id.as(not null)
	n_id.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwisset == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwisset
                _n_kwisset = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		abort
            end
            return
	end
        if _n_id == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TAttrid
                _n_id = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwisset)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwisset)
        v.enter_visit(_n_expr)
        v.enter_visit(_n_id)
    end
end
redef class APlusAssignOp
    redef fun n_pluseq=(n)
    do
        _n_pluseq = n
	n.parent = self
    end

    private init empty_init do end

    init init_aplusassignop (
            n_pluseq: nullable TPluseq 
    )
    do
        empty_init
        _n_pluseq = n_pluseq.as(not null)
	n_pluseq.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_pluseq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TPluseq
                _n_pluseq = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_pluseq)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_pluseq)
    end
end
redef class AMinusAssignOp
    redef fun n_minuseq=(n)
    do
        _n_minuseq = n
	n.parent = self
    end

    private init empty_init do end

    init init_aminusassignop (
            n_minuseq: nullable TMinuseq 
    )
    do
        empty_init
        _n_minuseq = n_minuseq.as(not null)
	n_minuseq.parent = self
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_minuseq == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TMinuseq
                _n_minuseq = new_child
	    else
		abort
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_minuseq)
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_minuseq)
    end
end
redef class AClosureDef
    redef fun n_kwwith=(n)
    do
        _n_kwwith = n
	n.parent = self
    end
    redef fun n_kwdo=(n)
    do
        _n_kwdo = n
	n.parent = self
    end
    redef fun n_expr=(n)
    do
        _n_expr = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aclosuredef (
            n_kwwith: nullable TKwwith ,
            n_id: Collection[Object] , # Should be Collection[TId]
            n_kwdo: nullable TKwdo ,
            n_expr: nullable AExpr 
    )
    do
        empty_init
        _n_kwwith = n_kwwith.as(not null)
	n_kwwith.parent = self
	for n in n_id do
		assert n isa TId
		_n_id.add(n)
		n.parent = self
	end
        _n_kwdo = n_kwdo.as(not null)
	n_kwdo.parent = self
        _n_expr = n_expr
	if n_expr != null then
		n_expr.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_kwwith == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwwith
                _n_kwwith = new_child
	    else
		abort
            end
            return
	end
        for i in [0.._n_id.length[ do
            if _n_id[i] == old_child then
                if new_child != null then
		    assert new_child isa TId
                    _n_id[i] = new_child
                    new_child.parent = self
                else
                    _n_id.remove_at(i)
                end
                return
            end
        end
        if _n_kwdo == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TKwdo
                _n_kwdo = new_child
	    else
		abort
            end
            return
	end
        if _n_expr == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa AExpr
                _n_expr = new_child
	    else
		_n_expr = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        v.enter_visit(_n_kwwith)
            for n in _n_id do
                v.enter_visit(n)
	    end
        v.enter_visit(_n_kwdo)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        v.enter_visit(_n_kwwith)
	do
	    var i = _n_id.length
            while i >= 0 do
                v.enter_visit(_n_id[i])
		i = i - 1
	    end
	end
        v.enter_visit(_n_kwdo)
        if _n_expr != null then
            v.enter_visit(_n_expr.as(not null))
        end
    end
end
redef class AQualified
    redef fun n_classid=(n)
    do
        _n_classid = n
        if n != null then
	    n.parent = self
        end
    end

    private init empty_init do end

    init init_aqualified (
            n_id: Collection[Object] , # Should be Collection[TId]
            n_classid: nullable TClassid 
    )
    do
        empty_init
	for n in n_id do
		assert n isa TId
		_n_id.add(n)
		n.parent = self
	end
        _n_classid = n_classid
	if n_classid != null then
		n_classid.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_id.length[ do
            if _n_id[i] == old_child then
                if new_child != null then
		    assert new_child isa TId
                    _n_id[i] = new_child
                    new_child.parent = self
                else
                    _n_id.remove_at(i)
                end
                return
            end
        end
        if _n_classid == old_child then
            if new_child != null then
                new_child.parent = self
		assert new_child isa TClassid
                _n_classid = new_child
	    else
		_n_classid = null
            end
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_id do
                v.enter_visit(n)
	    end
        if _n_classid != null then
            v.enter_visit(_n_classid.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_id.length
            while i >= 0 do
                v.enter_visit(_n_id[i])
		i = i - 1
	    end
	end
        if _n_classid != null then
            v.enter_visit(_n_classid.as(not null))
        end
    end
end
redef class ADoc

    private init empty_init do end

    init init_adoc (
            n_comment: Collection[Object]  # Should be Collection[TComment]
    )
    do
        empty_init
	for n in n_comment do
		assert n isa TComment
		_n_comment.add(n)
		n.parent = self
	end
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        for i in [0.._n_comment.length[ do
            if _n_comment[i] == old_child then
                if new_child != null then
		    assert new_child isa TComment
                    _n_comment[i] = new_child
                    new_child.parent = self
                else
                    _n_comment.remove_at(i)
                end
                return
            end
        end
    end

    redef fun visit_all(v: Visitor)
    do
            for n in _n_comment do
                v.enter_visit(n)
	    end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
	do
	    var i = _n_comment.length
            while i >= 0 do
                v.enter_visit(_n_comment[i])
		i = i - 1
	    end
	end
    end
end

redef class Start
    init(
        n_base: nullable AModule,
        n_eof: EOF)
    do
        _n_base = n_base
        _n_eof = n_eof
    end

    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_base == old_child then
            if new_child == null then
            else
                new_child.parent = self
		assert new_child isa AModule
                _n_base = new_child
            end
            old_child.parent = null
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_base != null then
            v.enter_visit(_n_base.as(not null))
        end
    end

    redef fun visit_all_reverse(v: Visitor)
    do
        if _n_base != null then
            v.enter_visit(_n_base.as(not null))
        end
    end
end
