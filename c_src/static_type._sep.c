/* This C file is generated by NIT to compile module static_type. */
#include "static_type._sep.h"
val_t static_type___MMLocalClass___get_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 27, LOCATE_static_type___MMLocalClass___get_type};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 = ATTR_static_type___MMLocalClass____base_type_cache( self) /*MMLocalClass::_base_type_cache*/;
  variable0 = TAG_Bool((variable0 ==  NIT_NULL /*null*/) || ((variable0 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable0, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))(variable0,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable0)) { /*if*/
    variable0 = NEW_static_type___MMTypeSimpleClass___init( self); /*new MMTypeSimpleClass*/
    ATTR_static_type___MMLocalClass____base_type_cache( self) /*MMLocalClass::_base_type_cache*/ = variable0;
  }
  variable0 = ATTR_static_type___MMLocalClass____base_type_cache( self) /*MMLocalClass::_base_type_cache*/;
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable0;
}
void static_type___MMLocalClass___add_ancestor(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 34, LOCATE_static_type___MMLocalClass___add_ancestor};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = ATTR_static_type___MMLocalClass____ancestors( self) /*MMLocalClass::_ancestors*/;
  variable2 = ((static_type___MMAncestor___local_class_t)CALL( variable0 /*a*/,COLOR_static_type___MMAncestor___local_class))( variable0 /*a*/) /*MMAncestor::local_class*/;
  variable1 = ((abstract_collection___Map___has_key_t)CALL(variable1,COLOR_abstract_collection___Map___has_key))(variable1, variable2) /*Map::has_key*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable1)))) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMLocalClass___add_ancestor, LOCATE_static_type, 37); nit_exit(1);}
  variable1 = ((static_type___MMAncestor___local_class_t)CALL( variable0 /*a*/,COLOR_static_type___MMAncestor___local_class))( variable0 /*a*/) /*MMAncestor::local_class*/;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable1 ==  self) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, self)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  self) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable1)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMLocalClass___add_ancestor, LOCATE_static_type, 38); nit_exit(1);}
  variable1 = ATTR_static_type___MMLocalClass____ancestors( self) /*MMLocalClass::_ancestors*/;
  variable2 = ((static_type___MMAncestor___local_class_t)CALL( variable0 /*a*/,COLOR_static_type___MMAncestor___local_class))( variable0 /*a*/) /*MMAncestor::local_class*/;
  ((abstract_collection___Map_____braeq_t)CALL(variable1,COLOR_abstract_collection___Map_____braeq))(variable1, variable2,  variable0 /*a*/) /*Map::[]=*/;
  tracehead = trace.prev;
  return;
}
val_t static_type___MMLocalClass___ancestors(val_t  self) {
  struct trace_t trace = {NULL, NULL, 42, LOCATE_static_type___MMLocalClass___ancestors};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMLocalClass____ancestors( self) /*MMLocalClass::_ancestors*/;
}
val_t static_type___MMLocalClass___ancestor(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 45, LOCATE_static_type___MMLocalClass___ancestor};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = ATTR_static_type___MMLocalClass____ancestors( self) /*MMLocalClass::_ancestors*/;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable1)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMLocalClass___ancestor, LOCATE_static_type, 48); nit_exit(1);}
  variable1 = ATTR_static_type___MMLocalClass____ancestors( self) /*MMLocalClass::_ancestors*/;
  variable1 = ((abstract_collection___Map___has_key_t)CALL(variable1,COLOR_abstract_collection___Map___has_key))(variable1,  variable0 /*c*/) /*Map::has_key*/;
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = ATTR_static_type___MMLocalClass____ancestors( self) /*MMLocalClass::_ancestors*/;
    variable1 = ((abstract_collection___Map_____bra_t)CALL(variable1,COLOR_abstract_collection___Map_____bra))(variable1,  variable0 /*c*/) /*Map::[]*/;
    variable1 = ((static_type___MMAncestor___stype_t)CALL(variable1,COLOR_static_type___MMAncestor___stype))(variable1) /*MMAncestor::stype*/;
    goto return_label2;
  }
  variable1 =  NIT_NULL /*null*/;
  goto return_label2;
  return_label2: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMLocalProperty___signature(val_t  self) {
  struct trace_t trace = {NULL, NULL, 57, LOCATE_static_type___MMLocalProperty___signature};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMLocalProperty____signature( self) /*MMLocalProperty::_signature*/;
}
void static_type___MMLocalProperty___signature__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 57, LOCATE_static_type___MMLocalProperty___signature__eq};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  ATTR_static_type___MMLocalProperty____signature( self) /*MMLocalProperty::_signature*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t static_type___MMLocalProperty___signature_for(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 62, LOCATE_static_type___MMLocalProperty___signature_for};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = ((abstractmetamodel___MMLocalProperty___local_class_t)CALL( self,COLOR_abstractmetamodel___MMLocalProperty___local_class))( self) /*MMLocalProperty::local_class*/;
  variable1 = ((static_type___MMLocalClass___get_type_t)CALL(variable1,COLOR_static_type___MMLocalClass___get_type))(variable1) /*MMLocalClass::get_type*/;
  variable1 = TAG_Bool(( variable0 /*t*/ == variable1) || (( variable0 /*t*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*t*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*t*/,variable1)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*t*/,COLOR_kernel___Object_____eqeq))( variable0 /*t*/, variable1) /*Object::==*/)))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = ((static_type___MMLocalProperty___signature_t)CALL( self,COLOR_static_type___MMLocalProperty___signature))( self) /*MMLocalProperty::signature*/;
    goto return_label3;
  }
  variable1 = ATTR_static_type___MMLocalProperty____signatures_cache( self) /*MMLocalProperty::_signatures_cache*/;
  variable1 = ((abstract_collection___CoupleMap___has_key_t)CALL(variable1,COLOR_abstract_collection___Map___has_key))(variable1,  variable0 /*t*/) /*CoupleMap::has_key*/;
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = ATTR_static_type___MMLocalProperty____signatures_cache( self) /*MMLocalProperty::_signatures_cache*/;
    variable1 = ((abstract_collection___CoupleMap_____bra_t)CALL(variable1,COLOR_abstract_collection___Map_____bra))(variable1,  variable0 /*t*/) /*CoupleMap::[]*/;
    goto return_label3;
  }
  variable2 = ((static_type___MMLocalProperty___signature_t)CALL( self,COLOR_static_type___MMLocalProperty___signature))( self) /*MMLocalProperty::signature*/;
  variable2 = ((static_type___MMSignature___adaptation_to_t)CALL(variable2,COLOR_static_type___MMSignature___adaptation_to))(variable2,  variable0 /*t*/) /*MMSignature::adaptation_to*/;
  variable1 = variable2;
  variable2 = ATTR_static_type___MMLocalProperty____signatures_cache( self) /*MMLocalProperty::_signatures_cache*/;
  ((hash___HashMap_____braeq_t)CALL(variable2,COLOR_abstract_collection___Map_____braeq))(variable2,  variable0 /*t*/,  variable1 /*res*/) /*HashMap::[]=*/;
  variable1 =  variable1 /*res*/;
  goto return_label3;
  return_label3: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMSignature___recv(val_t  self) {
  struct trace_t trace = {NULL, NULL, 76, LOCATE_static_type___MMSignature___recv};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMSignature____recv( self) /*MMSignature::_recv*/;
}
val_t static_type___MMSignature___return_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 82, LOCATE_static_type___MMSignature___return_type};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMSignature____return_type( self) /*MMSignature::_return_type*/;
}
val_t static_type___MMSignature___arity(val_t  self) {
  struct trace_t trace = {NULL, NULL, 85, LOCATE_static_type___MMSignature___arity};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
  variable0 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable0 ==  NIT_NULL /*null*/) || ((variable0 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable0, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))(variable0,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable0)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMSignature___arity, LOCATE_static_type, 88); nit_exit(1);}
  variable0 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
  variable0 = ((array___AbstractArray___length_t)CALL(variable0,COLOR_abstract_collection___Collection___length))(variable0) /*AbstractArray::length*/;
  goto return_label4;
  return_label4: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMSignature_____l(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 92, LOCATE_static_type___MMSignature_____l};
  val_t variable0;
  val_t variable1;
  val_t variable2;
    val_t variable3;
    val_t variable4;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*s*/ ==  NIT_NULL /*null*/) || (( variable0 /*s*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*s*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*s*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*s*/,COLOR_kernel___Object_____eqeq))( variable0 /*s*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable1)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMSignature_____l, LOCATE_static_type, 95); nit_exit(1);}
  variable1 = TAG_Bool(( self ==  variable0 /*s*/) || (( self != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( self,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( self, variable0 /*s*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( self,COLOR_kernel___Object_____eqeq))( self,  variable0 /*s*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  TAG_Bool(true);
    goto return_label5;
  }
  variable1 = ATTR_static_type___MMSignature____recv( self) /*MMSignature::_recv*/;
  variable1 = ((static_type___MMType___module_t)CALL(variable1,COLOR_static_type___MMType___module))(variable1) /*MMType::module*/;
  variable2 = ((static_type___MMSignature___recv_t)CALL( variable0 /*s*/,COLOR_static_type___MMSignature___recv))( variable0 /*s*/) /*MMSignature::recv*/;
  variable2 = ((static_type___MMType___module_t)CALL(variable2,COLOR_static_type___MMType___module))(variable2) /*MMType::module*/;
  variable1 = TAG_Bool((variable1 == variable2) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1,variable2)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1, variable2) /*Object::==*/)))));
  if (!UNTAG_Bool(variable1)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMSignature_____l, LOCATE_static_type, 99); nit_exit(1);}
  variable1 = ((static_type___MMSignature___arity_t)CALL( self,COLOR_static_type___MMSignature___arity))( self) /*MMSignature::arity*/;
  variable2 = ((static_type___MMSignature___arity_t)CALL( variable0 /*s*/,COLOR_static_type___MMSignature___arity))( variable0 /*s*/) /*MMSignature::arity*/;
  variable1 = TAG_Bool((variable1)!=(variable2));
  variable2 = variable1;
  if (!UNTAG_Bool(variable2)) { /* or */
    variable2 = ATTR_static_type___MMSignature____return_type( self) /*MMSignature::_return_type*/;
    variable2 = TAG_Bool((variable2 ==  NIT_NULL /*null*/) || ((variable2 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable2, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))(variable2,  NIT_NULL /*null*/) /*Object::==*/)))));
    variable3 = ((static_type___MMSignature___return_type_t)CALL( variable0 /*s*/,COLOR_static_type___MMSignature___return_type))( variable0 /*s*/) /*MMSignature::return_type*/;
    variable3 = TAG_Bool((variable3 ==  NIT_NULL /*null*/) || ((variable3 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable3,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable3, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable3,COLOR_kernel___Object_____eqeq))(variable3,  NIT_NULL /*null*/) /*Object::==*/)))));
    variable2 = TAG_Bool((variable2)!=(variable3));
  }
  variable1 = variable2;
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  TAG_Bool(false);
    goto return_label5;
  }
  variable1 = ATTR_static_type___MMSignature____return_type( self) /*MMSignature::_return_type*/;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Object::==*/)))))));
  variable2 = variable1;
  if (UNTAG_Bool(variable2)) { /* and */
    variable2 = ATTR_static_type___MMSignature____return_type( self) /*MMSignature::_return_type*/;
    variable3 = ((static_type___MMSignature___return_type_t)CALL( variable0 /*s*/,COLOR_static_type___MMSignature___return_type))( variable0 /*s*/) /*MMSignature::return_type*/;
    variable2 = ((static_type___MMType_____l_t)CALL(variable2,COLOR_static_type___MMType_____l))(variable2, variable3) /*MMType::<*/;
    variable2 =  TAG_Bool(!UNTAG_Bool(variable2));
  }
  variable1 = variable2;
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  TAG_Bool(false);
    goto return_label5;
  }
  variable1 = ((static_type___MMSignature___arity_t)CALL( self,COLOR_static_type___MMSignature___arity))( self) /*MMSignature::arity*/;
  variable2 = NEW_range___Range___without_last( TAG_Int(0), variable1); /*new Range[E]*/
  variable1 = variable2;
  variable1 = ((range___Range___iterator_t)CALL(variable1,COLOR_abstract_collection___Collection___iterator))(variable1) /*Range::iterator*/;
  while (true) { /*for*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /*for*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
    variable3 = ((static_type___MMSignature_____bra_t)CALL( variable0 /*s*/,COLOR_static_type___MMSignature_____bra))( variable0 /*s*/,  variable2 /*i*/) /*MMSignature::[]*/;
    variable4 = ((static_type___MMSignature_____bra_t)CALL( self,COLOR_static_type___MMSignature_____bra))( self,  variable2 /*i*/) /*MMSignature::[]*/;
    variable3 = ((static_type___MMType_____l_t)CALL(variable3,COLOR_static_type___MMType_____l))(variable3, variable4) /*MMType::<*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable3)))) { /*if*/
      variable1 =  TAG_Bool(false);
      goto return_label5;
    }
    continue_6: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
  }
  break_6: while(0);
  variable1 =  TAG_Bool(true);
  goto return_label5;
  return_label5: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMSignature_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 113, LOCATE_static_type___MMSignature_____bra};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  val_t variable3;
  val_t variable4;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
  variable1 = ((array___AbstractArray___length_t)CALL(variable1,COLOR_abstract_collection___Collection___length))(variable1) /*AbstractArray::length*/;
  variable1 = TAG_Bool(UNTAG_Int(variable1)>UNTAG_Int( variable0 /*i*/));
  if (!UNTAG_Bool(variable1)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMSignature_____bra, LOCATE_static_type, 116); nit_exit(1);}
  variable1 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
  variable2 =  variable0 /*i*/;
  variable3 = TAG_Bool(UNTAG_Int( variable2 /*index*/)>=UNTAG_Int( TAG_Int(0)));
  variable4 = variable3;
  if (UNTAG_Bool(variable4)) { /* and */
    variable4 = variable1;
    variable4 = ATTR_array___AbstractArray____length(variable4) /*AbstractArray::_length*/;
    variable4 = TAG_Bool(UNTAG_Int( variable2 /*index*/)<UNTAG_Int(variable4));
  }
  variable3 = variable4;
  if (!UNTAG_Bool(variable3)) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_static_type, 229); nit_exit(1);}
  variable3 = variable1;
  variable3 = ATTR_array___Array____items(variable3) /*Array::_items*/;
  variable3 = UNBOX_NativeArray(variable3)[UNTAG_Int( variable2 /*index*/)];
  goto return_label8;
  return_label8: while(false);
  variable1 = variable3;
  goto return_label7;
  return_label7: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMSignature___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 120, LOCATE_static_type___MMSignature___to_s};
  val_t variable0;
  val_t variable1;
  val_t variable2;
    val_t variable3;
    val_t variable4;
      val_t variable5;
      val_t variable6;
      val_t variable7;
      val_t variable8;
      val_t variable9;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 = NIT_NULL /*decl variable s*/;
  variable1 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Object::==*/)))))));
  variable2 = variable1;
  if (UNTAG_Bool(variable2)) { /* and */
    variable2 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
    variable2 = ((array___AbstractArray___length_t)CALL(variable2,COLOR_abstract_collection___Collection___length))(variable2) /*AbstractArray::length*/;
    variable2 = TAG_Bool(UNTAG_Int(variable2)>UNTAG_Int( TAG_Int(0)));
  }
  variable1 = variable2;
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = NIT_NULL /*decl variable tmp*/;
    variable3 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
    variable3 = ((array___AbstractArray___length_t)CALL(variable3,COLOR_abstract_collection___Collection___length))(variable3) /*AbstractArray::length*/;
    variable4 = NEW_array___Array___with_capacity(variable3); /*new Array[E]*/
    variable3 = variable4;
    variable2 = variable3;
    variable3 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
    variable3 = ((array___AbstractArray___length_t)CALL(variable3,COLOR_abstract_collection___Collection___length))(variable3) /*AbstractArray::length*/;
    variable4 = NEW_range___Range___without_last( TAG_Int(0), variable3); /*new Range[E]*/
    variable3 = variable4;
    variable3 = ((range___Range___iterator_t)CALL(variable3,COLOR_abstract_collection___Collection___iterator))(variable3) /*Range::iterator*/;
    while (true) { /*for*/
      variable4 = ((abstract_collection___Iterator___is_ok_t)CALL(variable3,COLOR_abstract_collection___Iterator___is_ok))(variable3) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable4)) break; /*for*/
      variable4 = ((abstract_collection___Iterator___item_t)CALL(variable3,COLOR_abstract_collection___Iterator___item))(variable3) /*Iterator::item*/;
      variable6 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
      variable7 =  variable4 /*i*/;
      variable8 = TAG_Bool(UNTAG_Int( variable7 /*index*/)>=UNTAG_Int( TAG_Int(0)));
      variable9 = variable8;
      if (UNTAG_Bool(variable9)) { /* and */
        variable9 = variable6;
        variable9 = ATTR_array___AbstractArray____length(variable9) /*AbstractArray::_length*/;
        variable9 = TAG_Bool(UNTAG_Int( variable7 /*index*/)<UNTAG_Int(variable9));
      }
      variable8 = variable9;
      if (!UNTAG_Bool(variable8)) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_static_type, 229); nit_exit(1);}
      variable8 = variable6;
      variable8 = ATTR_array___Array____items(variable8) /*Array::_items*/;
      variable8 = UNBOX_NativeArray(variable8)[UNTAG_Int( variable7 /*index*/)];
      goto return_label11;
      return_label11: while(false);
      variable6 = variable8;
      variable5 = variable6;
      variable6 = ((string___Object___to_s_t)CALL( variable5 /*p*/,COLOR_string___Object___to_s))( variable5 /*p*/) /*Object::to_s*/;
      ((array___AbstractArray___add_t)CALL( variable2 /*a*/,COLOR_abstract_collection___SimpleCollection___add))( variable2 /*a*/, variable6) /*AbstractArray::add*/;
      continue_10: while(0);
      ((abstract_collection___Iterator___next_t)CALL(variable3,COLOR_abstract_collection___Iterator___next))(variable3) /*Iterator::next*/;
    }
    break_10: while(0);
    variable3 = NEW_string___String___init(); /*new String*/
    variable4 = NEW_string___String___with_native(BOX_NativeString("("), TAG_Int(1)); /*new String*/
    variable5 = variable4;
    ((string___String___append_t)CALL(variable3,COLOR_abstract_collection___IndexedCollection___append))(variable3, variable5) /*String::append*/;
    variable6 = NEW_string___String___with_native(BOX_NativeString(","), TAG_Int(1)); /*new String*/
    variable6 = ((string___Collection___join_t)CALL( variable2 /*a*/,COLOR_string___Collection___join))( variable2 /*a*/, variable6) /*Collection::join*/;
    variable7 = variable6;
    ((string___String___append_t)CALL(variable3,COLOR_abstract_collection___IndexedCollection___append))(variable3, variable7) /*String::append*/;
    variable8 = NEW_string___String___with_native(BOX_NativeString(")"), TAG_Int(1)); /*new String*/
    variable9 = variable8;
    ((string___String___append_t)CALL(variable3,COLOR_abstract_collection___IndexedCollection___append))(variable3, variable9) /*String::append*/;
    variable0 = variable3 /*s=*/;
  } else { /*if*/
    variable1 = NEW_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable0 = variable1 /*s=*/;
  }
  variable1 = ATTR_static_type___MMSignature____return_type( self) /*MMSignature::_return_type*/;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = NEW_string___String___init(); /*new String*/
    variable2 = NEW_string___String___with_native(BOX_NativeString(": "), TAG_Int(2)); /*new String*/
    variable3 = variable2;
    ((string___String___append_t)CALL(variable1,COLOR_abstract_collection___IndexedCollection___append))(variable1, variable3) /*String::append*/;
    variable4 = ATTR_static_type___MMSignature____return_type( self) /*MMSignature::_return_type*/;
    variable5 = variable4;
    variable5 = ((string___String___to_s_t)CALL(variable5,COLOR_string___Object___to_s))(variable5) /*String::to_s*/;
    ((string___String___append_t)CALL(variable1,COLOR_abstract_collection___IndexedCollection___append))(variable1, variable5) /*String::append*/;
    variable6 = NEW_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable7 = variable6;
    ((string___String___append_t)CALL(variable1,COLOR_abstract_collection___IndexedCollection___append))(variable1, variable7) /*String::append*/;
    ((string___String___append_t)CALL( variable0 /*s*/,COLOR_abstract_collection___IndexedCollection___append))( variable0 /*s*/, variable1) /*String::append*/;
  }
  variable0 =  variable0 /*s*/;
  goto return_label9;
  return_label9: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMSignature___adaptation_to(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 142, LOCATE_static_type___MMSignature___adaptation_to};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  val_t variable3;
      val_t variable4;
      val_t variable5;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = ATTR_static_type___MMSignature____recv( self) /*MMSignature::_recv*/;
  variable1 = TAG_Bool((variable1 ==  variable0 /*r*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, variable0 /*r*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  variable0 /*r*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  self;
    goto return_label12;
  }
  variable2 = ((static_type___MMType___module_t)CALL( variable0 /*r*/,COLOR_static_type___MMType___module))( variable0 /*r*/) /*MMType::module*/;
  variable1 = variable2;
  variable3 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
  variable2 = variable3;
  variable3 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable2 /*p*/ ==  NIT_NULL /*null*/) || (( variable2 /*p*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable2 /*p*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable2 /*p*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable2 /*p*/,COLOR_kernel___Object_____eqeq))( variable2 /*p*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable3)) { /*if*/
    variable3 = NEW_array___Array___init(); /*new Array[E]*/
    variable2 = variable3 /*p=*/;
    variable3 = ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/;
    variable3 = ((array___AbstractArray___iterator_t)CALL(variable3,COLOR_abstract_collection___Collection___iterator))(variable3) /*AbstractArray::iterator*/;
    while (true) { /*for*/
      variable4 = ((array___ArrayIterator___is_ok_t)CALL(variable3,COLOR_abstract_collection___Iterator___is_ok))(variable3) /*ArrayIterator::is_ok*/;
      if (!UNTAG_Bool(variable4)) break; /*for*/
      variable4 = ((array___ArrayIterator___item_t)CALL(variable3,COLOR_abstract_collection___Iterator___item))(variable3) /*ArrayIterator::item*/;
      variable5 = ((static_type___MMType___for_module_t)CALL( variable4 /*i*/,COLOR_static_type___MMType___for_module))( variable4 /*i*/,  variable1 /*mod*/) /*MMType::for_module*/;
      variable5 = ((static_type___MMType___adapt_to_t)CALL(variable5,COLOR_static_type___MMType___adapt_to))(variable5,  variable0 /*r*/) /*MMType::adapt_to*/;
      ((array___AbstractArray___add_t)CALL( variable2 /*p*/,COLOR_abstract_collection___SimpleCollection___add))( variable2 /*p*/, variable5) /*AbstractArray::add*/;
      continue_13: while(0);
      ((array___ArrayIterator___next_t)CALL(variable3,COLOR_abstract_collection___Iterator___next))(variable3) /*ArrayIterator::next*/;
    }
    break_13: while(0);
  }
  variable4 = ATTR_static_type___MMSignature____return_type( self) /*MMSignature::_return_type*/;
  variable3 = variable4;
  variable4 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable3 /*rv*/ ==  NIT_NULL /*null*/) || (( variable3 /*rv*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable3 /*rv*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable3 /*rv*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable3 /*rv*/,COLOR_kernel___Object_____eqeq))( variable3 /*rv*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable4)) { /*if*/
    variable4 = ((static_type___MMType___for_module_t)CALL( variable3 /*rv*/,COLOR_static_type___MMType___for_module))( variable3 /*rv*/,  variable1 /*mod*/) /*MMType::for_module*/;
    variable4 = ((static_type___MMType___adapt_to_t)CALL(variable4,COLOR_static_type___MMType___adapt_to))(variable4,  variable0 /*r*/) /*MMType::adapt_to*/;
    variable3 = variable4 /*rv=*/;
  }
  variable4 = NEW_static_type___MMSignature___init( variable2 /*p*/,  variable3 /*rv*/,  variable0 /*r*/); /*new MMSignature*/
  variable1 = variable4;
  goto return_label12;
  return_label12: while(false);
  tracehead = trace.prev;
  return variable1;
}
void static_type___MMSignature___init(val_t  self, val_t  param0, val_t  param1, val_t  param2, int* init_table) {
  struct trace_t trace = {NULL, NULL, 163, LOCATE_static_type___MMSignature___init};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 =  param1;
  variable2 =  param2;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMSignature].i]) return;
  variable3 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*params*/ ==  NIT_NULL /*null*/) || (( variable0 /*params*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*params*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*params*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*params*/,COLOR_kernel___Object_____eqeq))( variable0 /*params*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable3)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMSignature___init, LOCATE_static_type, 165); nit_exit(1);}
  ATTR_static_type___MMSignature____params( self) /*MMSignature::_params*/ =  variable0 /*params*/;
  ATTR_static_type___MMSignature____return_type( self) /*MMSignature::_return_type*/ =  variable1 /*return_type*/;
  ATTR_static_type___MMSignature____recv( self) /*MMSignature::_recv*/ =  variable2 /*r*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMSignature].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t static_type___MMAncestor___stype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 174, LOCATE_static_type___MMAncestor___stype};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMAncestor____stype( self) /*MMAncestor::_stype*/;
}
void static_type___MMAncestor___stype__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 174, LOCATE_static_type___MMAncestor___stype__eq};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  ATTR_static_type___MMAncestor____stype( self) /*MMAncestor::_stype*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t static_type___MMAncestor___inheriter(val_t  self) {
  struct trace_t trace = {NULL, NULL, 177, LOCATE_static_type___MMAncestor___inheriter};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMAncestor____inheriter( self) /*MMAncestor::_inheriter*/;
}
void static_type___MMAncestor___inheriter__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 177, LOCATE_static_type___MMAncestor___inheriter__eq};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  ATTR_static_type___MMAncestor____inheriter( self) /*MMAncestor::_inheriter*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t static_type___MMAncestor___is_reffinement(val_t  self) {
  struct trace_t trace = {NULL, NULL, 180, LOCATE_static_type___MMAncestor___is_reffinement};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 = ((static_type___MMAncestor___stype_t)CALL( self,COLOR_static_type___MMAncestor___stype))( self) /*MMAncestor::stype*/;
  variable0 = ((static_type___MMType___module_t)CALL(variable0,COLOR_static_type___MMType___module))(variable0) /*MMType::module*/;
  variable1 = ((static_type___MMAncestor___stype_t)CALL( self,COLOR_static_type___MMAncestor___stype))( self) /*MMAncestor::stype*/;
  variable1 = ((static_type___MMType___module_t)CALL(variable1,COLOR_static_type___MMType___module))(variable1) /*MMType::module*/;
  variable0 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable0 == variable1) || ((variable0 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable0,variable1)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))(variable0, variable1) /*Object::==*/)))))));
  goto return_label15;
  return_label15: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMAncestor___is_specialisation(val_t  self) {
  struct trace_t trace = {NULL, NULL, 184, LOCATE_static_type___MMAncestor___is_specialisation};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 = ((static_type___MMAncestor___stype_t)CALL( self,COLOR_static_type___MMAncestor___stype))( self) /*MMAncestor::stype*/;
  variable0 = ((static_type___MMType___local_class_t)CALL(variable0,COLOR_static_type___MMType___local_class))(variable0) /*MMType::local_class*/;
  variable0 = ((abstractmetamodel___MMLocalClass___global_t)CALL(variable0,COLOR_abstractmetamodel___MMLocalClass___global))(variable0) /*MMLocalClass::global*/;
  variable1 = ((static_type___MMAncestor___inheriter_t)CALL( self,COLOR_static_type___MMAncestor___inheriter))( self) /*MMAncestor::inheriter*/;
  variable1 = ((static_type___MMType___local_class_t)CALL(variable1,COLOR_static_type___MMType___local_class))(variable1) /*MMType::local_class*/;
  variable1 = ((abstractmetamodel___MMLocalClass___global_t)CALL(variable1,COLOR_abstractmetamodel___MMLocalClass___global))(variable1) /*MMLocalClass::global*/;
  variable0 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable0 == variable1) || ((variable0 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable0,variable1)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))(variable0, variable1) /*Object::==*/)))))));
  goto return_label16;
  return_label16: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMAncestor___local_class(val_t  self) {
  struct trace_t trace = {NULL, NULL, 188, LOCATE_static_type___MMAncestor___local_class};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMAncestor___is_specialisation, LOCATE_static_type, 188);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t static_type___MMAncestor___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 191, LOCATE_static_type___MMAncestor___to_s};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 = ((static_type___MMAncestor___stype_t)CALL( self,COLOR_static_type___MMAncestor___stype))( self) /*MMAncestor::stype*/;
  variable0 = TAG_Bool((variable0 ==  NIT_NULL /*null*/) || ((variable0 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable0, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable0,COLOR_kernel___Object_____eqeq))(variable0,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable0)) { /*if*/
    variable0 = ((static_type___MMAncestor___local_class_t)CALL( self,COLOR_static_type___MMAncestor___local_class))( self) /*MMAncestor::local_class*/;
    variable0 = ((abstractmetamodel___MMLocalClass___to_s_t)CALL(variable0,COLOR_string___Object___to_s))(variable0) /*MMLocalClass::to_s*/;
    goto return_label17;
  } else { /*if*/
    variable0 = ((static_type___MMAncestor___stype_t)CALL( self,COLOR_static_type___MMAncestor___stype))( self) /*MMAncestor::stype*/;
    variable0 = ((string___Object___to_s_t)CALL(variable0,COLOR_string___Object___to_s))(variable0) /*Object::to_s*/;
    goto return_label17;
  }
  return_label17: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMType___module(val_t  self) {
  struct trace_t trace = {NULL, NULL, 204, LOCATE_static_type___MMType___module};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMAncestor___to_s, LOCATE_static_type, 204);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t static_type___MMType___local_class(val_t  self) {
  struct trace_t trace = {NULL, NULL, 207, LOCATE_static_type___MMType___local_class};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMAncestor___to_s, LOCATE_static_type, 207);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t static_type___MMType_____l(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 210, LOCATE_static_type___MMType_____l};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMAncestor___to_s, LOCATE_static_type, 210);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t static_type___MMType___is_supertype(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 213, LOCATE_static_type___MMType___is_supertype};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMAncestor___to_s, LOCATE_static_type, 213);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t static_type___MMType___for_module(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 218, LOCATE_static_type___MMType___for_module};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMAncestor___to_s, LOCATE_static_type, 218);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t static_type___MMType___adapt_to(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 221, LOCATE_static_type___MMType___adapt_to};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMAncestor___to_s, LOCATE_static_type, 221);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t static_type___MMType___upcast_for(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 225, LOCATE_static_type___MMType___upcast_for};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMAncestor___to_s, LOCATE_static_type, 225);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t static_type___MMType___not_for_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 229, LOCATE_static_type___MMType___not_for_self};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  self;
  goto return_label18;
  return_label18: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMTypeClass___local_class(val_t  self) {
  struct trace_t trace = {NULL, NULL, 236, LOCATE_static_type___MMTypeClass___local_class};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/;
}
val_t static_type___MMTypeClass___module(val_t  self) {
  struct trace_t trace = {NULL, NULL, 237, LOCATE_static_type___MMTypeClass___module};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 = ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/;
  variable0 = ((abstractmetamodel___MMLocalClass___module_t)CALL(variable0,COLOR_abstractmetamodel___MMLocalClass___module))(variable0) /*MMLocalClass::module*/;
  goto return_label19;
  return_label19: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMTypeClass_____l(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 238, LOCATE_static_type___MMTypeClass_____l};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*t*/ ==  NIT_NULL /*null*/) || (( variable0 /*t*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*t*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*t*/,COLOR_kernel___Object_____eqeq))( variable0 /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  variable2 = variable1;
  if (UNTAG_Bool(variable2)) { /* and */
    variable2 = ((static_type___MMType___is_supertype_t)CALL( variable0 /*t*/,COLOR_static_type___MMType___is_supertype))( variable0 /*t*/,  self) /*MMType::is_supertype*/;
  }
  variable1 = variable2;
  goto return_label20;
  return_label20: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMTypeClass___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 240, LOCATE_static_type___MMTypeClass___to_s};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 = ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/;
  variable0 = ((abstractmetamodel___MMLocalClass___to_s_t)CALL(variable0,COLOR_string___Object___to_s))(variable0) /*MMLocalClass::to_s*/;
  goto return_label21;
  return_label21: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMTypeClass___upcast_for(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 245, LOCATE_static_type___MMTypeClass___upcast_for};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable1)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMTypeClass___upcast_for, LOCATE_static_type, 247); nit_exit(1);}
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*c*/ ==  NIT_NULL /*null*/) || (( variable0 /*c*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*c*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*c*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*c*/,COLOR_kernel___Object_____eqeq))( variable0 /*c*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable1)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMTypeClass___upcast_for, LOCATE_static_type, 248); nit_exit(1);}
  variable1 =  self;
  variable2 = ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/;
  variable2 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable2 ==  variable0 /*c*/) || ((variable2 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable2, variable0 /*c*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))(variable2,  variable0 /*c*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable2 = ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/;
    variable2 = ((static_type___MMLocalClass___ancestor_t)CALL(variable2,COLOR_static_type___MMLocalClass___ancestor))(variable2,  variable0 /*c*/) /*MMLocalClass::ancestor*/;
    variable1 = variable2 /*t=*/;
  }
  variable2 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable1 /*t*/ ==  NIT_NULL /*null*/) || (( variable1 /*t*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable1 /*t*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable1 /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable1 /*t*/,COLOR_kernel___Object_____eqeq))( variable1 /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable2)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMTypeClass___upcast_for, LOCATE_static_type, 254); nit_exit(1);}
  variable1 =  variable1 /*t*/;
  goto return_label22;
  return_label22: while(false);
  tracehead = trace.prev;
  return variable1;
}
void static_type___MMTypeClass___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 258, LOCATE_static_type___MMTypeClass___init};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMTypeClass].i]) return;
  ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/ =  variable0 /*c*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMTypeClass].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t static_type___MMTypeSimpleClass___is_supertype(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 266, LOCATE_static_type___MMTypeSimpleClass___is_supertype};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 = ((static_type___MMType___local_class_t)CALL( variable0 /*t*/,COLOR_static_type___MMType___local_class))( variable0 /*t*/) /*MMType::local_class*/;
  variable1 = ((abstractmetamodel___MMLocalClass___cshe_t)CALL(variable1,COLOR_abstractmetamodel___MMLocalClass___cshe))(variable1) /*MMLocalClass::cshe*/;
  variable2 = ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/;
  variable1 = ((partial_order___PartialOrderElement_____leq_t)CALL(variable1,COLOR_partial_order___PartialOrderElement_____leq))(variable1, variable2) /*PartialOrderElement::<=*/;
  goto return_label24;
  return_label24: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMTypeSimpleClass___for_module(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 271, LOCATE_static_type___MMTypeSimpleClass___for_module};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 =  self;
  variable2 = ((static_type___MMTypeClass___module_t)CALL( self,COLOR_static_type___MMType___module))( self) /*MMTypeClass::module*/;
  variable2 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable2 ==  variable0 /*mod*/) || ((variable2 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable2, variable0 /*mod*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))(variable2,  variable0 /*mod*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable2 = ATTR_static_type___MMTypeClass____local_class( self) /*MMTypeClass::_local_class*/;
    variable2 = ((abstractmetamodel___MMLocalClass___for_module_t)CALL(variable2,COLOR_abstractmetamodel___MMLocalClass___for_module))(variable2,  variable0 /*mod*/) /*MMLocalClass::for_module*/;
    variable2 = ((static_type___MMLocalClass___get_type_t)CALL(variable2,COLOR_static_type___MMLocalClass___get_type))(variable2) /*MMLocalClass::get_type*/;
    variable1 = variable2 /*t=*/;
  }
  variable2 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable1 /*t*/ ==  NIT_NULL /*null*/) || (( variable1 /*t*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable1 /*t*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable1 /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable1 /*t*/,COLOR_kernel___Object_____eqeq))( variable1 /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable2)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMTypeSimpleClass___for_module, LOCATE_static_type, 277); nit_exit(1);}
  variable1 =  variable1 /*t*/;
  goto return_label25;
  return_label25: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMTypeSimpleClass___adapt_to(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 281, LOCATE_static_type___MMTypeSimpleClass___adapt_to};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 =  self;
  goto return_label26;
  return_label26: while(false);
  tracehead = trace.prev;
  return variable1;
}
void static_type___MMTypeSimpleClass___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 283, LOCATE_static_type___MMTypeSimpleClass___init};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMTypeSimpleClass].i]) return;
  ((static_type___MMTypeClass___init_t)CALL( self,COLOR_static_type___MMTypeClass___init))( self,  variable0 /*c*/, init_table /*YYY*/) /*MMTypeClass::init*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMTypeSimpleClass].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t static_type___MMTypeNone___module(val_t  self) {
  struct trace_t trace = {NULL, NULL, 292, LOCATE_static_type___MMTypeNone___module};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMTypeNone____module( self) /*MMTypeNone::_module*/;
}
val_t static_type___MMTypeNone_____l(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 293, LOCATE_static_type___MMTypeNone_____l};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 =  TAG_Bool(true);
  goto return_label28;
  return_label28: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMTypeNone___is_supertype(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 294, LOCATE_static_type___MMTypeNone___is_supertype};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 =  TAG_Bool(false);
  goto return_label29;
  return_label29: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t static_type___MMTypeNone___local_class(val_t  self) {
  struct trace_t trace = {NULL, NULL, 295, LOCATE_static_type___MMTypeNone___local_class};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  fprintf(stderr, "Aborted"); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_static_type___MMTypeNone___local_class, LOCATE_static_type, 295); nit_exit(1);
  tracehead = trace.prev;
  return variable0;
}
val_t static_type___MMTypeNone___upcast_for(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 296, LOCATE_static_type___MMTypeNone___upcast_for};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  variable1 =  self;
  goto return_label31;
  return_label31: while(false);
  tracehead = trace.prev;
  return variable1;
}
void static_type___MMTypeNone___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 298, LOCATE_static_type___MMTypeNone___init};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMTypeNone].i]) return;
  ATTR_static_type___MMTypeNone____module( self) /*MMTypeNone::_module*/ =  variable0 /*m*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMTypeNone].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t static_type___MMModule___type_none(val_t  self) {
  struct trace_t trace = {NULL, NULL, 302, LOCATE_static_type___MMModule___type_none};
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_static_type;
  tracehead = trace.prev;
  return ATTR_static_type___MMModule____type_none( self) /*MMModule::_type_none*/;
}
