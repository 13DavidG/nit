/* This C file is generated by NIT to compile module typing. */
#include "typing._sep.h"
void typing___MMSrcModule___do_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 23, LOCATE_typing___MMSrcModule___do_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[5] = NEW_TypingVisitor_typing___TypingVisitor___init( variable[1] /*tc*/, variable[4]); /*new TypingVisitor*/
  variable[4] = variable[5];
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = CALL_syntax_base___MMSrcModule___node(variable[4])(variable[4]) /*MMSrcModule::node*/;
  CALL_parser_prod___Visitor___visit( variable[3] /*tv*/)( variable[3] /*tv*/, variable[4]) /*TypingVisitor::visit*/;
  return_label0: while(false);
  tracehead = trace.prev;
  return;
}
void typing___TypingVisitor___visit(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 39, LOCATE_typing___TypingVisitor___visit};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[1] /*n*/ ==  NIT_NULL /*null*/) || (( variable[1] /*n*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[1] /*n*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[1] /*n*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[1] /*n*/)( variable[1] /*n*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    CALL_typing___PNode___accept_typing( variable[1] /*n*/)( variable[1] /*n*/, variable[3]) /*PNode::accept_typing*/;
  }
  return_label1: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___variable_ctx(val_t  self) {
  struct trace_t trace = {NULL, NULL, 44, LOCATE_typing___TypingVisitor___variable_ctx};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____variable_ctx( self) /*TypingVisitor::_variable_ctx*/;
}
void typing___TypingVisitor___variable_ctx__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 44, LOCATE_typing___TypingVisitor___variable_ctx__eq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____variable_ctx( self) /*TypingVisitor::_variable_ctx*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___self_var(val_t  self) {
  struct trace_t trace = {NULL, NULL, 47, LOCATE_typing___TypingVisitor___self_var};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____self_var( self) /*TypingVisitor::_self_var*/;
}
void typing___TypingVisitor___self_var__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 47, LOCATE_typing___TypingVisitor___self_var__eq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____self_var( self) /*TypingVisitor::_self_var*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___top_block(val_t  self) {
  struct trace_t trace = {NULL, NULL, 50, LOCATE_typing___TypingVisitor___top_block};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____top_block( self) /*TypingVisitor::_top_block*/;
}
void typing___TypingVisitor___top_block__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 50, LOCATE_typing___TypingVisitor___top_block__eq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____top_block( self) /*TypingVisitor::_top_block*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___closure(val_t  self) {
  struct trace_t trace = {NULL, NULL, 53, LOCATE_typing___TypingVisitor___closure};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____closure( self) /*TypingVisitor::_closure*/;
}
void typing___TypingVisitor___closure__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 53, LOCATE_typing___TypingVisitor___closure__eq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____closure( self) /*TypingVisitor::_closure*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___closure_break_stype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 56, LOCATE_typing___TypingVisitor___closure_break_stype};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____closure_break_stype( self) /*TypingVisitor::_closure_break_stype*/;
}
void typing___TypingVisitor___closure_break_stype__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 56, LOCATE_typing___TypingVisitor___closure_break_stype__eq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____closure_break_stype( self) /*TypingVisitor::_closure_break_stype*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___break_list(val_t  self) {
  struct trace_t trace = {NULL, NULL, 59, LOCATE_typing___TypingVisitor___break_list};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____break_list( self) /*TypingVisitor::_break_list*/;
}
void typing___TypingVisitor___break_list__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 59, LOCATE_typing___TypingVisitor___break_list__eq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____break_list( self) /*TypingVisitor::_break_list*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___explicit_super_init_calls(val_t  self) {
  struct trace_t trace = {NULL, NULL, 62, LOCATE_typing___TypingVisitor___explicit_super_init_calls};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____explicit_super_init_calls( self) /*TypingVisitor::_explicit_super_init_calls*/;
}
void typing___TypingVisitor___explicit_super_init_calls__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 62, LOCATE_typing___TypingVisitor___explicit_super_init_calls__eq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____explicit_super_init_calls( self) /*TypingVisitor::_explicit_super_init_calls*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___explicit_other_init_call(val_t  self) {
  struct trace_t trace = {NULL, NULL, 65, LOCATE_typing___TypingVisitor___explicit_other_init_call};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____explicit_other_init_call( self) /*TypingVisitor::_explicit_other_init_call*/;
}
void typing___TypingVisitor___explicit_other_init_call__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 65, LOCATE_typing___TypingVisitor___explicit_other_init_call__eq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____explicit_other_init_call( self) /*TypingVisitor::_explicit_other_init_call*/ =  param0;
  tracehead = trace.prev;
  return;
}
void typing___TypingVisitor___init(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 68, LOCATE_typing___TypingVisitor___init};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_TypingVisitor].i]) return;
  CALL_syntax_base___AbsSyntaxVisitor___init(variable[0])(variable[0], variable[1], variable[2], init_table /*YYY*/) /*AbsSyntaxVisitor::init*/;
  return_label2: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_TypingVisitor].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___get_default_constructor_for(val_t  self, val_t  param0, val_t  param1, val_t  param2) {
  struct trace_t trace = {NULL, NULL, 70, LOCATE_typing___TypingVisitor___get_default_constructor_for};
        static val_t once_value_5; static int once_bool_5; /* Once value for variable[17]*/
  val_t variable[24];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[6] = variable[0];
  variable[5] = variable[6];
  variable[7] = NEW_Array_array___Array___init(); /*new Array[MMMethod]*/
  variable[6] = variable[7];
  variable[8] = NEW_Array_array___Array___init(); /*new Array[MMMethod]*/
  variable[7] = variable[8];
  variable[9] = CALL_static_type___MMLocalProperty___signature( variable[3] /*prop*/)( variable[3] /*prop*/) /*MMLocalProperty::signature*/;
  variable[9] = CALL_static_type___MMSignature___arity(variable[9])(variable[9]) /*MMSignature::arity*/;
  variable[8] = variable[9];
  variable[9] = CALL_abstractmetamodel___MMLocalClass___global_properties( variable[2] /*c*/)( variable[2] /*c*/) /*MMLocalClass::global_properties*/;
  variable[9] = CALL_abstract_collection___Collection___iterator(variable[9])(variable[9]) /*Collection::iterator*/;
  while (true) { /*for*/
    variable[10] = CALL_abstract_collection___Iterator___is_ok(variable[9])(variable[9]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[10])) break; /*for*/
    variable[10] = CALL_abstract_collection___Iterator___item(variable[9])(variable[9]) /*Iterator::item*/;
    variable[11] = variable[10];
    variable[12] = CALL_abstractmetamodel___MMGlobalProperty___is_init_for( variable[11] /*g*/)( variable[11] /*g*/,  variable[2] /*c*/) /*MMGlobalProperty::is_init_for*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[12])))) { /*if*/
      goto continue_4;
    }
    variable[13] = CALL_abstractmetamodel___MMLocalClass_____bra( variable[2] /*c*/)( variable[2] /*c*/,  variable[11] /*g*/) /*MMLocalClass::[]*/;
    variable[12] = variable[13];
    variable[14] = CALL_static_type___MMLocalClass___get_type( variable[2] /*c*/)( variable[2] /*c*/) /*MMLocalClass::get_type*/;
    variable[14] = CALL_static_type___MMLocalProperty___signature_for( variable[12] /*gp*/)( variable[12] /*gp*/, variable[14]) /*MMLocalProperty::signature_for*/;
    variable[13] = variable[14];
    variable[14] = TAG_Bool(( variable[12] /*gp*/==NIT_NULL) || VAL_ISA( variable[12] /*gp*/, COLOR_MMSrcMethod, ID_MMSrcMethod)) /*cast MMSrcMethod*/;
    if (!UNTAG_Bool(variable[14])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___TypingVisitor___get_default_constructor_for, LOCATE_typing, 82); nit_exit(1);}
    variable[15] = CALL_static_type___MMSignature___arity( variable[13] /*gps*/)( variable[13] /*gps*/) /*MMSignature::arity*/;
    variable[14] = variable[15];
    variable[15] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[3] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*prop*/)( variable[3] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    variable[16] = variable[15];
    if (UNTAG_Bool(variable[16])) { /* and */
      variable[16] = CALL_abstractmetamodel___MMLocalProperty___name( variable[12] /*gp*/)( variable[12] /*gp*/) /*MMLocalProperty::name*/;
      variable[17] = CALL_abstractmetamodel___MMLocalProperty___name( variable[3] /*prop*/)( variable[3] /*prop*/) /*MMLocalProperty::name*/;
      variable[16] = TAG_Bool((variable[16] == variable[17]) || ((variable[16] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[16])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[16],variable[17])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[16])(variable[16], variable[17]) /*Object::==*/)))));
    }
    variable[15] = variable[16];
    if (UNTAG_Bool(variable[15])) { /*if*/
      variable[15] = TAG_Bool(( variable[14] /*garity*/)==( TAG_Int(0)));
      variable[16] = variable[15];
      if (!UNTAG_Bool(variable[16])) { /* or */
        variable[16] = TAG_Bool(( variable[8] /*parity*/)==( variable[14] /*garity*/));
        variable[17] = variable[16];
        if (UNTAG_Bool(variable[17])) { /* and */
          variable[17] = CALL_static_type___MMLocalProperty___signature( variable[3] /*prop*/)( variable[3] /*prop*/) /*MMLocalProperty::signature*/;
          variable[17] = CALL_static_type___MMSignature_____l(variable[17])(variable[17],  variable[13] /*gps*/) /*MMSignature::<*/;
        }
        variable[16] = variable[17];
      }
      variable[15] = variable[16];
      if (UNTAG_Bool(variable[15])) { /*if*/
        variable[4] =  variable[12] /*gp*/;
        goto return_label3;
      } else { /*if*/
        CALL_abstract_collection___SimpleCollection___add( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/,  variable[12] /*gp*/) /*AbstractArray::add*/;
      }
    } else { /*if*/
      variable[15] = TAG_Bool(( variable[14] /*garity*/)==( TAG_Int(0)));
      variable[16] = variable[15];
      if (UNTAG_Bool(variable[16])) { /* and */
        variable[16] = CALL_abstractmetamodel___MMLocalProperty___name( variable[12] /*gp*/)( variable[12] /*gp*/) /*MMLocalProperty::name*/;
        if (once_bool_5) variable[17] = once_value_5;
        else {
          variable[17] = NEW_String_string___String___with_native(BOX_NativeString("init"), TAG_Int(4)); /*new String*/
          variable[17] = CALL_symbol___String___to_symbol(variable[17])(variable[17]) /*String::to_symbol*/;
          once_value_5 = variable[17];
          once_bool_5 = true;
        }
        variable[16] = TAG_Bool((variable[16] == variable[17]) || ((variable[16] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[16])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[16],variable[17])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[16])(variable[16], variable[17]) /*Object::==*/)))));
      }
      variable[15] = variable[16];
      if (UNTAG_Bool(variable[15])) { /*if*/
        CALL_abstract_collection___SimpleCollection___add( variable[6] /*candidates*/)( variable[6] /*candidates*/,  variable[12] /*gp*/) /*AbstractArray::add*/;
        CALL_abstract_collection___SimpleCollection___add( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/,  variable[12] /*gp*/) /*AbstractArray::add*/;
      } else { /*if*/
        CALL_abstract_collection___SimpleCollection___add( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/,  variable[12] /*gp*/) /*AbstractArray::add*/;
      }
    }
    continue_4: while(0);
    CALL_abstract_collection___Iterator___next(variable[9])(variable[9]) /*Iterator::next*/;
  }
  break_4: while(0);
  variable[9] = CALL_abstract_collection___Collection___length( variable[6] /*candidates*/)( variable[6] /*candidates*/) /*AbstractArray::length*/;
  variable[9] = TAG_Bool((variable[9])==( TAG_Int(1)));
  if (UNTAG_Bool(variable[9])) { /*if*/
    variable[9] = CALL_abstract_collection___Collection___first( variable[6] /*candidates*/)( variable[6] /*candidates*/) /*IndexedCollection::first*/;
    variable[4] = variable[9];
    goto return_label3;
  } else { /*if*/
    variable[9] = CALL_abstract_collection___Collection___length( variable[6] /*candidates*/)( variable[6] /*candidates*/) /*AbstractArray::length*/;
    variable[9] = TAG_Bool(UNTAG_Int(variable[9])>UNTAG_Int( TAG_Int(0)));
    if (UNTAG_Bool(variable[9])) { /*if*/
      variable[10] = NEW_Array_array___Array___init(); /*new Array[String]*/
      variable[9] = variable[10];
      variable[10] = CALL_abstract_collection___Collection___iterator( variable[6] /*candidates*/)( variable[6] /*candidates*/) /*AbstractArray::iterator*/;
      while (true) { /*for*/
        variable[11] = CALL_abstract_collection___Iterator___is_ok(variable[10])(variable[10]) /*ArrayIterator::is_ok*/;
        if (!UNTAG_Bool(variable[11])) break; /*for*/
        variable[11] = CALL_abstract_collection___Iterator___item(variable[10])(variable[10]) /*ArrayIterator::item*/;
        variable[12] = variable[11];
        variable[13] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
        variable[14] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
        variable[15] = variable[14];
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[15]) /*AbstractArray::add*/;
        variable[16] = CALL_abstractmetamodel___MMLocalProperty___full_name( variable[12] /*p*/)( variable[12] /*p*/) /*MMLocalProperty::full_name*/;
        variable[17] = variable[16];
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[17]) /*AbstractArray::add*/;
        variable[18] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
        variable[19] = variable[18];
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[19]) /*AbstractArray::add*/;
        variable[20] = CALL_static_type___MMLocalProperty___signature( variable[12] /*p*/)( variable[12] /*p*/) /*MMLocalProperty::signature*/;
        variable[21] = variable[20];
        variable[21] = CALL_string___Object___to_s(variable[21])(variable[21]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[21]) /*AbstractArray::add*/;
        variable[22] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
        variable[23] = variable[22];
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[23]) /*AbstractArray::add*/;
        variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add( variable[9] /*a*/)( variable[9] /*a*/, variable[13]) /*AbstractArray::add*/;
        continue_6: while(0);
        CALL_abstract_collection___Iterator___next(variable[10])(variable[10]) /*ArrayIterator::next*/;
      }
      break_6: while(0);
      variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
      variable[11] = NEW_String_string___String___with_native(BOX_NativeString("Error: Conflicting default constructor to call for "), TAG_Int(51)); /*new String*/
      variable[12] = variable[11];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[12]) /*AbstractArray::add*/;
      variable[13] =  variable[2] /*c*/;
      variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[13]) /*AbstractArray::add*/;
      variable[14] = NEW_String_string___String___with_native(BOX_NativeString(": "), TAG_Int(2)); /*new String*/
      variable[15] = variable[14];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[15]) /*AbstractArray::add*/;
      variable[16] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)); /*new String*/
      variable[16] = CALL_string___Collection___join( variable[9] /*a*/)( variable[9] /*a*/, variable[16]) /*Collection::join*/;
      variable[17] = variable[16];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[17]) /*AbstractArray::add*/;
      variable[18] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
      variable[19] = variable[18];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[19]) /*AbstractArray::add*/;
      variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[5] /*v*/)( variable[5] /*v*/,  variable[1] /*n*/, variable[10]) /*AbsSyntaxVisitor::error*/;
      variable[4] =  NIT_NULL /*null*/;
      goto return_label3;
    } else { /*if*/
      variable[9] = CALL_abstract_collection___Collection___length( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/) /*AbstractArray::length*/;
      variable[9] = TAG_Bool(UNTAG_Int(variable[9])>UNTAG_Int( TAG_Int(0)));
      if (UNTAG_Bool(variable[9])) { /*if*/
        variable[10] = NEW_Array_array___Array___init(); /*new Array[String]*/
        variable[9] = variable[10];
        variable[10] = CALL_abstract_collection___Collection___iterator( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/) /*AbstractArray::iterator*/;
        while (true) { /*for*/
          variable[11] = CALL_abstract_collection___Iterator___is_ok(variable[10])(variable[10]) /*ArrayIterator::is_ok*/;
          if (!UNTAG_Bool(variable[11])) break; /*for*/
          variable[11] = CALL_abstract_collection___Iterator___item(variable[10])(variable[10]) /*ArrayIterator::item*/;
          variable[12] = variable[11];
          variable[13] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
          variable[14] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
          variable[15] = variable[14];
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[15]) /*AbstractArray::add*/;
          variable[16] = CALL_abstractmetamodel___MMLocalProperty___full_name( variable[12] /*p*/)( variable[12] /*p*/) /*MMLocalProperty::full_name*/;
          variable[17] = variable[16];
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[17]) /*AbstractArray::add*/;
          variable[18] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
          variable[19] = variable[18];
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[19]) /*AbstractArray::add*/;
          variable[20] = CALL_static_type___MMLocalProperty___signature( variable[12] /*p*/)( variable[12] /*p*/) /*MMLocalProperty::signature*/;
          variable[21] = variable[20];
          variable[21] = CALL_string___Object___to_s(variable[21])(variable[21]) /*Object::to_s*/;
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[21]) /*AbstractArray::add*/;
          variable[22] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
          variable[23] = variable[22];
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[23]) /*AbstractArray::add*/;
          variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
          CALL_abstract_collection___SimpleCollection___add( variable[9] /*a*/)( variable[9] /*a*/, variable[13]) /*AbstractArray::add*/;
          continue_7: while(0);
          CALL_abstract_collection___Iterator___next(variable[10])(variable[10]) /*ArrayIterator::next*/;
        }
        break_7: while(0);
        variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
        variable[11] = NEW_String_string___String___with_native(BOX_NativeString("Error: there is no available compatible constrctor in "), TAG_Int(54)); /*new String*/
        variable[12] = variable[11];
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[12]) /*AbstractArray::add*/;
        variable[13] =  variable[2] /*c*/;
        variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[13]) /*AbstractArray::add*/;
        variable[14] = NEW_String_string___String___with_native(BOX_NativeString(". Discarded candidates are "), TAG_Int(27)); /*new String*/
        variable[15] = variable[14];
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[15]) /*AbstractArray::add*/;
        variable[16] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)); /*new String*/
        variable[16] = CALL_string___Collection___join( variable[9] /*a*/)( variable[9] /*a*/, variable[16]) /*Collection::join*/;
        variable[17] = variable[16];
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[17]) /*AbstractArray::add*/;
        variable[18] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
        variable[19] = variable[18];
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[19]) /*AbstractArray::add*/;
        variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[5] /*v*/)( variable[5] /*v*/,  variable[1] /*n*/, variable[10]) /*AbsSyntaxVisitor::error*/;
        variable[4] =  NIT_NULL /*null*/;
        goto return_label3;
      } else { /*if*/
        variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: there is no available compatible constrctor in "), TAG_Int(54)); /*new String*/
        variable[11] = variable[10];
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[11]) /*AbstractArray::add*/;
        variable[12] =  variable[2] /*c*/;
        variable[12] = CALL_string___Object___to_s(variable[12])(variable[12]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[12]) /*AbstractArray::add*/;
        variable[13] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
        variable[14] = variable[13];
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[14]) /*AbstractArray::add*/;
        variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[5] /*v*/)( variable[5] /*v*/,  variable[1] /*n*/, variable[9]) /*AbsSyntaxVisitor::error*/;
        variable[4] =  NIT_NULL /*null*/;
        goto return_label3;
      }
    }
  }
  return_label3: while(false);
  tracehead = trace.prev;
  return variable[4];
}
val_t typing___VariableContext_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 123, LOCATE_typing___VariableContext_____bra};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_typing___VariableContext____dico(variable[3]) /*VariableContext::_dico*/;
  variable[3] = CALL_abstract_collection___Map___has_key(variable[3])(variable[3],  variable[1] /*s*/) /*Map::has_key*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[3] = ATTR_typing___VariableContext____dico(variable[3]) /*VariableContext::_dico*/;
    variable[3] = CALL_abstract_collection___Map_____bra(variable[3])(variable[3],  variable[1] /*s*/) /*Map::[]*/;
    variable[2] = variable[3];
    goto return_label8;
  } else { /*if*/
    variable[2] =  NIT_NULL /*null*/;
    goto return_label8;
  }
  return_label8: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void typing___VariableContext___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 134, LOCATE_typing___VariableContext___add};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_typing___VariableContext____dico(variable[3]) /*VariableContext::_dico*/;
  variable[4] = CALL_syntax_base___Variable___name( variable[1] /*v*/)( variable[1] /*v*/) /*Variable::name*/;
  CALL_abstract_collection___Map_____braeq(variable[3])(variable[3], variable[4],  variable[1] /*v*/) /*Map::[]=*/;
  return_label9: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___VariableContext___stype(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 141, LOCATE_typing___VariableContext___stype};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = CALL_syntax_base___Variable___stype( variable[1] /*v*/)( variable[1] /*v*/) /*Variable::stype*/;
  variable[2] = variable[3];
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___VariableContext___sub(val_t  self) {
  struct trace_t trace = {NULL, NULL, 151, LOCATE_typing___VariableContext___sub};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[3] = NEW_SubVariableContext_typing___SubVariableContext___with_prev(variable[2],  NIT_NULL /*null*/,  NIT_NULL /*null*/); /*new SubVariableContext*/
  variable[2] = variable[3];
  variable[1] = variable[2];
  goto return_label11;
  return_label11: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___VariableContext___sub_with(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 157, LOCATE_typing___VariableContext___sub_with};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = variable[0];
  variable[5] = NEW_SubVariableContext_typing___SubVariableContext___with_prev(variable[4],  variable[1] /*v*/,  variable[2] /*t*/); /*new SubVariableContext*/
  variable[4] = variable[5];
  variable[3] = variable[4];
  goto return_label12;
  return_label12: while(false);
  tracehead = trace.prev;
  return variable[3];
}
void typing___VariableContext___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 163, LOCATE_typing___VariableContext___init};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_VariableContext].i]) return;
  variable[2] = variable[0];
  variable[3] = NEW_HashMap_hash___HashMap___init(); /*new HashMap[Symbol, Variable]*/
  ATTR_typing___VariableContext____dico(variable[2]) /*VariableContext::_dico*/ = variable[3];
  return_label13: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_VariableContext].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t typing___SubVariableContext_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 175, LOCATE_typing___SubVariableContext_____bra};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_typing___VariableContext____dico(variable[3]) /*VariableContext::_dico*/;
  variable[3] = CALL_abstract_collection___Map___has_key(variable[3])(variable[3],  variable[1] /*s*/) /*Map::has_key*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[3] = ATTR_typing___VariableContext____dico(variable[3]) /*VariableContext::_dico*/;
    variable[3] = CALL_abstract_collection___Map_____bra(variable[3])(variable[3],  variable[1] /*s*/) /*Map::[]*/;
    variable[2] = variable[3];
    goto return_label14;
  } else { /*if*/
    variable[3] = variable[0];
    variable[3] = CALL_typing___SubVariableContext___prev(variable[3])(variable[3]) /*SubVariableContext::prev*/;
    variable[3] = CALL_typing___VariableContext_____bra(variable[3])(variable[3],  variable[1] /*s*/) /*VariableContext::[]*/;
    variable[2] = variable[3];
    goto return_label14;
  }
  return_label14: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___SubVariableContext___stype(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 184, LOCATE_typing___SubVariableContext___stype};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_typing___SubVariableContext____variable(variable[3]) /*SubVariableContext::_variable*/;
  variable[3] = TAG_Bool((variable[3] ==  variable[1] /*v*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], variable[1] /*v*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  variable[1] /*v*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[3] = ATTR_typing___SubVariableContext____var_type(variable[3]) /*SubVariableContext::_var_type*/;
    variable[2] = variable[3];
    goto return_label15;
  }
  variable[3] = variable[0];
  variable[3] = CALL_typing___SubVariableContext___prev(variable[3])(variable[3]) /*SubVariableContext::prev*/;
  variable[3] = CALL_typing___VariableContext___stype(variable[3])(variable[3],  variable[1] /*v*/) /*VariableContext::stype*/;
  variable[2] = variable[3];
  goto return_label15;
  return_label15: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___SubVariableContext___prev(val_t  self) {
  struct trace_t trace = {NULL, NULL, 171, LOCATE_typing___SubVariableContext___prev};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___SubVariableContext____prev( self) /*SubVariableContext::_prev*/;
}
void typing___SubVariableContext___with_prev(val_t  self, val_t  param0, val_t  param1, val_t  param2, int* init_table) {
  struct trace_t trace = {NULL, NULL, 192, LOCATE_typing___SubVariableContext___with_prev};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_SubVariableContext].i]) return;
  variable[5] = variable[0];
  CALL_typing___VariableContext___init(variable[5])(variable[5], init_table /*YYY*/) /*VariableContext::init*/;
  variable[5] = variable[0];
  ATTR_typing___SubVariableContext____prev(variable[5]) /*SubVariableContext::_prev*/ =  variable[1] /*p*/;
  variable[5] = variable[0];
  ATTR_typing___SubVariableContext____variable(variable[5]) /*SubVariableContext::_variable*/ =  variable[2] /*v*/;
  variable[5] = variable[0];
  ATTR_typing___SubVariableContext____var_type(variable[5]) /*SubVariableContext::_var_type*/ =  variable[3] /*t*/;
  return_label16: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_SubVariableContext].i] = 1;
  tracehead = trace.prev;
  return;
}
void typing___PNode___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 205, LOCATE_typing___PNode___accept_typing};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  CALL_syntax_base___PNode___accept_abs_syntax_visitor(variable[3])(variable[3],  variable[1] /*v*/) /*PNode::accept_abs_syntax_visitor*/;
  variable[3] = variable[0];
  CALL_typing___PNode___after_typing(variable[3])(variable[3],  variable[1] /*v*/) /*PNode::after_typing*/;
  return_label17: while(false);
  tracehead = trace.prev;
  return;
}
void typing___PNode___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 210, LOCATE_typing___PNode___after_typing};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  return_label18: while(false);
  tracehead = trace.prev;
  return;
}
void typing___PClassdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 214, LOCATE_typing___PClassdef___accept_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = NEW_String_string___String___with_native(BOX_NativeString("self"), TAG_Int(4)); /*new String*/
  variable[3] = CALL_symbol___String___to_symbol(variable[3])(variable[3]) /*String::to_symbol*/;
  variable[4] = variable[0];
  variable[5] = NEW_ParamVariable_syntax_base___ParamVariable___init(variable[3], variable[4]); /*new ParamVariable*/
  variable[3] = variable[5];
  CALL_typing___TypingVisitor___self_var__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::self_var=*/;
  variable[3] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
  variable[4] = variable[0];
  variable[4] = CALL_syntax_base___PClassdef___local_class(variable[4])(variable[4]) /*PClassdef::local_class*/;
  variable[4] = CALL_static_type___MMLocalClass___get_type(variable[4])(variable[4]) /*MMLocalClass::get_type*/;
  CALL_syntax_base___Variable___stype__eq(variable[3])(variable[3], variable[4]) /*Variable::stype=*/;
  CALL_SUPER_typing___PClassdef___accept_typing(variable[0])(variable[0], variable[1]) /*super PClassdef::accept_typing*/;
  return_label19: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAttrPropdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 223, LOCATE_typing___AAttrPropdef___accept_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  CALL_SUPER_typing___AAttrPropdef___accept_typing(variable[0])(variable[0], variable[1]) /*super AAttrPropdef::accept_typing*/;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AAttrPropdef___n_expr(variable[3])(variable[3]) /*AAttrPropdef::n_expr*/;
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[3] = CALL_parser_nodes___AAttrPropdef___n_expr(variable[3])(variable[3]) /*AAttrPropdef::n_expr*/;
    variable[4] = variable[0];
    variable[4] = CALL_syntax_base___AAttrPropdef___prop(variable[4])(variable[4]) /*AAttrPropdef::prop*/;
    variable[4] = CALL_static_type___MMLocalProperty___signature(variable[4])(variable[4]) /*MMLocalProperty::signature*/;
    variable[4] = CALL_static_type___MMSignature___return_type(variable[4])(variable[4]) /*MMSignature::return_type*/;
    CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  }
  return_label20: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AMethPropdef___self_var(val_t  self) {
  struct trace_t trace = {NULL, NULL, 233, LOCATE_typing___AMethPropdef___self_var};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AMethPropdef____self_var( self) /*AMethPropdef::_self_var*/;
}
void typing___AMethPropdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 234, LOCATE_typing___AMethPropdef___accept_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = NEW_VariableContext_typing___VariableContext___init(); /*new VariableContext*/
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::variable_ctx=*/;
  variable[3] = variable[0];
  variable[4] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
  ATTR_typing___AMethPropdef____self_var(variable[3]) /*AMethPropdef::_self_var*/ = variable[4];
  CALL_SUPER_typing___AMethPropdef___accept_typing(variable[0])(variable[0], variable[1]) /*super AMethPropdef::accept_typing*/;
  return_label21: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AConcreteInitPropdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 245, LOCATE_typing___AConcreteInitPropdef___accept_typing};
  val_t variable[15];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AConcreteMethPropdef___n_block(variable[3])(variable[3]) /*AConcreteMethPropdef::n_block*/;
  CALL_typing___TypingVisitor___top_block__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::top_block=*/;
  variable[3] = variable[0];
  variable[3] = CALL_typing___AConcreteInitPropdef___explicit_super_init_calls(variable[3])(variable[3]) /*AConcreteInitPropdef::explicit_super_init_calls*/;
  CALL_typing___TypingVisitor___explicit_super_init_calls__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::explicit_super_init_calls=*/;
  CALL_typing___TypingVisitor___explicit_other_init_call__eq( variable[1] /*v*/)( variable[1] /*v*/,  TAG_Bool(false)) /*TypingVisitor::explicit_other_init_call=*/;
  CALL_SUPER_typing___AConcreteInitPropdef___accept_typing(variable[0])(variable[0], variable[1]) /*super AConcreteInitPropdef::accept_typing*/;
  variable[3] = CALL_typing___TypingVisitor___explicit_other_init_call( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::explicit_other_init_call*/;
  variable[4] = variable[3];
  if (!UNTAG_Bool(variable[4])) { /* or */
    variable[4] = variable[0];
    variable[4] = CALL_syntax_base___AMethPropdef___method(variable[4])(variable[4]) /*AMethPropdef::method*/;
    variable[4] = CALL_abstractmetamodel___MMLocalProperty___global(variable[4])(variable[4]) /*MMLocalProperty::global*/;
    variable[4] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[4])(variable[4]) /*MMGlobalProperty::intro*/;
    variable[5] = variable[0];
    variable[5] = CALL_syntax_base___AMethPropdef___method(variable[5])(variable[5]) /*AMethPropdef::method*/;
    variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] == variable[5]) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4],variable[5])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4], variable[5]) /*Object::==*/)))))));
  }
  variable[3] = variable[4];
  if (UNTAG_Bool(variable[3])) { /*if*/
  } else { /*if*/
    variable[3] =  TAG_Int(0);
    variable[5] = variable[0];
    variable[5] = CALL_typing___AConcreteInitPropdef___explicit_super_init_calls(variable[5])(variable[5]) /*AConcreteInitPropdef::explicit_super_init_calls*/;
    variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
    variable[4] = variable[5];
    variable[5] =  NIT_NULL /*null*/;
    variable[6] =  NIT_NULL /*null*/;
    variable[7] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
    if (UNTAG_Bool(variable[7])) { /*if*/
      variable[7] = variable[0];
      variable[7] = CALL_typing___AConcreteInitPropdef___explicit_super_init_calls(variable[7])(variable[7]) /*AConcreteInitPropdef::explicit_super_init_calls*/;
      variable[8] = variable[7];
      variable[9] =  variable[3] /*i*/;
      variable[11] = TAG_Bool(UNTAG_Int( variable[9] /*index*/)>=UNTAG_Int( TAG_Int(0)));
      variable[12] = variable[11];
      if (UNTAG_Bool(variable[12])) { /* and */
        variable[12] = variable[8];
        variable[12] = ATTR_array___AbstractArray____length(variable[12]) /*AbstractArray::_length*/;
        variable[12] = TAG_Bool(UNTAG_Int( variable[9] /*index*/)<UNTAG_Int(variable[12]));
      }
      variable[11] = variable[12];
      if (!UNTAG_Bool(variable[11])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 229); nit_exit(1);}
      variable[11] = variable[8];
      variable[11] = ATTR_array___Array____items(variable[11]) /*Array::_items*/;
      variable[11] = UNBOX_NativeArray(variable[11])[UNTAG_Int( variable[9] /*index*/)];
      variable[10] = variable[11];
      goto return_label23;
      return_label23: while(false);
      variable[7] = variable[10];
      variable[5] = variable[7] /*cur_m=*/;
      variable[7] = CALL_abstractmetamodel___MMLocalProperty___global( variable[5] /*cur_m*/)( variable[5] /*cur_m*/) /*MMLocalProperty::global*/;
      variable[7] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[7])(variable[7]) /*MMGlobalProperty::intro*/;
      variable[7] = CALL_abstractmetamodel___MMLocalProperty___local_class(variable[7])(variable[7]) /*MMLocalProperty::local_class*/;
      variable[8] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
      variable[7] = CALL_abstractmetamodel___MMLocalClass___for_module(variable[7])(variable[7], variable[8]) /*MMLocalClass::for_module*/;
      variable[6] = variable[7] /*cur_c=*/;
    }
    variable[7] =  TAG_Int(0);
    while (true) { /*while*/
      variable[8] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
      variable[8] = CALL_abstractmetamodel___MMLocalClass___cshe(variable[8])(variable[8]) /*MMLocalClass::cshe*/;
      variable[8] = CALL_partial_order___PartialOrderElement___direct_greaters(variable[8])(variable[8]) /*PartialOrderElement::direct_greaters*/;
      variable[8] = CALL_abstract_collection___Collection___length(variable[8])(variable[8]) /*AbstractArray::length*/;
      variable[8] = TAG_Bool(UNTAG_Int( variable[7] /*j*/)<UNTAG_Int(variable[8]));
      if (!UNTAG_Bool(variable[8])) break; /* while*/
      variable[9] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
      variable[9] = CALL_abstractmetamodel___MMLocalClass___cshe(variable[9])(variable[9]) /*MMLocalClass::cshe*/;
      variable[9] = CALL_partial_order___PartialOrderElement___direct_greaters(variable[9])(variable[9]) /*PartialOrderElement::direct_greaters*/;
      variable[10] = variable[9];
      variable[11] =  variable[7] /*j*/;
      variable[13] = TAG_Bool(UNTAG_Int( variable[11] /*index*/)>=UNTAG_Int( TAG_Int(0)));
      variable[14] = variable[13];
      if (UNTAG_Bool(variable[14])) { /* and */
        variable[14] = variable[10];
        variable[14] = ATTR_array___AbstractArray____length(variable[14]) /*AbstractArray::_length*/;
        variable[14] = TAG_Bool(UNTAG_Int( variable[11] /*index*/)<UNTAG_Int(variable[14]));
      }
      variable[13] = variable[14];
      if (!UNTAG_Bool(variable[13])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 229); nit_exit(1);}
      variable[13] = variable[10];
      variable[13] = ATTR_array___Array____items(variable[13]) /*Array::_items*/;
      variable[13] = UNBOX_NativeArray(variable[13])[UNTAG_Int( variable[11] /*index*/)];
      variable[12] = variable[13];
      goto return_label25;
      return_label25: while(false);
      variable[9] = variable[12];
      variable[8] = variable[9];
      variable[9] = CALL_abstractmetamodel___MMLocalClass___global( variable[8] /*c*/)( variable[8] /*c*/) /*MMLocalClass::global*/;
      variable[9] = CALL_abstractmetamodel___MMGlobalClass___is_interface(variable[9])(variable[9]) /*MMGlobalClass::is_interface*/;
      variable[10] = variable[9];
      if (!UNTAG_Bool(variable[10])) { /* or */
        variable[10] = CALL_abstractmetamodel___MMLocalClass___global( variable[8] /*c*/)( variable[8] /*c*/) /*MMLocalClass::global*/;
        variable[10] = CALL_abstractmetamodel___MMGlobalClass___is_universal(variable[10])(variable[10]) /*MMGlobalClass::is_universal*/;
      }
      variable[9] = variable[10];
      variable[10] = variable[9];
      if (!UNTAG_Bool(variable[10])) { /* or */
        variable[10] = CALL_abstractmetamodel___MMLocalClass___global( variable[8] /*c*/)( variable[8] /*c*/) /*MMLocalClass::global*/;
        variable[10] = CALL_abstractmetamodel___MMGlobalClass___is_mixin(variable[10])(variable[10]) /*MMGlobalClass::is_mixin*/;
      }
      variable[9] = variable[10];
      if (UNTAG_Bool(variable[9])) { /*if*/
        variable[7] = TAG_Int(UNTAG_Int(variable[7])+UNTAG_Int( TAG_Int(1))) /*j*/;
      } else { /*if*/
        variable[9] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[6] /*cur_c*/ ==  NIT_NULL /*null*/) || (( variable[6] /*cur_c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[6] /*cur_c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[6] /*cur_c*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[6] /*cur_c*/)( variable[6] /*cur_c*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
        variable[10] = variable[9];
        if (UNTAG_Bool(variable[10])) { /* and */
          variable[10] = CALL_abstractmetamodel___MMLocalClass___cshe( variable[8] /*c*/)( variable[8] /*c*/) /*MMLocalClass::cshe*/;
          variable[10] = CALL_partial_order___PartialOrderElement_____leq(variable[10])(variable[10],  variable[6] /*cur_c*/) /*PartialOrderElement::<=*/;
          variable[11] = variable[10];
          if (!UNTAG_Bool(variable[11])) { /* or */
            variable[11] = CALL_abstractmetamodel___MMLocalClass___global( variable[6] /*cur_c*/)( variable[6] /*cur_c*/) /*MMLocalClass::global*/;
            variable[11] = CALL_abstractmetamodel___MMGlobalClass___is_mixin(variable[11])(variable[11]) /*MMGlobalClass::is_mixin*/;
          }
          variable[10] = variable[11];
        }
        variable[9] = variable[10];
        if (UNTAG_Bool(variable[9])) { /*if*/
          variable[9] = TAG_Bool(( variable[8] /*c*/ ==  variable[6] /*cur_c*/) || (( variable[8] /*c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[8] /*c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[8] /*c*/, variable[6] /*cur_c*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[8] /*c*/)( variable[8] /*c*/,  variable[6] /*cur_c*/) /*Object::==*/)))));
          if (UNTAG_Bool(variable[9])) { /*if*/
            variable[7] = TAG_Int(UNTAG_Int(variable[7])+UNTAG_Int( TAG_Int(1))) /*j*/;
          }
          variable[9] = variable[0];
          variable[9] = CALL_typing___AConcreteInitPropdef___super_init_calls(variable[9])(variable[9]) /*AConcreteInitPropdef::super_init_calls*/;
          CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9],  variable[5] /*cur_m*/) /*AbstractArray::add*/;
          variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
          variable[9] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
          if (UNTAG_Bool(variable[9])) { /*if*/
            variable[9] = variable[0];
            variable[9] = CALL_typing___AConcreteInitPropdef___explicit_super_init_calls(variable[9])(variable[9]) /*AConcreteInitPropdef::explicit_super_init_calls*/;
            variable[10] = variable[9];
            variable[11] =  variable[3] /*i*/;
            variable[13] = TAG_Bool(UNTAG_Int( variable[11] /*index*/)>=UNTAG_Int( TAG_Int(0)));
            variable[14] = variable[13];
            if (UNTAG_Bool(variable[14])) { /* and */
              variable[14] = variable[10];
              variable[14] = ATTR_array___AbstractArray____length(variable[14]) /*AbstractArray::_length*/;
              variable[14] = TAG_Bool(UNTAG_Int( variable[11] /*index*/)<UNTAG_Int(variable[14]));
            }
            variable[13] = variable[14];
            if (!UNTAG_Bool(variable[13])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 229); nit_exit(1);}
            variable[13] = variable[10];
            variable[13] = ATTR_array___Array____items(variable[13]) /*Array::_items*/;
            variable[13] = UNBOX_NativeArray(variable[13])[UNTAG_Int( variable[11] /*index*/)];
            variable[12] = variable[13];
            goto return_label26;
            return_label26: while(false);
            variable[9] = variable[12];
            variable[5] = variable[9] /*cur_m=*/;
            variable[9] = CALL_abstractmetamodel___MMLocalProperty___global( variable[5] /*cur_m*/)( variable[5] /*cur_m*/) /*MMLocalProperty::global*/;
            variable[9] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[9])(variable[9]) /*MMGlobalProperty::intro*/;
            variable[9] = CALL_abstractmetamodel___MMLocalProperty___local_class(variable[9])(variable[9]) /*MMLocalProperty::local_class*/;
            variable[10] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
            variable[9] = CALL_abstractmetamodel___MMLocalClass___for_module(variable[9])(variable[9], variable[10]) /*MMLocalClass::for_module*/;
            variable[6] = variable[9] /*cur_c=*/;
          } else { /*if*/
            variable[5] =  NIT_NULL /*null*/ /*cur_m=*/;
            variable[6] =  NIT_NULL /*null*/ /*cur_c=*/;
          }
        } else { /*if*/
          variable[10] = variable[0];
          variable[11] = variable[0];
          variable[11] = CALL_syntax_base___AMethPropdef___method(variable[11])(variable[11]) /*AMethPropdef::method*/;
          variable[10] = CALL_typing___TypingVisitor___get_default_constructor_for( variable[1] /*v*/)( variable[1] /*v*/, variable[10],  variable[8] /*c*/, variable[11]) /*TypingVisitor::get_default_constructor_for*/;
          variable[9] = variable[10];
          variable[10] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[9] /*p*/ ==  NIT_NULL /*null*/) || (( variable[9] /*p*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[9] /*p*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[9] /*p*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[9] /*p*/)( variable[9] /*p*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
          if (UNTAG_Bool(variable[10])) { /*if*/
            variable[10] = variable[0];
            variable[10] = CALL_typing___AConcreteInitPropdef___super_init_calls(variable[10])(variable[10]) /*AConcreteInitPropdef::super_init_calls*/;
            CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10],  variable[9] /*p*/) /*AbstractArray::add*/;
          }
          variable[7] = TAG_Int(UNTAG_Int(variable[7])+UNTAG_Int( TAG_Int(1))) /*j*/;
        }
      }
      continue_24: while(0);
    }
    break_24: while(0);
  }
  return_label22: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AConcreteInitPropdef___super_init_calls(val_t  self) {
  struct trace_t trace = {NULL, NULL, 243, LOCATE_typing___AConcreteInitPropdef___super_init_calls};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AConcreteInitPropdef____super_init_calls( self) /*AConcreteInitPropdef::_super_init_calls*/;
}
val_t typing___AConcreteInitPropdef___explicit_super_init_calls(val_t  self) {
  struct trace_t trace = {NULL, NULL, 244, LOCATE_typing___AConcreteInitPropdef___explicit_super_init_calls};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AConcreteInitPropdef____explicit_super_init_calls( self) /*AConcreteInitPropdef::_explicit_super_init_calls*/;
}
void typing___PParam___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 291, LOCATE_typing___PParam___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    variable[4] = variable[0];
    variable[4] = CALL_syntax_base___PParam___variable(variable[4])(variable[4]) /*PParam::variable*/;
    CALL_typing___VariableContext___add(variable[3])(variable[3], variable[4]) /*VariableContext::add*/;
  }
  return_label27: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AClosureDecl___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 301, LOCATE_typing___AClosureDecl___accept_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[4] = variable[0];
  variable[4] = CALL_syntax_base___PClosureDecl___variable(variable[4])(variable[4]) /*PClosureDecl::variable*/;
  CALL_typing___VariableContext___add(variable[3])(variable[3], variable[4]) /*VariableContext::add*/;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[4] = CALL_typing___VariableContext___sub(variable[4])(variable[4]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::variable_ctx=*/;
  variable[4] = variable[0];
  variable[4] = CALL_syntax_base___PClosureDecl___variable(variable[4])(variable[4]) /*PClosureDecl::variable*/;
  variable[4] = CALL_syntax_base___ClosureVariable___closure(variable[4])(variable[4]) /*ClosureVariable::closure*/;
  CALL_typing___TypingVisitor___closure__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::closure=*/;
  CALL_SUPER_typing___AClosureDecl___accept_typing(variable[0])(variable[0], variable[1]) /*super AClosureDecl::accept_typing*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  CALL_typing___TypingVisitor___closure__eq( variable[1] /*v*/)( variable[1] /*v*/,  NIT_NULL /*null*/) /*TypingVisitor::closure=*/;
  return_label28: while(false);
  tracehead = trace.prev;
  return;
}
void typing___PType___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 319, LOCATE_typing___PType___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_syntax_base___PType___get_stype(variable[4])(variable[4],  variable[1] /*v*/) /*PType::get_stype*/;
  ATTR_typing___PType____stype(variable[3]) /*PType::_stype*/ = variable[4];
  return_label29: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___PType___stype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 318, LOCATE_typing___PType___stype};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___PType____stype( self) /*PType::_stype*/;
}
val_t typing___PExpr___stype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 326, LOCATE_typing___PExpr___stype};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___PExpr____stype( self) /*PExpr::_stype*/;
}
val_t typing___PExpr___is_implicit_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 328, LOCATE_typing___PExpr___is_implicit_self};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  TAG_Bool(false);
  goto return_label30;
  return_label30: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___PExpr___is_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 331, LOCATE_typing___PExpr___is_self};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  TAG_Bool(false);
  goto return_label31;
  return_label31: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___PExpr___its_variable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 334, LOCATE_typing___PExpr___its_variable};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  NIT_NULL /*null*/;
  goto return_label32;
  return_label32: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___PExpr___if_true_variable_ctx(val_t  self) {
  struct trace_t trace = {NULL, NULL, 337, LOCATE_typing___PExpr___if_true_variable_ctx};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___PExpr____if_true_variable_ctx( self) /*PExpr::_if_true_variable_ctx*/;
}
void typing___AVardeclExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 342, LOCATE_typing___AVardeclExpr___after_typing};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AVardeclExpr___n_id(variable[4])(variable[4]) /*AVardeclExpr::n_id*/;
  variable[4] = CALL_syntax_base___Token___to_symbol(variable[4])(variable[4]) /*Token::to_symbol*/;
  variable[5] = variable[0];
  variable[6] = NEW_VarVariable_syntax_base___VarVariable___init(variable[4], variable[5]); /*new VarVariable*/
  variable[4] = variable[6];
  variable[3] = variable[4];
  variable[4] = variable[0];
  CALL_syntax_base___AVardeclExpr___variable__eq(variable[4])(variable[4],  variable[3] /*va*/) /*AVardeclExpr::variable=*/;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_typing___VariableContext___add(variable[4])(variable[4],  variable[3] /*va*/) /*VariableContext::add*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AVardeclExpr___n_type(variable[4])(variable[4]) /*AVardeclExpr::n_type*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AVardeclExpr___n_type(variable[4])(variable[4]) /*AVardeclExpr::n_type*/;
    variable[4] = CALL_typing___PType___stype(variable[4])(variable[4]) /*PType::stype*/;
    CALL_syntax_base___Variable___stype__eq( variable[3] /*va*/)( variable[3] /*va*/, variable[4]) /*Variable::stype=*/;
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[4])(variable[4]) /*AVardeclExpr::n_expr*/;
    variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[4] = variable[0];
      variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[4])(variable[4]) /*AVardeclExpr::n_expr*/;
      variable[5] = CALL_syntax_base___Variable___stype( variable[3] /*va*/)( variable[3] /*va*/) /*Variable::stype*/;
      CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
    }
  } else { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[4])(variable[4]) /*AVardeclExpr::n_expr*/;
    CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*AbsSyntaxVisitor::check_expr*/;
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[4])(variable[4]) /*AVardeclExpr::n_expr*/;
    variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
    CALL_syntax_base___Variable___stype__eq( variable[3] /*va*/)( variable[3] /*va*/, variable[4]) /*Variable::stype=*/;
  }
  return_label33: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ABlockExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 361, LOCATE_typing___ABlockExpr___accept_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[4] = CALL_typing___VariableContext___sub(variable[4])(variable[4]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::variable_ctx=*/;
  CALL_SUPER_typing___ABlockExpr___accept_typing(variable[0])(variable[0], variable[1]) /*super ABlockExpr::accept_typing*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  return_label34: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AReturnExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 373, LOCATE_typing___AReturnExpr___after_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
  variable[4] = CALL_static_type___MMLocalProperty___signature(variable[4])(variable[4]) /*MMLocalProperty::signature*/;
  variable[4] = CALL_static_type___MMSignature___return_type(variable[4])(variable[4]) /*MMSignature::return_type*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AReturnExpr___n_expr(variable[4])(variable[4]) /*AReturnExpr::n_expr*/;
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  variable[5] = variable[4];
  if (UNTAG_Bool(variable[5])) { /* and */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  }
  variable[4] = variable[5];
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: Return without value in a function."), TAG_Int(42)); /*new String*/
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
  } else { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AReturnExpr___n_expr(variable[4])(variable[4]) /*AReturnExpr::n_expr*/;
    variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
    variable[5] = variable[4];
    if (UNTAG_Bool(variable[5])) { /* and */
      variable[5] = TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
    }
    variable[4] = variable[5];
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[4] = variable[0];
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: Return with value in a procedure."), TAG_Int(40)); /*new String*/
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[4] = variable[0];
      variable[4] = CALL_parser_nodes___AReturnExpr___n_expr(variable[4])(variable[4]) /*AReturnExpr::n_expr*/;
      variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
      variable[5] = variable[4];
      if (UNTAG_Bool(variable[5])) { /* and */
        variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
      }
      variable[4] = variable[5];
      if (UNTAG_Bool(variable[4])) { /*if*/
        variable[4] = variable[0];
        variable[4] = CALL_parser_nodes___AReturnExpr___n_expr(variable[4])(variable[4]) /*AReturnExpr::n_expr*/;
        CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4],  variable[3] /*t*/) /*AbsSyntaxVisitor::check_conform_expr*/;
      }
    }
  }
  return_label35: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AContinueExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 387, LOCATE_typing___AContinueExpr___after_typing};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___closure( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::closure*/;
  variable[3] = variable[4];
  variable[4] =  NIT_NULL /*null*/;
  variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*c*/ ==  NIT_NULL /*null*/) || (( variable[3] /*c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*c*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*c*/)( variable[3] /*c*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[5] = CALL_static_type___MMClosure___is_break( variable[3] /*c*/)( variable[3] /*c*/) /*MMClosure::is_break*/;
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[5] = variable[0];
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: 'continue' forbiden in break blocks."), TAG_Int(43)); /*new String*/
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
      goto return_label36;
    }
    variable[5] = CALL_static_type___MMClosure___signature( variable[3] /*c*/)( variable[3] /*c*/) /*MMClosure::signature*/;
    variable[5] = CALL_static_type___MMSignature___return_type(variable[5])(variable[5]) /*MMSignature::return_type*/;
    variable[4] = variable[5] /*t=*/;
  }
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___AContinueExpr___n_expr(variable[5])(variable[5]) /*AContinueExpr::n_expr*/;
  variable[5] = TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))));
  variable[6] = variable[5];
  if (UNTAG_Bool(variable[6])) { /* and */
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*t*/ ==  NIT_NULL /*null*/) || (( variable[4] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*t*/)( variable[4] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  }
  variable[5] = variable[6];
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[5] = variable[0];
    variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: continue with a value required in this bloc."), TAG_Int(51)); /*new String*/
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
  } else { /*if*/
    variable[5] = variable[0];
    variable[5] = CALL_parser_nodes___AContinueExpr___n_expr(variable[5])(variable[5]) /*AContinueExpr::n_expr*/;
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
    variable[6] = variable[5];
    if (UNTAG_Bool(variable[6])) { /* and */
      variable[6] = TAG_Bool(( variable[4] /*t*/ ==  NIT_NULL /*null*/) || (( variable[4] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*t*/)( variable[4] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
    }
    variable[5] = variable[6];
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[5] = variable[0];
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: continue without value required in this bloc."), TAG_Int(52)); /*new String*/
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[5] = variable[0];
      variable[5] = CALL_parser_nodes___AContinueExpr___n_expr(variable[5])(variable[5]) /*AContinueExpr::n_expr*/;
      variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
      variable[6] = variable[5];
      if (UNTAG_Bool(variable[6])) { /* and */
        variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*t*/ ==  NIT_NULL /*null*/) || (( variable[4] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*t*/)( variable[4] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
      }
      variable[5] = variable[6];
      if (UNTAG_Bool(variable[5])) { /*if*/
        variable[5] = variable[0];
        variable[5] = CALL_parser_nodes___AContinueExpr___n_expr(variable[5])(variable[5]) /*AContinueExpr::n_expr*/;
        CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[5],  variable[4] /*t*/) /*AbsSyntaxVisitor::check_conform_expr*/;
      }
    }
  }
  return_label36: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ABreakExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 410, LOCATE_typing___ABreakExpr___after_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___closure_break_stype( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::closure_break_stype*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___ABreakExpr___n_expr(variable[4])(variable[4]) /*ABreakExpr::n_expr*/;
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  variable[5] = variable[4];
  if (UNTAG_Bool(variable[5])) { /* and */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  }
  variable[4] = variable[5];
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: break with a value required in this bloc."), TAG_Int(48)); /*new String*/
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
  } else { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___ABreakExpr___n_expr(variable[4])(variable[4]) /*ABreakExpr::n_expr*/;
    variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
    variable[5] = variable[4];
    if (UNTAG_Bool(variable[5])) { /* and */
      variable[5] = TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
    }
    variable[4] = variable[5];
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[4] = variable[0];
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: break without value required in this bloc."), TAG_Int(49)); /*new String*/
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[4] = variable[0];
      variable[4] = CALL_parser_nodes___ABreakExpr___n_expr(variable[4])(variable[4]) /*ABreakExpr::n_expr*/;
      variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
      variable[5] = variable[4];
      if (UNTAG_Bool(variable[5])) { /* and */
        variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
      }
      variable[4] = variable[5];
      if (UNTAG_Bool(variable[4])) { /*if*/
        variable[4] = CALL_typing___TypingVisitor___break_list( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::break_list*/;
        variable[5] = variable[0];
        variable[5] = CALL_parser_nodes___ABreakExpr___n_expr(variable[5])(variable[5]) /*ABreakExpr::n_expr*/;
        CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
      }
    }
  }
  return_label37: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AIfExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 425, LOCATE_typing___AIfExpr___accept_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfExpr___n_expr(variable[4])(variable[4]) /*AIfExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfExpr___n_expr(variable[4])(variable[4]) /*AIfExpr::n_expr*/;
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfExpr___n_expr(variable[4])(variable[4]) /*AIfExpr::n_expr*/;
  variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AIfExpr___n_expr(variable[4])(variable[4]) /*AIfExpr::n_expr*/;
    variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
    CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::variable_ctx=*/;
  }
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfExpr___n_then(variable[4])(variable[4]) /*AIfExpr::n_then*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfExpr___n_else(variable[4])(variable[4]) /*AIfExpr::n_else*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AIfExpr___n_else(variable[4])(variable[4]) /*AIfExpr::n_else*/;
    CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
    CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  }
  return_label38: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AWhileExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 447, LOCATE_typing___AWhileExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AWhileExpr___n_expr(variable[3])(variable[3]) /*AWhileExpr::n_expr*/;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  return_label39: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AForExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 454, LOCATE_typing___AForExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(( variable[3] /*varctx*/==NIT_NULL) || VAL_ISA( variable[3] /*varctx*/, COLOR_SubVariableContext, ID_SubVariableContext)) /*cast SubVariableContext*/;
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___AForExpr___after_typing, LOCATE_typing, 458); nit_exit(1);}
  variable[4] = CALL_typing___SubVariableContext___prev( variable[3] /*varctx*/)( variable[3] /*varctx*/) /*SubVariableContext::prev*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::variable_ctx=*/;
  return_label40: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AForVardeclExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 468, LOCATE_typing___AForVardeclExpr___after_typing};
  static val_t once_value_42; static int once_bool_42; /* Once value for variable[7]*/
  static val_t once_value_43; static int once_bool_43; /* Once value for variable[8]*/
  static val_t once_value_44; static int once_bool_44; /* Once value for variable[8]*/
  static val_t once_value_45; static int once_bool_45; /* Once value for variable[8]*/
  val_t variable[13];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = CALL_typing___VariableContext___sub(variable[3])(variable[3]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::variable_ctx=*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AForVardeclExpr___n_id(variable[4])(variable[4]) /*AForVardeclExpr::n_id*/;
  variable[4] = CALL_syntax_base___Token___to_symbol(variable[4])(variable[4]) /*Token::to_symbol*/;
  variable[5] = variable[0];
  variable[6] = NEW_AutoVariable_syntax_base___AutoVariable___init(variable[4], variable[5]); /*new AutoVariable*/
  variable[4] = variable[6];
  variable[3] = variable[4];
  variable[4] = variable[0];
  CALL_syntax_base___AForVardeclExpr___variable__eq(variable[4])(variable[4],  variable[3] /*va*/) /*AForVardeclExpr::variable=*/;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_typing___VariableContext___add(variable[4])(variable[4],  variable[3] /*va*/) /*VariableContext::add*/;
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___AForVardeclExpr___n_expr(variable[5])(variable[5]) /*AForVardeclExpr::n_expr*/;
  variable[5] = CALL_syntax_base___PExpr___stype(variable[5])(variable[5]) /*PExpr::stype*/;
  variable[4] = variable[5];
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___AForVardeclExpr___n_expr(variable[5])(variable[5]) /*AForVardeclExpr::n_expr*/;
  variable[6] = CALL_syntax_base___AbsSyntaxVisitor___type_collection( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_collection*/;
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::check_conform_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
    goto return_label41;
  }
  variable[5] = variable[0];
  variable[6] = CALL_static_type___MMType___local_class( variable[4] /*expr_type*/)( variable[4] /*expr_type*/) /*MMType::local_class*/;
  if (once_bool_42) variable[7] = once_value_42;
  else {
    variable[7] = NEW_String_string___String___with_native(BOX_NativeString("iterator"), TAG_Int(8)); /*new String*/
    variable[7] = CALL_symbol___String___to_symbol(variable[7])(variable[7]) /*String::to_symbol*/;
    once_value_42 = variable[7];
    once_bool_42 = true;
  }
  variable[6] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[6])(variable[6], variable[7]) /*MMLocalClass::select_method*/;
  ATTR_typing___AForVardeclExpr____meth_iterator(variable[5]) /*AForVardeclExpr::_meth_iterator*/ = variable[6];
  variable[5] = variable[0];
  variable[5] = ATTR_typing___AForVardeclExpr____meth_iterator(variable[5]) /*AForVardeclExpr::_meth_iterator*/;
  variable[5] = TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[5] = variable[0];
    variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: Collection MUST have an iterate method"), TAG_Int(45)); /*new String*/
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
    goto return_label41;
  }
  variable[6] = variable[0];
  variable[6] = ATTR_typing___AForVardeclExpr____meth_iterator(variable[6]) /*AForVardeclExpr::_meth_iterator*/;
  variable[6] = CALL_static_type___MMLocalProperty___signature_for(variable[6])(variable[6],  variable[4] /*expr_type*/) /*MMLocalProperty::signature_for*/;
  variable[6] = CALL_static_type___MMSignature___return_type(variable[6])(variable[6]) /*MMSignature::return_type*/;
  variable[5] = variable[6];
  variable[6] = variable[0];
  variable[7] = CALL_static_type___MMType___local_class( variable[5] /*iter_type*/)( variable[5] /*iter_type*/) /*MMType::local_class*/;
  if (once_bool_43) variable[8] = once_value_43;
  else {
    variable[8] = NEW_String_string___String___with_native(BOX_NativeString("is_ok"), TAG_Int(5)); /*new String*/
    variable[8] = CALL_symbol___String___to_symbol(variable[8])(variable[8]) /*String::to_symbol*/;
    once_value_43 = variable[8];
    once_bool_43 = true;
  }
  variable[7] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[7])(variable[7], variable[8]) /*MMLocalClass::select_method*/;
  ATTR_typing___AForVardeclExpr____meth_is_ok(variable[6]) /*AForVardeclExpr::_meth_is_ok*/ = variable[7];
  variable[6] = variable[0];
  variable[6] = ATTR_typing___AForVardeclExpr____meth_is_ok(variable[6]) /*AForVardeclExpr::_meth_is_ok*/;
  variable[6] = TAG_Bool((variable[6] ==  NIT_NULL /*null*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = variable[0];
    variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
    variable[9] = variable[8];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
    variable[10] =  variable[5] /*iter_type*/;
    variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[10]) /*AbstractArray::add*/;
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have an is_ok method"), TAG_Int(26)); /*new String*/
    variable[12] = variable[11];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[12]) /*AbstractArray::add*/;
    variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
    goto return_label41;
  }
  variable[6] = variable[0];
  variable[7] = CALL_static_type___MMType___local_class( variable[5] /*iter_type*/)( variable[5] /*iter_type*/) /*MMType::local_class*/;
  if (once_bool_44) variable[8] = once_value_44;
  else {
    variable[8] = NEW_String_string___String___with_native(BOX_NativeString("item"), TAG_Int(4)); /*new String*/
    variable[8] = CALL_symbol___String___to_symbol(variable[8])(variable[8]) /*String::to_symbol*/;
    once_value_44 = variable[8];
    once_bool_44 = true;
  }
  variable[7] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[7])(variable[7], variable[8]) /*MMLocalClass::select_method*/;
  ATTR_typing___AForVardeclExpr____meth_item(variable[6]) /*AForVardeclExpr::_meth_item*/ = variable[7];
  variable[6] = variable[0];
  variable[6] = ATTR_typing___AForVardeclExpr____meth_item(variable[6]) /*AForVardeclExpr::_meth_item*/;
  variable[6] = TAG_Bool((variable[6] ==  NIT_NULL /*null*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = variable[0];
    variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
    variable[9] = variable[8];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
    variable[10] =  variable[5] /*iter_type*/;
    variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[10]) /*AbstractArray::add*/;
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have an item method"), TAG_Int(25)); /*new String*/
    variable[12] = variable[11];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[12]) /*AbstractArray::add*/;
    variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
    goto return_label41;
  }
  variable[6] = variable[0];
  variable[7] = CALL_static_type___MMType___local_class( variable[5] /*iter_type*/)( variable[5] /*iter_type*/) /*MMType::local_class*/;
  if (once_bool_45) variable[8] = once_value_45;
  else {
    variable[8] = NEW_String_string___String___with_native(BOX_NativeString("next"), TAG_Int(4)); /*new String*/
    variable[8] = CALL_symbol___String___to_symbol(variable[8])(variable[8]) /*String::to_symbol*/;
    once_value_45 = variable[8];
    once_bool_45 = true;
  }
  variable[7] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[7])(variable[7], variable[8]) /*MMLocalClass::select_method*/;
  ATTR_typing___AForVardeclExpr____meth_next(variable[6]) /*AForVardeclExpr::_meth_next*/ = variable[7];
  variable[6] = variable[0];
  variable[6] = ATTR_typing___AForVardeclExpr____meth_next(variable[6]) /*AForVardeclExpr::_meth_next*/;
  variable[6] = TAG_Bool((variable[6] ==  NIT_NULL /*null*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = variable[0];
    variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
    variable[9] = variable[8];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
    variable[10] =  variable[5] /*iter_type*/;
    variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[10]) /*AbstractArray::add*/;
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have a next method"), TAG_Int(24)); /*new String*/
    variable[12] = variable[11];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[12]) /*AbstractArray::add*/;
    variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
    goto return_label41;
  }
  variable[7] = variable[0];
  variable[7] = ATTR_typing___AForVardeclExpr____meth_item(variable[7]) /*AForVardeclExpr::_meth_item*/;
  variable[7] = CALL_static_type___MMLocalProperty___signature_for(variable[7])(variable[7],  variable[5] /*iter_type*/) /*MMLocalProperty::signature_for*/;
  variable[7] = CALL_static_type___MMSignature___return_type(variable[7])(variable[7]) /*MMSignature::return_type*/;
  variable[6] = variable[7];
  variable[7] = variable[0];
  variable[7] = CALL_parser_nodes___AForVardeclExpr___n_expr(variable[7])(variable[7]) /*AForVardeclExpr::n_expr*/;
  variable[7] = CALL_typing___PExpr___is_self(variable[7])(variable[7]) /*PExpr::is_self*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[7])))) { /*if*/
    variable[7] = CALL_static_type___MMType___not_for_self( variable[6] /*t*/)( variable[6] /*t*/) /*MMType::not_for_self*/;
    variable[6] = variable[7] /*t=*/;
  }
  CALL_syntax_base___Variable___stype__eq( variable[3] /*va*/)( variable[3] /*va*/,  variable[6] /*t*/) /*Variable::stype=*/;
  return_label41: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AForVardeclExpr___meth_iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 464, LOCATE_typing___AForVardeclExpr___meth_iterator};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForVardeclExpr____meth_iterator( self) /*AForVardeclExpr::_meth_iterator*/;
}
val_t typing___AForVardeclExpr___meth_is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 465, LOCATE_typing___AForVardeclExpr___meth_is_ok};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForVardeclExpr____meth_is_ok( self) /*AForVardeclExpr::_meth_is_ok*/;
}
val_t typing___AForVardeclExpr___meth_item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 466, LOCATE_typing___AForVardeclExpr___meth_item};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForVardeclExpr____meth_item( self) /*AForVardeclExpr::_meth_item*/;
}
val_t typing___AForVardeclExpr___meth_next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 467, LOCATE_typing___AForVardeclExpr___meth_next};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForVardeclExpr____meth_next( self) /*AForVardeclExpr::_meth_next*/;
}
void typing___AAssertExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 507, LOCATE_typing___AAssertExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AAssertExpr___n_expr(variable[3])(variable[3]) /*AAssertExpr::n_expr*/;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AAssertExpr___n_expr(variable[3])(variable[3]) /*AAssertExpr::n_expr*/;
  variable[3] = CALL_typing___PExpr___if_true_variable_ctx(variable[3])(variable[3]) /*PExpr::if_true_variable_ctx*/;
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[3] = CALL_parser_nodes___AAssertExpr___n_expr(variable[3])(variable[3]) /*AAssertExpr::n_expr*/;
    variable[3] = CALL_typing___PExpr___if_true_variable_ctx(variable[3])(variable[3]) /*PExpr::if_true_variable_ctx*/;
    CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::variable_ctx=*/;
  }
  return_label46: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AVarExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 517, LOCATE_typing___AVarExpr___after_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[5] = variable[0];
  variable[5] = CALL_syntax_base___AVarFormExpr___variable(variable[5])(variable[5]) /*AVarFormExpr::variable*/;
  variable[4] = CALL_typing___VariableContext___stype(variable[4])(variable[4], variable[5]) /*VariableContext::stype*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label47: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AVarExpr___its_variable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 515, LOCATE_typing___AVarExpr___its_variable};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_syntax_base___AVarFormExpr___variable(variable[2])(variable[2]) /*AVarFormExpr::variable*/;
  variable[1] = variable[2];
  goto return_label48;
  return_label48: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___AVarAssignExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 524, LOCATE_typing___AVarAssignExpr___after_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[5] = variable[0];
  variable[5] = CALL_syntax_base___AVarFormExpr___variable(variable[5])(variable[5]) /*AVarFormExpr::variable*/;
  variable[4] = CALL_typing___VariableContext___stype(variable[4])(variable[4], variable[5]) /*VariableContext::stype*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[4])(variable[4]) /*AAssignFormExpr::n_value*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4],  variable[3] /*t*/) /*AbsSyntaxVisitor::check_conform_expr*/;
  return_label49: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AReassignFormExpr___do_lvalue_typing(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 532, LOCATE_typing___AReassignFormExpr___do_lvalue_typing};
  val_t variable[16];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = TAG_Bool(( variable[2] /*type_lvalue*/ ==  NIT_NULL /*null*/) || (( variable[2] /*type_lvalue*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[2] /*type_lvalue*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[2] /*type_lvalue*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[2] /*type_lvalue*/)( variable[2] /*type_lvalue*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label50;
  }
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___AReassignFormExpr___n_assign_op(variable[5])(variable[5]) /*AReassignFormExpr::n_assign_op*/;
  variable[5] = CALL_typing___PAssignOp___method_name(variable[5])(variable[5]) /*PAssignOp::method_name*/;
  variable[4] = variable[5];
  variable[6] = CALL_static_type___MMType___local_class( variable[2] /*type_lvalue*/)( variable[2] /*type_lvalue*/) /*MMType::local_class*/;
  variable[6] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[6])(variable[6],  variable[4] /*name*/) /*MMLocalClass::select_method*/;
  variable[5] = variable[6];
  variable[6] = TAG_Bool(( variable[5] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[5] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*prop*/)( variable[5] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = variable[0];
    variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
    variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: Method '"), TAG_Int(15)); /*new String*/
    variable[9] = variable[8];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
    variable[10] =  variable[4] /*name*/;
    variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[10]) /*AbstractArray::add*/;
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString("' doesn't exists in "), TAG_Int(20)); /*new String*/
    variable[12] = variable[11];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[12]) /*AbstractArray::add*/;
    variable[13] =  variable[2] /*type_lvalue*/;
    variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[13]) /*AbstractArray::add*/;
    variable[14] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
    variable[15] = variable[14];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[15]) /*AbstractArray::add*/;
    variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
    goto return_label50;
  }
  variable[6] = CALL_abstractmetamodel___MMLocalProperty___global( variable[5] /*prop*/)( variable[5] /*prop*/) /*MMLocalProperty::global*/;
  variable[7] = variable[0];
  variable[8] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
  CALL_syntax_base___MMGlobalProperty___check_visibility(variable[6])(variable[6],  variable[1] /*v*/, variable[7], variable[8],  TAG_Bool(false)) /*MMGlobalProperty::check_visibility*/;
  variable[7] = CALL_static_type___MMLocalProperty___signature_for( variable[5] /*prop*/)( variable[5] /*prop*/,  variable[2] /*type_lvalue*/) /*MMLocalProperty::signature_for*/;
  variable[6] = variable[7];
  variable[7] = variable[0];
  ATTR_typing___AReassignFormExpr____assign_method(variable[7]) /*AReassignFormExpr::_assign_method*/ =  variable[5] /*prop*/;
  variable[7] = variable[0];
  variable[7] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[7])(variable[7]) /*AReassignFormExpr::n_value*/;
  variable[8] = CALL_static_type___MMSignature_____bra( variable[6] /*psig*/)( variable[6] /*psig*/,  TAG_Int(0)) /*MMSignature::[]*/;
  variable[8] = CALL_static_type___MMType___not_for_self(variable[8])(variable[8]) /*MMType::not_for_self*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[7], variable[8]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[7] = variable[0];
  variable[8] = CALL_static_type___MMSignature___return_type( variable[6] /*psig*/)( variable[6] /*psig*/) /*MMSignature::return_type*/;
  variable[8] = CALL_static_type___MMType___not_for_self(variable[8])(variable[8]) /*MMType::not_for_self*/;
  variable[9] = variable[0];
  variable[9] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[9])(variable[9]) /*AReassignFormExpr::n_value*/;
  variable[9] = CALL_syntax_base___PExpr___stype(variable[9])(variable[9]) /*PExpr::stype*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform( variable[1] /*v*/)( variable[1] /*v*/, variable[7], variable[8], variable[9]) /*AbsSyntaxVisitor::check_conform*/;
  return_label50: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AReassignFormExpr___assign_method(val_t  self) {
  struct trace_t trace = {NULL, NULL, 551, LOCATE_typing___AReassignFormExpr___assign_method};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AReassignFormExpr____assign_method( self) /*AReassignFormExpr::_assign_method*/;
}
void typing___AVarReassignExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 556, LOCATE_typing___AVarReassignExpr___after_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[5] = variable[0];
  variable[5] = CALL_syntax_base___AVarFormExpr___variable(variable[5])(variable[5]) /*AVarFormExpr::variable*/;
  variable[4] = CALL_typing___VariableContext___stype(variable[4])(variable[4], variable[5]) /*VariableContext::stype*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  CALL_typing___AReassignFormExpr___do_lvalue_typing(variable[4])(variable[4],  variable[1] /*v*/,  variable[3] /*t*/) /*AReassignFormExpr::do_lvalue_typing*/;
  return_label51: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___PAssignOp___method_name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 564, LOCATE_typing___PAssignOp___method_name};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 564);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t typing___APlusAssignOp___method_name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 567, LOCATE_typing___APlusAssignOp___method_name};
  static val_t once_value_53; static int once_bool_53; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_53) variable[2] = once_value_53;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("+"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_53 = variable[2];
    once_bool_53 = true;
  }
  variable[1] = variable[2];
  goto return_label52;
  return_label52: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AMinusAssignOp___method_name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 570, LOCATE_typing___AMinusAssignOp___method_name};
  static val_t once_value_55; static int once_bool_55; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_55) variable[2] = once_value_55;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("-"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_55 = variable[2];
    once_bool_55 = true;
  }
  variable[1] = variable[2];
  goto return_label54;
  return_label54: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___ASelfExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 576, LOCATE_typing___ASelfExpr___after_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
  CALL_syntax_base___ASelfExpr___variable__eq(variable[3])(variable[3], variable[4]) /*ASelfExpr::variable=*/;
  variable[3] = variable[0];
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[5] = variable[0];
  variable[5] = CALL_syntax_base___ASelfExpr___variable(variable[5])(variable[5]) /*ASelfExpr::variable*/;
  variable[4] = CALL_typing___VariableContext___stype(variable[4])(variable[4], variable[5]) /*VariableContext::stype*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label56: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASelfExpr___is_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 582, LOCATE_typing___ASelfExpr___is_self};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  TAG_Bool(true);
  goto return_label57;
  return_label57: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ASelfExpr___its_variable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 574, LOCATE_typing___ASelfExpr___its_variable};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_syntax_base___ASelfExpr___variable(variable[2])(variable[2]) /*ASelfExpr::variable*/;
  variable[1] = variable[2];
  goto return_label58;
  return_label58: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AImplicitSelfExpr___is_implicit_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 586, LOCATE_typing___AImplicitSelfExpr___is_implicit_self};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  TAG_Bool(true);
  goto return_label59;
  return_label59: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___AIfexprExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 590, LOCATE_typing___AIfexprExpr___accept_typing};
  val_t variable[16];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_expr(variable[4])(variable[4]) /*AIfexprExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_expr(variable[4])(variable[4]) /*AIfexprExpr::n_expr*/;
  variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AIfexprExpr___n_expr(variable[4])(variable[4]) /*AIfexprExpr::n_expr*/;
    variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
    CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::variable_ctx=*/;
  }
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_then(variable[4])(variable[4]) /*AIfexprExpr::n_then*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_else(variable[4])(variable[4]) /*AIfexprExpr::n_else*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_expr(variable[4])(variable[4]) /*AIfexprExpr::n_expr*/;
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_then(variable[4])(variable[4]) /*AIfexprExpr::n_then*/;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*AbsSyntaxVisitor::check_expr*/;
  variable[4] =  TAG_Bool(!UNTAG_Bool(variable[4]));
  if (!UNTAG_Bool(variable[4])) { /* or */
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AIfexprExpr___n_else(variable[4])(variable[4]) /*AIfexprExpr::n_else*/;
    variable[4] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*AbsSyntaxVisitor::check_expr*/;
    variable[4] =  TAG_Bool(!UNTAG_Bool(variable[4]));
  }
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label60;
  }
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___AIfexprExpr___n_then(variable[5])(variable[5]) /*AIfexprExpr::n_then*/;
  variable[5] = CALL_syntax_base___PExpr___stype(variable[5])(variable[5]) /*PExpr::stype*/;
  variable[4] = variable[5];
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___AIfexprExpr___n_else(variable[6])(variable[6]) /*AIfexprExpr::n_else*/;
  variable[6] = CALL_syntax_base___PExpr___stype(variable[6])(variable[6]) /*PExpr::stype*/;
  variable[5] = variable[6];
  variable[6] = CALL_static_type___MMType_____l( variable[4] /*t*/)( variable[4] /*t*/,  variable[5] /*te*/) /*MMType::<*/;
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[4] =  variable[5] /*te*/ /*t=*/;
  } else { /*if*/
    variable[6] = CALL_static_type___MMType_____l( variable[5] /*te*/)( variable[5] /*te*/,  variable[4] /*t*/) /*MMType::<*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
      variable[6] = variable[0];
      variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Type error: "), TAG_Int(12)); /*new String*/
      variable[9] = variable[8];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
      variable[10] =  variable[5] /*te*/;
      variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[10]) /*AbstractArray::add*/;
      variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" is not a subtype of "), TAG_Int(21)); /*new String*/
      variable[12] = variable[11];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[12]) /*AbstractArray::add*/;
      variable[13] =  variable[4] /*t*/;
      variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[13]) /*AbstractArray::add*/;
      variable[14] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
      variable[15] = variable[14];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[15]) /*AbstractArray::add*/;
      variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
      goto return_label60;
    }
  }
  variable[6] = variable[0];
  ATTR_typing___PExpr____stype(variable[6]) /*PExpr::_stype*/ =  variable[4] /*t*/;
  return_label60: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ABoolExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 618, LOCATE_typing___ABoolExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label61: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AOrExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 625, LOCATE_typing___AOrExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AOrExpr___n_expr(variable[3])(variable[3]) /*AOrExpr::n_expr*/;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AOrExpr___n_expr2(variable[3])(variable[3]) /*AOrExpr::n_expr2*/;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label62: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAndExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 634, LOCATE_typing___AAndExpr___accept_typing};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr(variable[4])(variable[4]) /*AAndExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr(variable[4])(variable[4]) /*AAndExpr::n_expr*/;
  variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___AAndExpr___n_expr(variable[4])(variable[4]) /*AAndExpr::n_expr*/;
    variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
    CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::variable_ctx=*/;
  }
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr2(variable[4])(variable[4]) /*AAndExpr::n_expr2*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr2(variable[4])(variable[4]) /*AAndExpr::n_expr2*/;
  variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = variable[0];
    variable[5] = CALL_parser_nodes___AAndExpr___n_expr2(variable[5])(variable[5]) /*AAndExpr::n_expr2*/;
    variable[5] = CALL_typing___PExpr___if_true_variable_ctx(variable[5])(variable[5]) /*PExpr::if_true_variable_ctx*/;
    ATTR_typing___PExpr____if_true_variable_ctx(variable[4]) /*PExpr::_if_true_variable_ctx*/ = variable[5];
  } else { /*if*/
    variable[4] = variable[0];
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    ATTR_typing___PExpr____if_true_variable_ctx(variable[4]) /*PExpr::_if_true_variable_ctx*/ = variable[5];
  }
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr(variable[4])(variable[4]) /*AAndExpr::n_expr*/;
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr2(variable[4])(variable[4]) /*AAndExpr::n_expr2*/;
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[4] = variable[0];
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[4]) /*PExpr::_stype*/ = variable[5];
  return_label63: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ANotExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 657, LOCATE_typing___ANotExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ANotExpr___n_expr(variable[3])(variable[3]) /*ANotExpr::n_expr*/;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label64: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AIntExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 665, LOCATE_typing___AIntExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_int( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_int*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label65: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AFloatExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 673, LOCATE_typing___AFloatExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_float( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_float*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label66: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ACharExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 680, LOCATE_typing___ACharExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_char( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_char*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label67: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AStringFormExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 688, LOCATE_typing___AStringFormExpr___after_typing};
  static val_t once_value_69; static int once_bool_69; /* Once value for variable[5]*/
  val_t variable[11];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_string( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_string*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = ATTR_typing___PExpr____stype(variable[4]) /*PExpr::_stype*/;
  variable[4] = CALL_static_type___MMType___local_class(variable[4])(variable[4]) /*MMType::local_class*/;
  if (once_bool_69) variable[5] = once_value_69;
  else {
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString("with_native"), TAG_Int(11)); /*new String*/
    variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
    once_value_69 = variable[5];
    once_bool_69 = true;
  }
  variable[4] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[4])(variable[4], variable[5]) /*MMLocalClass::select_method*/;
  ATTR_typing___AStringFormExpr____meth_with_native(variable[3]) /*AStringFormExpr::_meth_with_native*/ = variable[4];
  variable[3] = variable[0];
  variable[3] = ATTR_typing___AStringFormExpr____meth_with_native(variable[3]) /*AStringFormExpr::_meth_with_native*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[6] = variable[5];
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[6]) /*AbstractArray::add*/;
    variable[7] = variable[0];
    variable[7] = ATTR_typing___PExpr____stype(variable[7]) /*PExpr::_stype*/;
    variable[8] = variable[7];
    variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[8]) /*AbstractArray::add*/;
    variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have a with_native method."), TAG_Int(32)); /*new String*/
    variable[10] = variable[9];
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[10]) /*AbstractArray::add*/;
    variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::error*/;
  }
  return_label68: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AStringFormExpr___meth_with_native(val_t  self) {
  struct trace_t trace = {NULL, NULL, 687, LOCATE_typing___AStringFormExpr___meth_with_native};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AStringFormExpr____meth_with_native( self) /*AStringFormExpr::_meth_with_native*/;
}
void typing___ASuperstringExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 701, LOCATE_typing___ASuperstringExpr___after_typing};
  static val_t once_value_71; static int once_bool_71; /* Once value for variable[5]*/
  static val_t once_value_72; static int once_bool_72; /* Once value for variable[5]*/
  static val_t once_value_73; static int once_bool_73; /* Once value for variable[5]*/
  val_t variable[11];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_string( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_string*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = ATTR_typing___PExpr____stype(variable[4]) /*PExpr::_stype*/;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_array( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*AbsSyntaxVisitor::type_array*/;
  ATTR_typing___ASuperstringExpr____atype(variable[3]) /*ASuperstringExpr::_atype*/ = variable[4];
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = ATTR_typing___ASuperstringExpr____atype(variable[4]) /*ASuperstringExpr::_atype*/;
  variable[4] = CALL_static_type___MMType___local_class(variable[4])(variable[4]) /*MMType::local_class*/;
  if (once_bool_71) variable[5] = once_value_71;
  else {
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString("with_capacity"), TAG_Int(13)); /*new String*/
    variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
    once_value_71 = variable[5];
    once_bool_71 = true;
  }
  variable[4] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[4])(variable[4], variable[5]) /*MMLocalClass::select_method*/;
  ATTR_typing___ASuperstringExpr____meth_with_capacity(variable[3]) /*ASuperstringExpr::_meth_with_capacity*/ = variable[4];
  variable[3] = variable[0];
  variable[3] = ATTR_typing___ASuperstringExpr____meth_with_capacity(variable[3]) /*ASuperstringExpr::_meth_with_capacity*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[6] = variable[5];
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[6]) /*AbstractArray::add*/;
    variable[7] = variable[0];
    variable[7] = ATTR_typing___ASuperstringExpr____atype(variable[7]) /*ASuperstringExpr::_atype*/;
    variable[8] = variable[7];
    variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[8]) /*AbstractArray::add*/;
    variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have a with_capacity method."), TAG_Int(34)); /*new String*/
    variable[10] = variable[9];
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[10]) /*AbstractArray::add*/;
    variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::error*/;
  }
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = ATTR_typing___ASuperstringExpr____atype(variable[4]) /*ASuperstringExpr::_atype*/;
  variable[4] = CALL_static_type___MMType___local_class(variable[4])(variable[4]) /*MMType::local_class*/;
  if (once_bool_72) variable[5] = once_value_72;
  else {
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString("add"), TAG_Int(3)); /*new String*/
    variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
    once_value_72 = variable[5];
    once_bool_72 = true;
  }
  variable[4] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[4])(variable[4], variable[5]) /*MMLocalClass::select_method*/;
  ATTR_typing___ASuperstringExpr____meth_add(variable[3]) /*ASuperstringExpr::_meth_add*/ = variable[4];
  variable[3] = variable[0];
  variable[3] = ATTR_typing___ASuperstringExpr____meth_add(variable[3]) /*ASuperstringExpr::_meth_add*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[6] = variable[5];
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[6]) /*AbstractArray::add*/;
    variable[7] = variable[0];
    variable[7] = ATTR_typing___ASuperstringExpr____atype(variable[7]) /*ASuperstringExpr::_atype*/;
    variable[8] = variable[7];
    variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[8]) /*AbstractArray::add*/;
    variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have an add method."), TAG_Int(25)); /*new String*/
    variable[10] = variable[9];
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[10]) /*AbstractArray::add*/;
    variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::error*/;
  }
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_object( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_object*/;
  variable[4] = CALL_static_type___MMType___local_class(variable[4])(variable[4]) /*MMType::local_class*/;
  if (once_bool_73) variable[5] = once_value_73;
  else {
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString("to_s"), TAG_Int(4)); /*new String*/
    variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
    once_value_73 = variable[5];
    once_bool_73 = true;
  }
  variable[4] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[4])(variable[4], variable[5]) /*MMLocalClass::select_method*/;
  ATTR_typing___ASuperstringExpr____meth_to_s(variable[3]) /*ASuperstringExpr::_meth_to_s*/ = variable[4];
  variable[3] = variable[0];
  variable[3] = ATTR_typing___ASuperstringExpr____meth_to_s(variable[3]) /*ASuperstringExpr::_meth_to_s*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[4] = NEW_String_string___String___with_native(BOX_NativeString("Object MUST have a to_s method."), TAG_Int(31)); /*new String*/
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::error*/;
  }
  return_label70: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASuperstringExpr___meth_with_capacity(val_t  self) {
  struct trace_t trace = {NULL, NULL, 697, LOCATE_typing___ASuperstringExpr___meth_with_capacity};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperstringExpr____meth_with_capacity( self) /*ASuperstringExpr::_meth_with_capacity*/;
}
val_t typing___ASuperstringExpr___meth_add(val_t  self) {
  struct trace_t trace = {NULL, NULL, 698, LOCATE_typing___ASuperstringExpr___meth_add};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperstringExpr____meth_add( self) /*ASuperstringExpr::_meth_add*/;
}
val_t typing___ASuperstringExpr___meth_to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 699, LOCATE_typing___ASuperstringExpr___meth_to_s};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperstringExpr____meth_to_s( self) /*ASuperstringExpr::_meth_to_s*/;
}
val_t typing___ASuperstringExpr___atype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 700, LOCATE_typing___ASuperstringExpr___atype};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperstringExpr____atype( self) /*ASuperstringExpr::_atype*/;
}
void typing___ANullExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 715, LOCATE_typing___ANullExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_none( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_none*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label74: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AArrayExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 725, LOCATE_typing___AArrayExpr___after_typing};
  val_t variable[11];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] =  NIT_NULL /*null*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AArrayExpr___n_exprs(variable[4])(variable[4]) /*AArrayExpr::n_exprs*/;
  variable[4] = CALL_abstract_collection___Collection___iterator(variable[4])(variable[4]) /*List::iterator*/;
  while (true) { /*for*/
    variable[5] = CALL_abstract_collection___Iterator___is_ok(variable[4])(variable[4]) /*ListIterator::is_ok*/;
    if (!UNTAG_Bool(variable[5])) break; /*for*/
    variable[5] = CALL_abstract_collection___Iterator___item(variable[4])(variable[4]) /*ListIterator::item*/;
    variable[6] = variable[5];
    variable[8] = CALL_syntax_base___PExpr___stype( variable[6] /*n*/)( variable[6] /*n*/) /*PExpr::stype*/;
    variable[7] = variable[8];
    variable[8] = TAG_Bool(( variable[3] /*stype*/ ==  NIT_NULL /*null*/) || (( variable[3] /*stype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*stype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*stype*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*stype*/)( variable[3] /*stype*/,  NIT_NULL /*null*/) /*Object::==*/)))));
    variable[9] = variable[8];
    if (!UNTAG_Bool(variable[9])) { /* or */
      variable[9] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[7] /*ntype*/ ==  NIT_NULL /*null*/) || (( variable[7] /*ntype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[7] /*ntype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[7] /*ntype*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[7] /*ntype*/)( variable[7] /*ntype*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
      variable[10] = variable[9];
      if (UNTAG_Bool(variable[10])) { /* and */
        variable[10] = CALL_static_type___MMType_____l( variable[3] /*stype*/)( variable[3] /*stype*/,  variable[7] /*ntype*/) /*MMType::<*/;
      }
      variable[9] = variable[10];
    }
    variable[8] = variable[9];
    if (UNTAG_Bool(variable[8])) { /*if*/
      variable[3] =  variable[7] /*ntype*/ /*stype=*/;
    }
    continue_76: while(0);
    CALL_abstract_collection___Iterator___next(variable[4])(variable[4]) /*ListIterator::next*/;
  }
  break_76: while(0);
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AArrayExpr___n_exprs(variable[4])(variable[4]) /*AArrayExpr::n_exprs*/;
  variable[4] = CALL_abstract_collection___Collection___iterator(variable[4])(variable[4]) /*List::iterator*/;
  while (true) { /*for*/
    variable[5] = CALL_abstract_collection___Iterator___is_ok(variable[4])(variable[4]) /*ListIterator::is_ok*/;
    if (!UNTAG_Bool(variable[5])) break; /*for*/
    variable[5] = CALL_abstract_collection___Iterator___item(variable[4])(variable[4]) /*ListIterator::item*/;
    variable[6] = variable[5];
    CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/,  variable[6] /*n*/,  variable[3] /*stype*/) /*AbsSyntaxVisitor::check_conform_expr*/;
    continue_77: while(0);
    CALL_abstract_collection___Iterator___next(variable[4])(variable[4]) /*ListIterator::next*/;
  }
  break_77: while(0);
  variable[4] = variable[0];
  CALL_typing___AArrayExpr___do_typing(variable[4])(variable[4],  variable[1] /*v*/,  variable[3] /*stype*/) /*AArrayExpr::do_typing*/;
  return_label75: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AArrayExpr___meth_with_capacity(val_t  self) {
  struct trace_t trace = {NULL, NULL, 722, LOCATE_typing___AArrayExpr___meth_with_capacity};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AArrayExpr____meth_with_capacity( self) /*AArrayExpr::_meth_with_capacity*/;
}
val_t typing___AArrayExpr___meth_add(val_t  self) {
  struct trace_t trace = {NULL, NULL, 723, LOCATE_typing___AArrayExpr___meth_add};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AArrayExpr____meth_add( self) /*AArrayExpr::_meth_add*/;
}
void typing___AArrayExpr___do_typing(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 740, LOCATE_typing___AArrayExpr___do_typing};
  static val_t once_value_79; static int once_bool_79; /* Once value for variable[6]*/
  static val_t once_value_80; static int once_bool_80; /* Once value for variable[6]*/
  val_t variable[12];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = variable[0];
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_array( variable[1] /*v*/)( variable[1] /*v*/,  variable[2] /*element_type*/) /*AbsSyntaxVisitor::type_array*/;
  ATTR_typing___PExpr____stype(variable[4]) /*PExpr::_stype*/ = variable[5];
  variable[4] = variable[0];
  variable[5] = variable[0];
  variable[5] = ATTR_typing___PExpr____stype(variable[5]) /*PExpr::_stype*/;
  variable[5] = CALL_static_type___MMType___local_class(variable[5])(variable[5]) /*MMType::local_class*/;
  if (once_bool_79) variable[6] = once_value_79;
  else {
    variable[6] = NEW_String_string___String___with_native(BOX_NativeString("with_capacity"), TAG_Int(13)); /*new String*/
    variable[6] = CALL_symbol___String___to_symbol(variable[6])(variable[6]) /*String::to_symbol*/;
    once_value_79 = variable[6];
    once_bool_79 = true;
  }
  variable[5] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[5])(variable[5], variable[6]) /*MMLocalClass::select_method*/;
  ATTR_typing___AArrayExpr____meth_with_capacity(variable[4]) /*AArrayExpr::_meth_with_capacity*/ = variable[5];
  variable[4] = variable[0];
  variable[4] = ATTR_typing___AArrayExpr____meth_with_capacity(variable[4]) /*AArrayExpr::_meth_with_capacity*/;
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[6] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[7] = variable[6];
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[7]) /*AbstractArray::add*/;
    variable[8] = variable[0];
    variable[8] = ATTR_typing___PExpr____stype(variable[8]) /*PExpr::_stype*/;
    variable[9] = variable[8];
    variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[9]) /*AbstractArray::add*/;
    variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have a with_capacity method."), TAG_Int(34)); /*new String*/
    variable[11] = variable[10];
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[11]) /*AbstractArray::add*/;
    variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
  }
  variable[4] = variable[0];
  variable[5] = variable[0];
  variable[5] = ATTR_typing___PExpr____stype(variable[5]) /*PExpr::_stype*/;
  variable[5] = CALL_static_type___MMType___local_class(variable[5])(variable[5]) /*MMType::local_class*/;
  if (once_bool_80) variable[6] = once_value_80;
  else {
    variable[6] = NEW_String_string___String___with_native(BOX_NativeString("add"), TAG_Int(3)); /*new String*/
    variable[6] = CALL_symbol___String___to_symbol(variable[6])(variable[6]) /*String::to_symbol*/;
    once_value_80 = variable[6];
    once_bool_80 = true;
  }
  variable[5] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[5])(variable[5], variable[6]) /*MMLocalClass::select_method*/;
  ATTR_typing___AArrayExpr____meth_add(variable[4]) /*AArrayExpr::_meth_add*/ = variable[5];
  variable[4] = variable[0];
  variable[4] = ATTR_typing___AArrayExpr____meth_add(variable[4]) /*AArrayExpr::_meth_add*/;
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[6] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[7] = variable[6];
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[7]) /*AbstractArray::add*/;
    variable[8] = variable[0];
    variable[8] = ATTR_typing___PExpr____stype(variable[8]) /*PExpr::_stype*/;
    variable[9] = variable[8];
    variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[9]) /*AbstractArray::add*/;
    variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have an add method."), TAG_Int(25)); /*new String*/
    variable[11] = variable[10];
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[11]) /*AbstractArray::add*/;
    variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
  }
  return_label78: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ARangeExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 753, LOCATE_typing___ARangeExpr___after_typing};
  val_t variable[15];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___ARangeExpr___n_expr(variable[4])(variable[4]) /*ARangeExpr::n_expr*/;
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  variable[3] = variable[4];
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___ARangeExpr___n_expr2(variable[5])(variable[5]) /*ARangeExpr::n_expr2*/;
  variable[5] = CALL_syntax_base___PExpr___stype(variable[5])(variable[5]) /*PExpr::stype*/;
  variable[4] = variable[5];
  variable[5] = TAG_Bool(( variable[3] /*ntype*/ ==  NIT_NULL /*null*/) || (( variable[3] /*ntype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*ntype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*ntype*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*ntype*/)( variable[3] /*ntype*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  variable[6] = variable[5];
  if (!UNTAG_Bool(variable[6])) { /* or */
    variable[6] = TAG_Bool(( variable[3] /*ntype*/ ==  NIT_NULL /*null*/) || (( variable[3] /*ntype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*ntype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*ntype*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*ntype*/)( variable[3] /*ntype*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  }
  variable[5] = variable[6];
  if (UNTAG_Bool(variable[5])) { /*if*/
    goto return_label81;
  }
  variable[5] = CALL_static_type___MMType_____l( variable[3] /*ntype*/)( variable[3] /*ntype*/,  variable[4] /*ntype2*/) /*MMType::<*/;
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[3] =  variable[4] /*ntype2*/ /*ntype=*/;
  } else { /*if*/
    variable[5] = CALL_static_type___MMType_____l( variable[4] /*ntype2*/)( variable[4] /*ntype2*/,  variable[3] /*ntype*/) /*MMType::<*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
      variable[5] = variable[0];
      variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
      variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Type error: "), TAG_Int(12)); /*new String*/
      variable[8] = variable[7];
      CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[8]) /*AbstractArray::add*/;
      variable[9] =  variable[3] /*ntype*/;
      variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[9]) /*AbstractArray::add*/;
      variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" incompatible with "), TAG_Int(19)); /*new String*/
      variable[11] = variable[10];
      CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[11]) /*AbstractArray::add*/;
      variable[12] =  variable[4] /*ntype2*/;
      variable[12] = CALL_string___Object___to_s(variable[12])(variable[12]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[12]) /*AbstractArray::add*/;
      variable[13] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
      variable[14] = variable[13];
      CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[14]) /*AbstractArray::add*/;
      variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
      goto return_label81;
    }
  }
  variable[6] = CALL_syntax_base___AbsSyntaxVisitor___type_discrete( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_discrete*/;
  variable[5] = variable[6];
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___ARangeExpr___n_expr(variable[6])(variable[6]) /*ARangeExpr::n_expr*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[6],  variable[5] /*dtype*/) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___ARangeExpr___n_expr2(variable[6])(variable[6]) /*ARangeExpr::n_expr2*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[6],  variable[5] /*dtype*/) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[6] = variable[0];
  variable[7] = CALL_syntax_base___AbsSyntaxVisitor___type_range( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*ntype*/) /*AbsSyntaxVisitor::type_range*/;
  ATTR_typing___PExpr____stype(variable[6]) /*PExpr::_stype*/ = variable[7];
  return_label81: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ARangeExpr___meth_init(val_t  self) {
  struct trace_t trace = {NULL, NULL, 752, LOCATE_typing___ARangeExpr___meth_init};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ARangeExpr____meth_init( self) /*ARangeExpr::_meth_init*/;
}
void typing___ACrangeExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 774, LOCATE_typing___ACrangeExpr___after_typing};
  static val_t once_value_83; static int once_bool_83; /* Once value for variable[5]*/
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  CALL_SUPER_typing___ACrangeExpr___after_typing(variable[0])(variable[0], variable[1]) /*super ACrangeExpr::after_typing*/;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  variable[4] = CALL_static_type___MMType___local_class(variable[4])(variable[4]) /*MMType::local_class*/;
  if (once_bool_83) variable[5] = once_value_83;
  else {
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString("init"), TAG_Int(4)); /*new String*/
    variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
    once_value_83 = variable[5];
    once_bool_83 = true;
  }
  variable[4] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[4])(variable[4], variable[5]) /*MMLocalClass::select_method*/;
  ATTR_typing___ARangeExpr____meth_init(variable[3]) /*ARangeExpr::_meth_init*/ = variable[4];
  return_label82: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AOrangeExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 781, LOCATE_typing___AOrangeExpr___after_typing};
  static val_t once_value_85; static int once_bool_85; /* Once value for variable[5]*/
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  CALL_SUPER_typing___AOrangeExpr___after_typing(variable[0])(variable[0], variable[1]) /*super AOrangeExpr::after_typing*/;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  variable[4] = CALL_static_type___MMType___local_class(variable[4])(variable[4]) /*MMType::local_class*/;
  if (once_bool_85) variable[5] = once_value_85;
  else {
    variable[5] = NEW_String_string___String___with_native(BOX_NativeString("without_last"), TAG_Int(12)); /*new String*/
    variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
    once_value_85 = variable[5];
    once_bool_85 = true;
  }
  variable[4] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[4])(variable[4], variable[5]) /*MMLocalClass::select_method*/;
  ATTR_typing___ARangeExpr____meth_init(variable[3]) /*ARangeExpr::_meth_init*/ = variable[4];
  return_label84: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ASuperExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 793, LOCATE_typing___ASuperExpr___after_typing};
  val_t variable[19];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
  variable[4] = CALL_abstractmetamodel___MMLocalProperty___prhe(variable[4])(variable[4]) /*MMLocalProperty::prhe*/;
  variable[4] = CALL_partial_order___PartialOrderElement___direct_greaters(variable[4])(variable[4]) /*PartialOrderElement::direct_greaters*/;
  variable[3] = variable[4];
  variable[4] = CALL_abstract_collection___Collection___is_empty( variable[3] /*precs*/)( variable[3] /*precs*/) /*AbstractArray::is_empty*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[4])))) { /*if*/
    variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    CALL_abstractmetamodel___MMLocalProperty___need_super__eq(variable[4])(variable[4],  TAG_Bool(true)) /*MMLocalProperty::need_super=*/;
  } else { /*if*/
    variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    variable[4] = CALL_abstractmetamodel___MMLocalProperty___global(variable[4])(variable[4]) /*MMLocalProperty::global*/;
    variable[4] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[4])(variable[4]) /*MMGlobalProperty::is_init*/;
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[5] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
      variable[6] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
      variable[6] = CALL_abstractmetamodel___MMLocalProperty___name(variable[6])(variable[6]) /*MMLocalProperty::name*/;
      variable[5] = CALL_abstractmetamodel___MMLocalClass___super_methods_named(variable[5])(variable[5], variable[6]) /*MMLocalClass::super_methods_named*/;
      variable[4] = variable[5];
      variable[5] = CALL_abstract_collection___Collection___iterator( variable[4] /*base_precs*/)( variable[4] /*base_precs*/) /*AbstractArray::iterator*/;
      while (true) { /*for*/
        variable[6] = CALL_abstract_collection___Iterator___is_ok(variable[5])(variable[5]) /*ArrayIterator::is_ok*/;
        if (!UNTAG_Bool(variable[6])) break; /*for*/
        variable[6] = CALL_abstract_collection___Iterator___item(variable[5])(variable[5]) /*ArrayIterator::item*/;
        variable[7] = variable[6];
        variable[8] = CALL_abstractmetamodel___MMLocalProperty___global( variable[7] /*p*/)( variable[7] /*p*/) /*MMLocalProperty::global*/;
        variable[8] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[8])(variable[8]) /*MMGlobalProperty::is_init*/;
        if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[8])))) { /*if*/
          variable[8] = variable[0];
          variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
          variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
          variable[11] = variable[10];
          CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[11]) /*AbstractArray::add*/;
          variable[12] = CALL_abstractmetamodel___MMLocalProperty___local_class( variable[7] /*p*/)( variable[7] /*p*/) /*MMLocalProperty::local_class*/;
          variable[13] = variable[12];
          variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
          CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[13]) /*AbstractArray::add*/;
          variable[14] = NEW_String_string___String___with_native(BOX_NativeString("::"), TAG_Int(2)); /*new String*/
          variable[15] = variable[14];
          CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[15]) /*AbstractArray::add*/;
          variable[16] =  variable[7] /*p*/;
          variable[16] = CALL_string___Object___to_s(variable[16])(variable[16]) /*Object::to_s*/;
          CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[16]) /*AbstractArray::add*/;
          variable[17] = NEW_String_string___String___with_native(BOX_NativeString(" is not a constructor."), TAG_Int(22)); /*new String*/
          variable[18] = variable[17];
          CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[18]) /*AbstractArray::add*/;
          variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
          CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[8], variable[9]) /*AbsSyntaxVisitor::error*/;
        } else { /*if*/
          variable[8] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
          variable[9] = CALL_abstractmetamodel___MMLocalProperty___global( variable[7] /*p*/)( variable[7] /*p*/) /*MMLocalProperty::global*/;
          variable[8] = CALL_abstractmetamodel___MMLocalClass_____bra(variable[8])(variable[8], variable[9]) /*MMLocalClass::[]*/;
          CALL_abstract_collection___SimpleCollection___add( variable[3] /*precs*/)( variable[3] /*precs*/, variable[8]) /*AbstractArray::add*/;
        }
        continue_87: while(0);
        CALL_abstract_collection___Iterator___next(variable[5])(variable[5]) /*ArrayIterator::next*/;
      }
      break_87: while(0);
      variable[5] = CALL_abstract_collection___Collection___is_empty( variable[3] /*precs*/)( variable[3] /*precs*/) /*AbstractArray::is_empty*/;
      if (UNTAG_Bool(variable[5])) { /*if*/
        variable[5] = variable[0];
        variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
        variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Error: No contructor named "), TAG_Int(27)); /*new String*/
        variable[8] = variable[7];
        CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[8]) /*AbstractArray::add*/;
        variable[9] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
        variable[9] = CALL_abstractmetamodel___MMLocalProperty___name(variable[9])(variable[9]) /*MMLocalProperty::name*/;
        variable[10] = variable[9];
        variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[10]) /*AbstractArray::add*/;
        variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" in superclasses."), TAG_Int(17)); /*new String*/
        variable[12] = variable[11];
        CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[12]) /*AbstractArray::add*/;
        variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
        goto return_label86;
      } else { /*if*/
        variable[5] = CALL_abstract_collection___Collection___length( variable[3] /*precs*/)( variable[3] /*precs*/) /*AbstractArray::length*/;
        variable[5] = TAG_Bool(UNTAG_Int(variable[5])>UNTAG_Int( TAG_Int(1)));
        if (UNTAG_Bool(variable[5])) { /*if*/
          variable[5] = variable[0];
          variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
          variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Error: Conflicting contructors named "), TAG_Int(37)); /*new String*/
          variable[8] = variable[7];
          CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[8]) /*AbstractArray::add*/;
          variable[9] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
          variable[9] = CALL_abstractmetamodel___MMLocalProperty___name(variable[9])(variable[9]) /*MMLocalProperty::name*/;
          variable[10] = variable[9];
          variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
          CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[10]) /*AbstractArray::add*/;
          variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" in superclasses: "), TAG_Int(18)); /*new String*/
          variable[12] = variable[11];
          CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[12]) /*AbstractArray::add*/;
          variable[13] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)); /*new String*/
          variable[13] = CALL_string___Collection___join( variable[3] /*precs*/)( variable[3] /*precs*/, variable[13]) /*Collection::join*/;
          variable[14] = variable[13];
          CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[14]) /*AbstractArray::add*/;
          variable[15] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
          variable[16] = variable[15];
          CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[16]) /*AbstractArray::add*/;
          variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
          CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
          goto return_label86;
        }
      }
      variable[6] = CALL_abstract_collection___Collection___first( variable[4] /*base_precs*/)( variable[4] /*base_precs*/) /*IndexedCollection::first*/;
      variable[5] = variable[6];
      variable[6] = TAG_Bool(( variable[5] /*p*/==NIT_NULL) || VAL_ISA( variable[5] /*p*/, COLOR_MMMethod, ID_MMMethod)) /*cast MMMethod*/;
      if (!UNTAG_Bool(variable[6])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___ASuperExpr___after_typing, LOCATE_typing, 815); nit_exit(1);}
      variable[6] = variable[0];
      ATTR_typing___ASuperExpr____init_in_superclass(variable[6]) /*ASuperExpr::_init_in_superclass*/ =  variable[5] /*p*/;
      variable[6] = variable[0];
      CALL_typing___ASuperInitCall___register_super_init_call(variable[6])(variable[6],  variable[1] /*v*/,  variable[5] /*p*/) /*ASuperInitCall::register_super_init_call*/;
      variable[6] = variable[0];
      variable[6] = CALL_parser_nodes___ASuperExpr___n_args(variable[6])(variable[6]) /*ASuperExpr::n_args*/;
      variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*List::length*/;
      variable[6] = TAG_Bool(UNTAG_Int(variable[6])>UNTAG_Int( TAG_Int(0)));
      if (UNTAG_Bool(variable[6])) { /*if*/
        variable[7] = variable[0];
        variable[8] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
        variable[8] = CALL_syntax_base___Variable___stype(variable[8])(variable[8]) /*Variable::stype*/;
        variable[7] = CALL_typing___AAbsSendExpr___get_signature(variable[7])(variable[7],  variable[1] /*v*/, variable[8],  variable[5] /*p*/,  TAG_Bool(true)) /*AAbsSendExpr::get_signature*/;
        variable[6] = variable[7];
        variable[7] = variable[0];
        variable[8] = variable[0];
        variable[9] = CALL_abstractmetamodel___MMLocalProperty___name( variable[5] /*p*/)( variable[5] /*p*/) /*MMLocalProperty::name*/;
        variable[10] = variable[0];
        variable[10] = CALL_parser_nodes___ASuperExpr___n_args(variable[10])(variable[10]) /*ASuperExpr::n_args*/;
        variable[10] = CALL_array___Collection___to_a(variable[10])(variable[10]) /*Collection::to_a*/;
        variable[8] = CALL_typing___AAbsSendExpr___process_signature(variable[8])(variable[8],  variable[1] /*v*/,  variable[6] /*signature*/, variable[9], variable[10]) /*AAbsSendExpr::process_signature*/;
        ATTR_typing___AAbsSendExpr____arguments(variable[7]) /*AAbsSendExpr::_arguments*/ = variable[8];
      }
    } else { /*if*/
      variable[4] = variable[0];
      variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: No super method to call for "), TAG_Int(35)); /*new String*/
      variable[7] = variable[6];
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[7]) /*AbstractArray::add*/;
      variable[8] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
      variable[9] = variable[8];
      variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[9]) /*AbstractArray::add*/;
      variable[10] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
      variable[11] = variable[10];
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[11]) /*AbstractArray::add*/;
      variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
      goto return_label86;
    }
  }
  variable[4] = CALL_abstract_collection___Collection___first( variable[3] /*precs*/)( variable[3] /*precs*/) /*IndexedCollection::first*/;
  variable[5] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
  variable[5] = CALL_syntax_base___Variable___stype(variable[5])(variable[5]) /*Variable::stype*/;
  variable[4] = CALL_static_type___MMLocalProperty___signature_for(variable[4])(variable[4], variable[5]) /*MMLocalProperty::signature_for*/;
  variable[4] = CALL_static_type___MMSignature___return_type(variable[4])(variable[4]) /*MMSignature::return_type*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[5] = NEW_Array_array___Array___init(); /*new Array[MMType]*/
    variable[4] = variable[5];
    variable[5] =  NIT_NULL /*null*/;
    variable[6] = CALL_abstract_collection___Collection___iterator( variable[3] /*precs*/)( variable[3] /*precs*/) /*AbstractArray::iterator*/;
    while (true) { /*for*/
      variable[7] = CALL_abstract_collection___Iterator___is_ok(variable[6])(variable[6]) /*ArrayIterator::is_ok*/;
      if (!UNTAG_Bool(variable[7])) break; /*for*/
      variable[7] = CALL_abstract_collection___Iterator___item(variable[6])(variable[6]) /*ArrayIterator::item*/;
      variable[8] = variable[7];
      variable[9] = TAG_Bool(( variable[8] /*prop*/==NIT_NULL) || VAL_ISA( variable[8] /*prop*/, COLOR_MMMethod, ID_MMMethod)) /*cast MMMethod*/;
      if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___ASuperExpr___after_typing, LOCATE_typing, 831); nit_exit(1);}
      variable[10] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
      variable[10] = CALL_syntax_base___Variable___stype(variable[10])(variable[10]) /*Variable::stype*/;
      variable[10] = CALL_static_type___MMLocalProperty___signature_for( variable[8] /*prop*/)( variable[8] /*prop*/, variable[10]) /*MMLocalProperty::signature_for*/;
      variable[10] = CALL_static_type___MMSignature___return_type(variable[10])(variable[10]) /*MMSignature::return_type*/;
      variable[11] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
      variable[10] = CALL_static_type___MMType___for_module(variable[10])(variable[10], variable[11]) /*MMType::for_module*/;
      variable[11] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
      variable[11] = CALL_static_type___MMLocalProperty___signature(variable[11])(variable[11]) /*MMLocalProperty::signature*/;
      variable[11] = CALL_static_type___MMSignature___recv(variable[11])(variable[11]) /*MMSignature::recv*/;
      variable[10] = CALL_static_type___MMType___adapt_to(variable[10])(variable[10], variable[11]) /*MMType::adapt_to*/;
      variable[9] = variable[10];
      CALL_abstract_collection___SimpleCollection___add( variable[4] /*stypes*/)( variable[4] /*stypes*/,  variable[9] /*t*/) /*AbstractArray::add*/;
      variable[10] = TAG_Bool(( variable[5] /*stype*/ ==  NIT_NULL /*null*/) || (( variable[5] /*stype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*stype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*stype*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*stype*/)( variable[5] /*stype*/,  NIT_NULL /*null*/) /*Object::==*/)))));
      variable[11] = variable[10];
      if (!UNTAG_Bool(variable[11])) { /* or */
        variable[11] = CALL_static_type___MMType_____l( variable[5] /*stype*/)( variable[5] /*stype*/,  variable[9] /*t*/) /*MMType::<*/;
      }
      variable[10] = variable[11];
      if (UNTAG_Bool(variable[10])) { /*if*/
        variable[5] =  variable[9] /*t*/ /*stype=*/;
      }
      continue_88: while(0);
      CALL_abstract_collection___Iterator___next(variable[6])(variable[6]) /*ArrayIterator::next*/;
    }
    break_88: while(0);
    variable[6] = CALL_abstract_collection___Collection___iterator( variable[4] /*stypes*/)( variable[4] /*stypes*/) /*AbstractArray::iterator*/;
    while (true) { /*for*/
      variable[7] = CALL_abstract_collection___Iterator___is_ok(variable[6])(variable[6]) /*ArrayIterator::is_ok*/;
      if (!UNTAG_Bool(variable[7])) break; /*for*/
      variable[7] = CALL_abstract_collection___Iterator___item(variable[6])(variable[6]) /*ArrayIterator::item*/;
      variable[8] = variable[7];
      variable[9] = variable[0];
      CALL_syntax_base___AbsSyntaxVisitor___check_conform( variable[1] /*v*/)( variable[1] /*v*/, variable[9],  variable[8] /*t*/,  variable[5] /*stype*/) /*AbsSyntaxVisitor::check_conform*/;
      continue_89: while(0);
      CALL_abstract_collection___Iterator___next(variable[6])(variable[6]) /*ArrayIterator::next*/;
    }
    break_89: while(0);
    variable[6] = variable[0];
    ATTR_typing___PExpr____stype(variable[6]) /*PExpr::_stype*/ =  variable[5] /*stype*/;
  }
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
  variable[4] = variable[5];
  variable[5] = TAG_Bool(( variable[4] /*p*/==NIT_NULL) || VAL_ISA( variable[4] /*p*/, COLOR_MMSrcMethod, ID_MMSrcMethod)) /*cast MMSrcMethod*/;
  if (!UNTAG_Bool(variable[5])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___ASuperExpr___after_typing, LOCATE_typing, 844); nit_exit(1);}
  variable[5] = variable[0];
  ATTR_typing___AAbsSendExpr____prop(variable[5]) /*AAbsSendExpr::_prop*/ =  variable[4] /*p*/;
  return_label86: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASuperExpr___init_in_superclass(val_t  self) {
  struct trace_t trace = {NULL, NULL, 791, LOCATE_typing___ASuperExpr___init_in_superclass};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperExpr____init_in_superclass( self) /*ASuperExpr::_init_in_superclass*/;
}
val_t typing___AAttrFormExpr___prop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 850, LOCATE_typing___AAttrFormExpr___prop};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAttrFormExpr____prop( self) /*AAttrFormExpr::_prop*/;
}
val_t typing___AAttrFormExpr___attr_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 853, LOCATE_typing___AAttrFormExpr___attr_type};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAttrFormExpr____attr_type( self) /*AAttrFormExpr::_attr_type*/;
}
void typing___AAttrFormExpr___do_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 856, LOCATE_typing___AAttrFormExpr___do_typing};
  val_t variable[21];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AAttrFormExpr___n_expr(variable[3])(variable[3]) /*AAttrFormExpr::n_expr*/;
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label90;
  }
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAttrFormExpr___n_expr(variable[4])(variable[4]) /*AAttrFormExpr::n_expr*/;
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  variable[3] = variable[4];
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___AAttrFormExpr___n_id(variable[5])(variable[5]) /*AAttrFormExpr::n_id*/;
  variable[5] = CALL_syntax_base___Token___to_symbol(variable[5])(variable[5]) /*Token::to_symbol*/;
  variable[4] = variable[5];
  variable[6] = CALL_static_type___MMType___local_class( variable[3] /*type_recv*/)( variable[3] /*type_recv*/) /*MMType::local_class*/;
  variable[6] = CALL_abstractmetamodel___MMLocalClass___select_attribute(variable[6])(variable[6],  variable[4] /*name*/) /*MMLocalClass::select_attribute*/;
  variable[5] = variable[6];
  variable[6] = TAG_Bool(( variable[5] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[5] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*prop*/)( variable[5] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = variable[0];
    variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
    variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: Attribute "), TAG_Int(17)); /*new String*/
    variable[9] = variable[8];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
    variable[10] =  variable[4] /*name*/;
    variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[10]) /*AbstractArray::add*/;
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" doesn't exists in "), TAG_Int(19)); /*new String*/
    variable[12] = variable[11];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[12]) /*AbstractArray::add*/;
    variable[13] =  variable[3] /*type_recv*/;
    variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[13]) /*AbstractArray::add*/;
    variable[14] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
    variable[15] = variable[14];
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[15]) /*AbstractArray::add*/;
    variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
    goto return_label90;
  } else { /*if*/
    variable[6] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
    variable[7] = CALL_abstractmetamodel___MMLocalProperty___global( variable[5] /*prop*/)( variable[5] /*prop*/) /*MMLocalProperty::global*/;
    variable[7] = CALL_abstractmetamodel___MMGlobalProperty___local_class(variable[7])(variable[7]) /*MMGlobalProperty::local_class*/;
    variable[7] = CALL_abstractmetamodel___MMLocalClass___module(variable[7])(variable[7]) /*MMLocalClass::module*/;
    variable[6] = CALL_abstractmetamodel___MMModule___visibility_for(variable[6])(variable[6], variable[7]) /*MMModule::visibility_for*/;
    variable[6] = TAG_Bool(UNTAG_Int(variable[6])<UNTAG_Int( TAG_Int(3)));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[6] = variable[0];
      variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(7)); /*new Array[String]*/
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: Attribute "), TAG_Int(17)); /*new String*/
      variable[9] = variable[8];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
      variable[10] =  variable[4] /*name*/;
      variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[10]) /*AbstractArray::add*/;
      variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" from "), TAG_Int(6)); /*new String*/
      variable[12] = variable[11];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[12]) /*AbstractArray::add*/;
      variable[13] = CALL_abstractmetamodel___MMLocalProperty___global( variable[5] /*prop*/)( variable[5] /*prop*/) /*MMLocalProperty::global*/;
      variable[13] = CALL_abstractmetamodel___MMGlobalProperty___local_class(variable[13])(variable[13]) /*MMGlobalProperty::local_class*/;
      variable[13] = CALL_abstractmetamodel___MMLocalClass___module(variable[13])(variable[13]) /*MMLocalClass::module*/;
      variable[14] = variable[13];
      variable[14] = CALL_string___Object___to_s(variable[14])(variable[14]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[14]) /*AbstractArray::add*/;
      variable[15] = NEW_String_string___String___with_native(BOX_NativeString(" is invisible in "), TAG_Int(17)); /*new String*/
      variable[16] = variable[15];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[16]) /*AbstractArray::add*/;
      variable[17] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
      variable[18] = variable[17];
      variable[18] = CALL_string___Object___to_s(variable[18])(variable[18]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[18]) /*AbstractArray::add*/;
      variable[19] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
      variable[20] = variable[19];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[20]) /*AbstractArray::add*/;
      variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
    }
  }
  variable[6] = variable[0];
  ATTR_typing___AAttrFormExpr____prop(variable[6]) /*AAttrFormExpr::_prop*/ =  variable[5] /*prop*/;
  variable[7] = CALL_static_type___MMLocalProperty___signature_for( variable[5] /*prop*/)( variable[5] /*prop*/,  variable[3] /*type_recv*/) /*MMLocalProperty::signature_for*/;
  variable[7] = CALL_static_type___MMSignature___return_type(variable[7])(variable[7]) /*MMSignature::return_type*/;
  variable[6] = variable[7];
  variable[7] = variable[0];
  variable[7] = CALL_parser_nodes___AAttrFormExpr___n_expr(variable[7])(variable[7]) /*AAttrFormExpr::n_expr*/;
  variable[7] = CALL_typing___PExpr___is_self(variable[7])(variable[7]) /*PExpr::is_self*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[7])))) { /*if*/
    variable[7] = CALL_static_type___MMType___not_for_self( variable[6] /*at*/)( variable[6] /*at*/) /*MMType::not_for_self*/;
    variable[6] = variable[7] /*at=*/;
  }
  variable[7] = variable[0];
  ATTR_typing___AAttrFormExpr____attr_type(variable[7]) /*AAttrFormExpr::_attr_type*/ =  variable[6] /*at*/;
  return_label90: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAttrExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 877, LOCATE_typing___AAttrExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  CALL_typing___AAttrFormExpr___do_typing(variable[3])(variable[3],  variable[1] /*v*/) /*AAttrFormExpr::do_typing*/;
  variable[3] = variable[0];
  variable[3] = CALL_typing___AAttrFormExpr___prop(variable[3])(variable[3]) /*AAttrFormExpr::prop*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label91;
  }
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_typing___AAttrFormExpr___attr_type(variable[4])(variable[4]) /*AAttrFormExpr::attr_type*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label91: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAttrAssignExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 888, LOCATE_typing___AAttrAssignExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  CALL_typing___AAttrFormExpr___do_typing(variable[3])(variable[3],  variable[1] /*v*/) /*AAttrFormExpr::do_typing*/;
  variable[3] = variable[0];
  variable[3] = CALL_typing___AAttrFormExpr___prop(variable[3])(variable[3]) /*AAttrFormExpr::prop*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label92;
  }
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[3])(variable[3]) /*AAssignFormExpr::n_value*/;
  variable[4] = variable[0];
  variable[4] = CALL_typing___AAttrFormExpr___attr_type(variable[4])(variable[4]) /*AAttrFormExpr::attr_type*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  return_label92: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAttrReassignExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 899, LOCATE_typing___AAttrReassignExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  CALL_typing___AAttrFormExpr___do_typing(variable[3])(variable[3],  variable[1] /*v*/) /*AAttrFormExpr::do_typing*/;
  variable[3] = variable[0];
  variable[3] = CALL_typing___AAttrFormExpr___prop(variable[3])(variable[3]) /*AAttrFormExpr::prop*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label93;
  }
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_typing___AAttrFormExpr___attr_type(variable[4])(variable[4]) /*AAttrFormExpr::attr_type*/;
  CALL_typing___AReassignFormExpr___do_lvalue_typing(variable[3])(variable[3],  variable[1] /*v*/, variable[4]) /*AReassignFormExpr::do_lvalue_typing*/;
  return_label93: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AAbsSendExpr___prop_signature(val_t  self) {
  struct trace_t trace = {NULL, NULL, 911, LOCATE_typing___AAbsSendExpr___prop_signature};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAbsSendExpr____prop_signature( self) /*AAbsSendExpr::_prop_signature*/;
}
void typing___AAbsSendExpr___do_typing(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3, val_t  param4, val_t  param5, val_t  param6) {
  struct trace_t trace = {NULL, NULL, 914, LOCATE_typing___AAbsSendExpr___do_typing};
  val_t variable[15];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[4] =  param3;
  variable[5] =  param4;
  variable[6] =  param5;
  variable[7] =  param6;
  variable[10] = variable[0];
  variable[10] = CALL_typing___AAbsSendExpr___get_property(variable[10])(variable[10],  variable[1] /*v*/,  variable[2] /*type_recv*/,  variable[3] /*is_implicit_self*/,  variable[5] /*name*/) /*AAbsSendExpr::get_property*/;
  variable[9] = variable[10];
  variable[10] = TAG_Bool(( variable[9] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[9] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[9] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[9] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[9] /*prop*/)( variable[9] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[10])) { /*if*/
    goto return_label94;
  }
  variable[11] = variable[0];
  variable[11] = CALL_typing___AAbsSendExpr___get_signature(variable[11])(variable[11],  variable[1] /*v*/,  variable[2] /*type_recv*/,  variable[9] /*prop*/,  variable[4] /*recv_is_self*/) /*AAbsSendExpr::get_signature*/;
  variable[10] = variable[11];
  variable[11] = TAG_Bool(( variable[10] /*sig*/ ==  NIT_NULL /*null*/) || (( variable[10] /*sig*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[10] /*sig*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[10] /*sig*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[10] /*sig*/)( variable[10] /*sig*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[11])) { /*if*/
    goto return_label94;
  }
  variable[12] = variable[0];
  variable[13] = CALL_abstractmetamodel___MMLocalProperty___name( variable[9] /*prop*/)( variable[9] /*prop*/) /*MMLocalProperty::name*/;
  variable[12] = CALL_typing___AAbsSendExpr___process_signature(variable[12])(variable[12],  variable[1] /*v*/,  variable[10] /*sig*/, variable[13],  variable[6] /*raw_args*/) /*AAbsSendExpr::process_signature*/;
  variable[11] = variable[12];
  variable[12] = TAG_Bool(( variable[11] /*args*/ ==  NIT_NULL /*null*/) || (( variable[11] /*args*/ != NIT_NULL) && UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[11] /*args*/)( variable[11] /*args*/,  NIT_NULL /*null*/) /*AbstractArray::==*/)));
  if (UNTAG_Bool(variable[12])) { /*if*/
    goto return_label94;
  }
  variable[13] = variable[0];
  variable[14] = CALL_abstractmetamodel___MMLocalProperty___name( variable[9] /*prop*/)( variable[9] /*prop*/) /*MMLocalProperty::name*/;
  variable[13] = CALL_typing___AAbsSendExpr___process_closures(variable[13])(variable[13],  variable[1] /*v*/,  variable[10] /*sig*/, variable[14],  variable[7] /*closure_defs*/) /*AAbsSendExpr::process_closures*/;
  variable[12] = variable[13];
  variable[13] = variable[0];
  ATTR_typing___AAbsSendExpr____prop(variable[13]) /*AAbsSendExpr::_prop*/ =  variable[9] /*prop*/;
  variable[13] = variable[0];
  ATTR_typing___AAbsSendExpr____prop_signature(variable[13]) /*AAbsSendExpr::_prop_signature*/ =  variable[10] /*sig*/;
  variable[13] = variable[0];
  ATTR_typing___AAbsSendExpr____arguments(variable[13]) /*AAbsSendExpr::_arguments*/ =  variable[11] /*args*/;
  variable[13] = variable[0];
  ATTR_typing___AAbsSendExpr____return_type(variable[13]) /*AAbsSendExpr::_return_type*/ =  variable[12] /*rtype*/;
  return_label94: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AAbsSendExpr___get_property(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 930, LOCATE_typing___AAbsSendExpr___get_property};
  val_t variable[19];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[4] =  param3;
  variable[6] = TAG_Bool(( variable[2] /*type_recv*/ ==  NIT_NULL /*null*/) || (( variable[2] /*type_recv*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[2] /*type_recv*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[2] /*type_recv*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[2] /*type_recv*/)( variable[2] /*type_recv*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[5] =  NIT_NULL /*null*/;
    goto return_label95;
  }
  variable[7] = CALL_static_type___MMType___local_class( variable[2] /*type_recv*/)( variable[2] /*type_recv*/) /*MMType::local_class*/;
  variable[7] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[7])(variable[7],  variable[4] /*name*/) /*MMLocalClass::select_method*/;
  variable[6] = variable[7];
  variable[7] = TAG_Bool(( variable[6] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[6] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[6] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[6] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[6] /*prop*/)( variable[6] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  variable[8] = variable[7];
  if (UNTAG_Bool(variable[8])) { /* and */
    variable[8] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    variable[8] = CALL_abstractmetamodel___MMLocalProperty___global(variable[8])(variable[8]) /*MMLocalProperty::global*/;
    variable[8] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[8])(variable[8]) /*MMGlobalProperty::is_init*/;
  }
  variable[7] = variable[8];
  if (UNTAG_Bool(variable[7])) { /*if*/
    variable[8] = CALL_static_type___MMType___local_class( variable[2] /*type_recv*/)( variable[2] /*type_recv*/) /*MMType::local_class*/;
    variable[8] = CALL_abstractmetamodel___MMLocalClass___super_methods_named(variable[8])(variable[8],  variable[4] /*name*/) /*MMLocalClass::super_methods_named*/;
    variable[7] = variable[8];
    variable[8] = CALL_abstract_collection___Collection___length( variable[7] /*props*/)( variable[7] /*props*/) /*AbstractArray::length*/;
    variable[8] = TAG_Bool(UNTAG_Int(variable[8])>UNTAG_Int( TAG_Int(1)));
    if (UNTAG_Bool(variable[8])) { /*if*/
      variable[8] = variable[0];
      variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
      variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: Ambigous method name '"), TAG_Int(29)); /*new String*/
      variable[11] = variable[10];
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[11]) /*AbstractArray::add*/;
      variable[12] =  variable[4] /*name*/;
      variable[12] = CALL_string___Object___to_s(variable[12])(variable[12]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[12]) /*AbstractArray::add*/;
      variable[13] = NEW_String_string___String___with_native(BOX_NativeString("' for "), TAG_Int(6)); /*new String*/
      variable[14] = variable[13];
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[14]) /*AbstractArray::add*/;
      variable[15] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)); /*new String*/
      variable[15] = CALL_string___Collection___join( variable[7] /*props*/)( variable[7] /*props*/, variable[15]) /*Collection::join*/;
      variable[16] = variable[15];
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[16]) /*AbstractArray::add*/;
      variable[17] = NEW_String_string___String___with_native(BOX_NativeString(". Use explicit designation."), TAG_Int(27)); /*new String*/
      variable[18] = variable[17];
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[18]) /*AbstractArray::add*/;
      variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[8], variable[9]) /*AbsSyntaxVisitor::error*/;
      variable[5] =  NIT_NULL /*null*/;
      goto return_label95;
    } else { /*if*/
      variable[8] = CALL_abstract_collection___Collection___length( variable[7] /*props*/)( variable[7] /*props*/) /*AbstractArray::length*/;
      variable[8] = TAG_Bool((variable[8])==( TAG_Int(1)));
      if (UNTAG_Bool(variable[8])) { /*if*/
        variable[9] = CALL_static_type___MMType___local_class( variable[2] /*type_recv*/)( variable[2] /*type_recv*/) /*MMType::local_class*/;
        variable[10] = CALL_abstract_collection___Collection___first( variable[7] /*props*/)( variable[7] /*props*/) /*IndexedCollection::first*/;
        variable[10] = CALL_abstractmetamodel___MMLocalProperty___global(variable[10])(variable[10]) /*MMLocalProperty::global*/;
        variable[9] = CALL_abstractmetamodel___MMLocalClass_____bra(variable[9])(variable[9], variable[10]) /*MMLocalClass::[]*/;
        variable[8] = variable[9];
        variable[9] = TAG_Bool(( variable[8] /*p*/==NIT_NULL) || VAL_ISA( variable[8] /*p*/, COLOR_MMMethod, ID_MMMethod)) /*cast MMMethod*/;
        if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___AAbsSendExpr___get_property, LOCATE_typing, 941); nit_exit(1);}
        variable[6] =  variable[8] /*p*/ /*prop=*/;
      }
    }
  }
  variable[7] = TAG_Bool(( variable[6] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[6] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[6] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[6] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[6] /*prop*/)( variable[6] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[7])) { /*if*/
    if (UNTAG_Bool( variable[3] /*is_implicit_self*/)) { /*if*/
      variable[7] = variable[0];
      variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: Method or variable '"), TAG_Int(27)); /*new String*/
      variable[10] = variable[9];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[10]) /*AbstractArray::add*/;
      variable[11] =  variable[4] /*name*/;
      variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[11]) /*AbstractArray::add*/;
      variable[12] = NEW_String_string___String___with_native(BOX_NativeString("' unknown in "), TAG_Int(13)); /*new String*/
      variable[13] = variable[12];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[13]) /*AbstractArray::add*/;
      variable[14] =  variable[2] /*type_recv*/;
      variable[14] = CALL_string___Object___to_s(variable[14])(variable[14]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[14]) /*AbstractArray::add*/;
      variable[15] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
      variable[16] = variable[15];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[16]) /*AbstractArray::add*/;
      variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[7], variable[8]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[7] = variable[0];
      variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: Method '"), TAG_Int(15)); /*new String*/
      variable[10] = variable[9];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[10]) /*AbstractArray::add*/;
      variable[11] =  variable[4] /*name*/;
      variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[11]) /*AbstractArray::add*/;
      variable[12] = NEW_String_string___String___with_native(BOX_NativeString("' doesn't exists in "), TAG_Int(20)); /*new String*/
      variable[13] = variable[12];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[13]) /*AbstractArray::add*/;
      variable[14] =  variable[2] /*type_recv*/;
      variable[14] = CALL_string___Object___to_s(variable[14])(variable[14]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[14]) /*AbstractArray::add*/;
      variable[15] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
      variable[16] = variable[15];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[16]) /*AbstractArray::add*/;
      variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[7], variable[8]) /*AbsSyntaxVisitor::error*/;
    }
    variable[5] =  NIT_NULL /*null*/;
    goto return_label95;
  }
  variable[5] =  variable[6] /*prop*/;
  goto return_label95;
  return_label95: while(false);
  tracehead = trace.prev;
  return variable[5];
}
val_t typing___AAbsSendExpr___get_signature(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 957, LOCATE_typing___AAbsSendExpr___get_signature};
  val_t variable[9];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[4] =  param3;
  variable[6] = CALL_abstractmetamodel___MMLocalProperty___global( variable[3] /*prop*/)( variable[3] /*prop*/) /*MMLocalProperty::global*/;
  variable[7] = variable[0];
  variable[8] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
  CALL_syntax_base___MMGlobalProperty___check_visibility(variable[6])(variable[6],  variable[1] /*v*/, variable[7], variable[8],  variable[4] /*recv_is_self*/) /*MMGlobalProperty::check_visibility*/;
  variable[7] = CALL_static_type___MMLocalProperty___signature_for( variable[3] /*prop*/)( variable[3] /*prop*/,  variable[2] /*type_recv*/) /*MMLocalProperty::signature_for*/;
  variable[6] = variable[7];
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool( variable[4] /*recv_is_self*/)))) { /*if*/
    variable[7] = CALL_static_type___MMSignature___not_for_self( variable[6] /*psig*/)( variable[6] /*psig*/) /*MMSignature::not_for_self*/;
    variable[6] = variable[7] /*psig=*/;
  }
  variable[5] =  variable[6] /*psig*/;
  goto return_label96;
  return_label96: while(false);
  tracehead = trace.prev;
  return variable[5];
}
val_t typing___AAbsSendExpr___process_signature(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 966, LOCATE_typing___AAbsSendExpr___process_signature};
  val_t variable[25];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[4] =  param3;
  variable[7] = CALL_vararg___MMSignature___vararg_rank( variable[2] /*psig*/)( variable[2] /*psig*/) /*MMSignature::vararg_rank*/;
  variable[6] = variable[7];
  variable[8] = CALL_static_type___MMSignature___arity( variable[2] /*psig*/)( variable[2] /*psig*/) /*MMSignature::arity*/;
  variable[7] = variable[8];
  /*variable[8] is variable raw_arity*/
  variable[9] = TAG_Bool(( variable[4] /*raw_args*/ ==  NIT_NULL /*null*/) || (( variable[4] /*raw_args*/ != NIT_NULL) && UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*raw_args*/)( variable[4] /*raw_args*/,  NIT_NULL /*null*/) /*AbstractArray::==*/)));
  if (UNTAG_Bool(variable[9])) { /*if*/
    variable[8] =  TAG_Int(0) /*raw_arity=*/;
  } else { /*if*/
    variable[9] = CALL_abstract_collection___Collection___length( variable[4] /*raw_args*/)( variable[4] /*raw_args*/) /*AbstractArray::length*/;
    variable[8] = variable[9] /*raw_arity=*/;
  }
  variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*par_arity*/)>UNTAG_Int( variable[8] /*raw_arity*/));
  variable[10] = variable[9];
  if (!UNTAG_Bool(variable[10])) { /* or */
    variable[10] = TAG_Bool(( variable[7] /*par_arity*/)!=( variable[8] /*raw_arity*/));
    variable[11] = variable[10];
    if (UNTAG_Bool(variable[11])) { /* and */
      variable[11] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
      variable[11] = TAG_Bool(( variable[6] /*par_vararg*/)==(variable[11]));
    }
    variable[10] = variable[11];
  }
  variable[9] = variable[10];
  if (UNTAG_Bool(variable[9])) { /*if*/
    variable[9] = variable[0];
    variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString("Error: '"), TAG_Int(8)); /*new String*/
    variable[12] = variable[11];
    CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[12]) /*AbstractArray::add*/;
    variable[13] =  variable[3] /*name*/;
    variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[13]) /*AbstractArray::add*/;
    variable[14] = NEW_String_string___String___with_native(BOX_NativeString("' arity missmatch."), TAG_Int(18)); /*new String*/
    variable[15] = variable[14];
    CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[15]) /*AbstractArray::add*/;
    variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[9], variable[10]) /*AbsSyntaxVisitor::error*/;
    variable[5] =  NIT_NULL /*null*/;
    goto return_label97;
  }
  variable[9] =  TAG_Int(0);
  variable[11] = NEW_Array_array___Array___init(); /*new Array[PExpr]*/
  variable[10] = variable[11];
  variable[11] = NEW_Range_range___Range___without_last( TAG_Int(0),  variable[7] /*par_arity*/); /*new Range[Int]*/
  variable[11] = CALL_abstract_collection___Collection___iterator(variable[11])(variable[11]) /*Range::iterator*/;
  while (true) { /*for*/
    variable[12] = CALL_abstract_collection___Iterator___is_ok(variable[11])(variable[11]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[12])) break; /*for*/
    variable[12] = CALL_abstract_collection___Iterator___item(variable[11])(variable[11]) /*Iterator::item*/;
    variable[13] = variable[12];
    /*variable[14] is variable a*/
    variable[16] = CALL_static_type___MMSignature_____bra( variable[2] /*psig*/)( variable[2] /*psig*/,  variable[13] /*par_idx*/) /*MMSignature::[]*/;
    variable[15] = variable[16];
    variable[16] = TAG_Bool(( variable[13] /*par_idx*/)==( variable[6] /*par_vararg*/));
    if (UNTAG_Bool(variable[16])) { /*if*/
      variable[17] = NEW_Array_array___Array___init(); /*new Array[PExpr]*/
      variable[16] = variable[17];
      variable[17] = TAG_Int(UNTAG_Int( variable[8] /*raw_arity*/)-UNTAG_Int( variable[7] /*par_arity*/));
      variable[18] = NEW_Range_range___Range___init( TAG_Int(0), variable[17]); /*new Range[Int]*/
      variable[17] = variable[18];
      variable[17] = CALL_abstract_collection___Collection___iterator(variable[17])(variable[17]) /*Range::iterator*/;
      while (true) { /*for*/
        variable[18] = CALL_abstract_collection___Iterator___is_ok(variable[17])(variable[17]) /*Iterator::is_ok*/;
        if (!UNTAG_Bool(variable[18])) break; /*for*/
        variable[18] = CALL_abstract_collection___Iterator___item(variable[17])(variable[17]) /*Iterator::item*/;
        variable[19] = variable[18];
        variable[20] =  variable[4] /*raw_args*/;
        variable[21] =  variable[9] /*arg_idx*/;
        variable[23] = TAG_Bool(UNTAG_Int( variable[21] /*index*/)>=UNTAG_Int( TAG_Int(0)));
        variable[24] = variable[23];
        if (UNTAG_Bool(variable[24])) { /* and */
          variable[24] = variable[20];
          variable[24] = ATTR_array___AbstractArray____length(variable[24]) /*AbstractArray::_length*/;
          variable[24] = TAG_Bool(UNTAG_Int( variable[21] /*index*/)<UNTAG_Int(variable[24]));
        }
        variable[23] = variable[24];
        if (!UNTAG_Bool(variable[23])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 229); nit_exit(1);}
        variable[23] = variable[20];
        variable[23] = ATTR_array___Array____items(variable[23]) /*Array::_items*/;
        variable[23] = UNBOX_NativeArray(variable[23])[UNTAG_Int( variable[21] /*index*/)];
        variable[22] = variable[23];
        goto return_label100;
        return_label100: while(false);
        variable[20] = variable[22];
        variable[14] = variable[20] /*a=*/;
        CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/,  variable[14] /*a*/,  variable[15] /*par_type*/) /*AbsSyntaxVisitor::check_conform_expr*/;
        CALL_abstract_collection___SimpleCollection___add( variable[16] /*star*/)( variable[16] /*star*/,  variable[14] /*a*/) /*AbstractArray::add*/;
        variable[20] = TAG_Int(UNTAG_Int( variable[9] /*arg_idx*/)+UNTAG_Int( TAG_Int(1)));
        variable[9] = variable[20] /*arg_idx=*/;
        continue_99: while(0);
        CALL_abstract_collection___Iterator___next(variable[17])(variable[17]) /*Iterator::next*/;
      }
      break_99: while(0);
      variable[18] = NEW_AArrayExpr_parser_prod___AArrayExpr___init_aarrayexpr( variable[16] /*star*/); /*new AArrayExpr*/
      variable[17] = variable[18];
      CALL_typing___AArrayExpr___do_typing( variable[17] /*aa*/)( variable[17] /*aa*/,  variable[1] /*v*/,  variable[15] /*par_type*/) /*AArrayExpr::do_typing*/;
      variable[14] =  variable[17] /*aa*/ /*a=*/;
    } else { /*if*/
      variable[16] =  variable[4] /*raw_args*/;
      variable[17] =  variable[9] /*arg_idx*/;
      variable[19] = TAG_Bool(UNTAG_Int( variable[17] /*index*/)>=UNTAG_Int( TAG_Int(0)));
      variable[20] = variable[19];
      if (UNTAG_Bool(variable[20])) { /* and */
        variable[20] = variable[16];
        variable[20] = ATTR_array___AbstractArray____length(variable[20]) /*AbstractArray::_length*/;
        variable[20] = TAG_Bool(UNTAG_Int( variable[17] /*index*/)<UNTAG_Int(variable[20]));
      }
      variable[19] = variable[20];
      if (!UNTAG_Bool(variable[19])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 229); nit_exit(1);}
      variable[19] = variable[16];
      variable[19] = ATTR_array___Array____items(variable[19]) /*Array::_items*/;
      variable[19] = UNBOX_NativeArray(variable[19])[UNTAG_Int( variable[17] /*index*/)];
      variable[18] = variable[19];
      goto return_label101;
      return_label101: while(false);
      variable[16] = variable[18];
      variable[14] = variable[16] /*a=*/;
      CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/,  variable[14] /*a*/,  variable[15] /*par_type*/) /*AbsSyntaxVisitor::check_conform_expr*/;
      variable[16] = TAG_Int(UNTAG_Int( variable[9] /*arg_idx*/)+UNTAG_Int( TAG_Int(1)));
      variable[9] = variable[16] /*arg_idx=*/;
    }
    CALL_abstract_collection___SimpleCollection___add( variable[10] /*args*/)( variable[10] /*args*/,  variable[14] /*a*/) /*AbstractArray::add*/;
    continue_98: while(0);
    CALL_abstract_collection___Iterator___next(variable[11])(variable[11]) /*Iterator::next*/;
  }
  break_98: while(0);
  variable[5] =  variable[10] /*args*/;
  goto return_label97;
  return_label97: while(false);
  tracehead = trace.prev;
  return variable[5];
}
val_t typing___AAbsSendExpr___process_closures(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 1003, LOCATE_typing___AAbsSendExpr___process_closures};
  val_t variable[24];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[4] =  param3;
  variable[7] = CALL_static_type___MMSignature___return_type( variable[2] /*psig*/)( variable[2] /*psig*/) /*MMSignature::return_type*/;
  variable[6] = variable[7];
  variable[8] = CALL_static_type___MMSignature___closures( variable[2] /*psig*/)( variable[2] /*psig*/) /*MMSignature::closures*/;
  variable[7] = variable[8];
  variable[8] =  TAG_Int(0);
  variable[9] = CALL_abstract_collection___Collection___iterator( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[10] = CALL_abstract_collection___Iterator___is_ok(variable[9])(variable[9]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[10])) break; /*for*/
    variable[10] = CALL_abstract_collection___Iterator___item(variable[9])(variable[9]) /*ArrayIterator::item*/;
    variable[11] = variable[10];
    variable[12] = CALL_static_type___MMClosure___is_optional( variable[11] /*c*/)( variable[11] /*c*/) /*MMClosure::is_optional*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[12])))) { /*if*/
      variable[8] = TAG_Int(UNTAG_Int(variable[8])+UNTAG_Int( TAG_Int(1))) /*min_arity*/;
    }
    continue_103: while(0);
    CALL_abstract_collection___Iterator___next(variable[9])(variable[9]) /*ArrayIterator::next*/;
  }
  break_103: while(0);
  variable[9] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*cd*/ ==  NIT_NULL /*null*/) || (( variable[4] /*cd*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*cd*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*cd*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*cd*/)( variable[4] /*cd*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[9])) { /*if*/
    variable[9] = CALL_abstract_collection___Collection___length( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArray::length*/;
    variable[9] = TAG_Bool((variable[9])==( TAG_Int(0)));
    if (UNTAG_Bool(variable[9])) { /*if*/
      variable[9] = variable[0];
      variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
      variable[11] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
      variable[12] = variable[11];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[12]) /*AbstractArray::add*/;
      variable[13] =  variable[3] /*name*/;
      variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[13]) /*AbstractArray::add*/;
      variable[14] = NEW_String_string___String___with_native(BOX_NativeString(" does not require blocs."), TAG_Int(24)); /*new String*/
      variable[15] = variable[14];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[15]) /*AbstractArray::add*/;
      variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[9], variable[10]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[9] = CALL_abstract_collection___Collection___length( variable[4] /*cd*/)( variable[4] /*cd*/) /*AbstractArray::length*/;
      variable[10] = CALL_abstract_collection___Collection___length( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArray::length*/;
      variable[9] = TAG_Bool(UNTAG_Int(variable[9])>UNTAG_Int(variable[10]));
      variable[10] = variable[9];
      if (!UNTAG_Bool(variable[10])) { /* or */
        variable[10] = CALL_abstract_collection___Collection___length( variable[4] /*cd*/)( variable[4] /*cd*/) /*AbstractArray::length*/;
        variable[10] = TAG_Bool(UNTAG_Int(variable[10])<UNTAG_Int( variable[8] /*min_arity*/));
      }
      variable[9] = variable[10];
      if (UNTAG_Bool(variable[9])) { /*if*/
        variable[9] = variable[0];
        variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(7)); /*new Array[String]*/
        variable[11] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
        variable[12] = variable[11];
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[12]) /*AbstractArray::add*/;
        variable[13] =  variable[3] /*name*/;
        variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[13]) /*AbstractArray::add*/;
        variable[14] = NEW_String_string___String___with_native(BOX_NativeString(" requires "), TAG_Int(10)); /*new String*/
        variable[15] = variable[14];
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[15]) /*AbstractArray::add*/;
        variable[16] = CALL_abstract_collection___Collection___length( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArray::length*/;
        variable[17] = variable[16];
        variable[17] = CALL_string___Object___to_s(variable[17])(variable[17]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[17]) /*AbstractArray::add*/;
        variable[18] = NEW_String_string___String___with_native(BOX_NativeString(" blocs, "), TAG_Int(8)); /*new String*/
        variable[19] = variable[18];
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[19]) /*AbstractArray::add*/;
        variable[20] = CALL_abstract_collection___Collection___length( variable[4] /*cd*/)( variable[4] /*cd*/) /*AbstractArray::length*/;
        variable[21] = variable[20];
        variable[21] = CALL_string___Object___to_s(variable[21])(variable[21]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[21]) /*AbstractArray::add*/;
        variable[22] = NEW_String_string___String___with_native(BOX_NativeString(" found."), TAG_Int(7)); /*new String*/
        variable[23] = variable[22];
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[23]) /*AbstractArray::add*/;
        variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[9], variable[10]) /*AbsSyntaxVisitor::error*/;
      } else { /*if*/
        variable[10] = CALL_typing___TypingVisitor___closure_break_stype( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::closure_break_stype*/;
        variable[9] = variable[10];
        variable[11] = CALL_typing___TypingVisitor___break_list( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::break_list*/;
        variable[10] = variable[11];
        CALL_typing___TypingVisitor___closure_break_stype__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[6] /*t*/) /*TypingVisitor::closure_break_stype=*/;
        variable[11] = NEW_Array_array___Array___init(); /*new Array[ABreakExpr]*/
        CALL_typing___TypingVisitor___break_list__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[11]) /*TypingVisitor::break_list=*/;
        variable[11] = CALL_abstract_collection___Collection___length( variable[4] /*cd*/)( variable[4] /*cd*/) /*AbstractArray::length*/;
        variable[12] = NEW_Range_range___Range___without_last( TAG_Int(0), variable[11]); /*new Range[Int]*/
        variable[11] = variable[12];
        variable[11] = CALL_abstract_collection___Collection___iterator(variable[11])(variable[11]) /*Range::iterator*/;
        while (true) { /*for*/
          variable[12] = CALL_abstract_collection___Iterator___is_ok(variable[11])(variable[11]) /*Iterator::is_ok*/;
          if (!UNTAG_Bool(variable[12])) break; /*for*/
          variable[12] = CALL_abstract_collection___Iterator___item(variable[11])(variable[11]) /*Iterator::item*/;
          variable[13] = variable[12];
          variable[14] =  variable[4] /*cd*/;
          variable[15] =  variable[13] /*i*/;
          variable[17] = TAG_Bool(UNTAG_Int( variable[15] /*index*/)>=UNTAG_Int( TAG_Int(0)));
          variable[18] = variable[17];
          if (UNTAG_Bool(variable[18])) { /* and */
            variable[18] = variable[14];
            variable[18] = ATTR_array___AbstractArray____length(variable[18]) /*AbstractArray::_length*/;
            variable[18] = TAG_Bool(UNTAG_Int( variable[15] /*index*/)<UNTAG_Int(variable[18]));
          }
          variable[17] = variable[18];
          if (!UNTAG_Bool(variable[17])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 229); nit_exit(1);}
          variable[17] = variable[14];
          variable[17] = ATTR_array___Array____items(variable[17]) /*Array::_items*/;
          variable[17] = UNBOX_NativeArray(variable[17])[UNTAG_Int( variable[15] /*index*/)];
          variable[16] = variable[17];
          goto return_label105;
          return_label105: while(false);
          variable[14] = variable[16];
          variable[15] =  variable[7] /*cs*/;
          variable[16] =  variable[13] /*i*/;
          variable[18] = TAG_Bool(UNTAG_Int( variable[16] /*index*/)>=UNTAG_Int( TAG_Int(0)));
          variable[19] = variable[18];
          if (UNTAG_Bool(variable[19])) { /* and */
            variable[19] = variable[15];
            variable[19] = ATTR_array___AbstractArray____length(variable[19]) /*AbstractArray::_length*/;
            variable[19] = TAG_Bool(UNTAG_Int( variable[16] /*index*/)<UNTAG_Int(variable[19]));
          }
          variable[18] = variable[19];
          if (!UNTAG_Bool(variable[18])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 229); nit_exit(1);}
          variable[18] = variable[15];
          variable[18] = ATTR_array___Array____items(variable[18]) /*Array::_items*/;
          variable[18] = UNBOX_NativeArray(variable[18])[UNTAG_Int( variable[16] /*index*/)];
          variable[17] = variable[18];
          goto return_label106;
          return_label106: while(false);
          variable[15] = variable[17];
          CALL_typing___PClosureDef___accept_typing2(variable[14])(variable[14],  variable[1] /*v*/, variable[15]) /*PClosureDef::accept_typing2*/;
          continue_104: while(0);
          CALL_abstract_collection___Iterator___next(variable[11])(variable[11]) /*Iterator::next*/;
        }
        break_104: while(0);
        variable[11] = CALL_typing___TypingVisitor___break_list( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::break_list*/;
        variable[11] = CALL_abstract_collection___Collection___iterator(variable[11])(variable[11]) /*AbstractArray::iterator*/;
        while (true) { /*for*/
          variable[12] = CALL_abstract_collection___Iterator___is_ok(variable[11])(variable[11]) /*ArrayIterator::is_ok*/;
          if (!UNTAG_Bool(variable[12])) break; /*for*/
          variable[12] = CALL_abstract_collection___Iterator___item(variable[11])(variable[11]) /*ArrayIterator::item*/;
          variable[13] = variable[12];
          variable[15] = CALL_syntax_base___PExpr___stype( variable[13] /*n*/)( variable[13] /*n*/) /*PExpr::stype*/;
          variable[14] = variable[15];
          variable[15] = TAG_Bool(( variable[6] /*t*/ ==  NIT_NULL /*null*/) || (( variable[6] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[6] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[6] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[6] /*t*/)( variable[6] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
          variable[16] = variable[15];
          if (!UNTAG_Bool(variable[16])) { /* or */
            variable[16] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[6] /*t*/ ==  NIT_NULL /*null*/) || (( variable[6] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[6] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[6] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[6] /*t*/)( variable[6] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
            variable[17] = variable[16];
            if (UNTAG_Bool(variable[17])) { /* and */
              variable[17] = CALL_static_type___MMType_____l( variable[6] /*t*/)( variable[6] /*t*/,  variable[14] /*ntype*/) /*MMType::<*/;
            }
            variable[16] = variable[17];
          }
          variable[15] = variable[16];
          if (UNTAG_Bool(variable[15])) { /*if*/
            variable[6] =  variable[14] /*ntype*/ /*t=*/;
          }
          continue_107: while(0);
          CALL_abstract_collection___Iterator___next(variable[11])(variable[11]) /*ArrayIterator::next*/;
        }
        break_107: while(0);
        variable[11] = CALL_typing___TypingVisitor___break_list( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::break_list*/;
        variable[11] = CALL_abstract_collection___Collection___iterator(variable[11])(variable[11]) /*AbstractArray::iterator*/;
        while (true) { /*for*/
          variable[12] = CALL_abstract_collection___Iterator___is_ok(variable[11])(variable[11]) /*ArrayIterator::is_ok*/;
          if (!UNTAG_Bool(variable[12])) break; /*for*/
          variable[12] = CALL_abstract_collection___Iterator___item(variable[11])(variable[11]) /*ArrayIterator::item*/;
          variable[13] = variable[12];
          CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/,  variable[13] /*n*/,  variable[6] /*t*/) /*AbsSyntaxVisitor::check_conform_expr*/;
          continue_108: while(0);
          CALL_abstract_collection___Iterator___next(variable[11])(variable[11]) /*ArrayIterator::next*/;
        }
        break_108: while(0);
        CALL_typing___TypingVisitor___closure_break_stype__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[9] /*old_bbst*/) /*TypingVisitor::closure_break_stype=*/;
        CALL_typing___TypingVisitor___break_list__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[10] /*old_bl*/) /*TypingVisitor::break_list=*/;
      }
    }
  } else { /*if*/
    variable[9] = TAG_Bool(( variable[8] /*min_arity*/)!=( TAG_Int(0)));
    if (UNTAG_Bool(variable[9])) { /*if*/
      variable[9] = variable[0];
      variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
      variable[11] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
      variable[12] = variable[11];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[12]) /*AbstractArray::add*/;
      variable[13] =  variable[3] /*name*/;
      variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[13]) /*AbstractArray::add*/;
      variable[14] = NEW_String_string___String___with_native(BOX_NativeString(" requires "), TAG_Int(10)); /*new String*/
      variable[15] = variable[14];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[15]) /*AbstractArray::add*/;
      variable[16] = CALL_abstract_collection___Collection___length( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArray::length*/;
      variable[17] = variable[16];
      variable[17] = CALL_string___Object___to_s(variable[17])(variable[17]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[17]) /*AbstractArray::add*/;
      variable[18] = NEW_String_string___String___with_native(BOX_NativeString(" blocs."), TAG_Int(7)); /*new String*/
      variable[19] = variable[18];
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[19]) /*AbstractArray::add*/;
      variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[9], variable[10]) /*AbsSyntaxVisitor::error*/;
    }
  }
  variable[5] =  variable[6] /*t*/;
  goto return_label102;
  return_label102: while(false);
  tracehead = trace.prev;
  return variable[5];
}
val_t typing___AAbsSendExpr___prop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1044, LOCATE_typing___AAbsSendExpr___prop};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAbsSendExpr____prop( self) /*AAbsSendExpr::_prop*/;
}
val_t typing___AAbsSendExpr___arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1047, LOCATE_typing___AAbsSendExpr___arguments};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAbsSendExpr____arguments( self) /*AAbsSendExpr::_arguments*/;
}
val_t typing___AAbsSendExpr___return_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1050, LOCATE_typing___AAbsSendExpr___return_type};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAbsSendExpr____return_type( self) /*AAbsSendExpr::_return_type*/;
}
void typing___ASuperInitCall___register_super_init_call(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 1058, LOCATE_typing___ASuperInitCall___register_super_init_call};
  val_t variable[21];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = variable[0];
  variable[4] = CALL_parser_prod___PNode___parent(variable[4])(variable[4]) /*PNode::parent*/;
  variable[5] = CALL_typing___TypingVisitor___top_block( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::top_block*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] == variable[5]) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4],variable[5])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4], variable[5]) /*Object::==*/)))))));
  variable[5] = variable[4];
  if (UNTAG_Bool(variable[5])) { /* and */
    variable[5] = variable[0];
    variable[6] = CALL_typing___TypingVisitor___top_block( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::top_block*/;
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] == variable[6]) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5],variable[6])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5], variable[6]) /*Object::==*/)))))));
  }
  variable[4] = variable[5];
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: Constructor invocation "), TAG_Int(30)); /*new String*/
    variable[7] = variable[6];
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[7]) /*AbstractArray::add*/;
    variable[8] =  variable[2] /*property*/;
    variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[8]) /*AbstractArray::add*/;
    variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" must not be in nested block."), TAG_Int(29)); /*new String*/
    variable[10] = variable[9];
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[10]) /*AbstractArray::add*/;
    variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
  }
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
  variable[6] = CALL_abstractmetamodel___MMLocalProperty___global( variable[2] /*property*/)( variable[2] /*property*/) /*MMLocalProperty::global*/;
  variable[6] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[6])(variable[6]) /*MMGlobalProperty::intro*/;
  variable[6] = CALL_abstractmetamodel___MMLocalProperty___local_class(variable[6])(variable[6]) /*MMLocalProperty::local_class*/;
  variable[6] = CALL_abstractmetamodel___MMLocalClass___global(variable[6])(variable[6]) /*MMLocalClass::global*/;
  variable[5] = CALL_abstractmetamodel___MMModule_____bra(variable[5])(variable[5], variable[6]) /*MMModule::[]*/;
  variable[4] = variable[5];
  variable[5] =  NIT_NULL /*null*/;
  variable[6] = CALL_typing___TypingVisitor___explicit_super_init_calls( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::explicit_super_init_calls*/;
  variable[6] = CALL_abstract_collection___Collection___is_empty(variable[6])(variable[6]) /*AbstractArray::is_empty*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
    variable[6] = CALL_typing___TypingVisitor___explicit_super_init_calls( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::explicit_super_init_calls*/;
    variable[6] = CALL_abstract_collection___IndexedCollection___last(variable[6])(variable[6]) /*IndexedCollection::last*/;
    variable[6] = CALL_abstractmetamodel___MMLocalProperty___global(variable[6])(variable[6]) /*MMLocalProperty::global*/;
    variable[6] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[6])(variable[6]) /*MMGlobalProperty::intro*/;
    variable[6] = CALL_abstractmetamodel___MMLocalProperty___local_class(variable[6])(variable[6]) /*MMLocalProperty::local_class*/;
    variable[5] = variable[6] /*prev_class=*/;
  }
  variable[7] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
  variable[7] = CALL_abstractmetamodel___MMLocalClass___cshe(variable[7])(variable[7]) /*MMLocalClass::cshe*/;
  variable[7] = CALL_partial_order___PartialOrderElement___reverse_linear_extension(variable[7])(variable[7]) /*PartialOrderElement::reverse_linear_extension*/;
  variable[6] = variable[7];
  variable[7] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
  variable[7] = TAG_Bool(( variable[4] /*cla*/ == variable[7]) || (( variable[4] /*cla*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*cla*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*cla*/,variable[7])):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*cla*/)( variable[4] /*cla*/, variable[7]) /*Object::==*/)))));
  if (UNTAG_Bool(variable[7])) { /*if*/
    CALL_typing___TypingVisitor___explicit_other_init_call__eq( variable[1] /*v*/)( variable[1] /*v*/,  TAG_Bool(true)) /*TypingVisitor::explicit_other_init_call=*/;
  } else { /*if*/
    variable[7] = CALL_abstract_collection___Collection___has( variable[6] /*order*/)( variable[6] /*order*/,  variable[4] /*cla*/) /*AbstractArray::has*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[7])))) { /*if*/
      variable[7] = variable[0];
      variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: Constructor of class "), TAG_Int(28)); /*new String*/
      variable[10] = variable[9];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[10]) /*AbstractArray::add*/;
      variable[11] =  variable[4] /*cla*/;
      variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[11]) /*AbstractArray::add*/;
      variable[12] = NEW_String_string___String___with_native(BOX_NativeString(" must be one in "), TAG_Int(16)); /*new String*/
      variable[13] = variable[12];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[13]) /*AbstractArray::add*/;
      variable[14] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)); /*new String*/
      variable[14] = CALL_string___Collection___join( variable[6] /*order*/)( variable[6] /*order*/, variable[14]) /*Collection::join*/;
      variable[15] = variable[14];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[15]) /*AbstractArray::add*/;
      variable[16] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
      variable[17] = variable[16];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[17]) /*AbstractArray::add*/;
      variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[7], variable[8]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[7] = TAG_Bool(( variable[4] /*cla*/ ==  variable[5] /*prev_class*/) || (( variable[4] /*cla*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*cla*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*cla*/, variable[5] /*prev_class*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*cla*/)( variable[4] /*cla*/,  variable[5] /*prev_class*/) /*Object::==*/)))));
      if (UNTAG_Bool(variable[7])) { /*if*/
        variable[7] = variable[0];
        variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
        variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: Only one super constructor invocation of class "), TAG_Int(54)); /*new String*/
        variable[10] = variable[9];
        CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[10]) /*AbstractArray::add*/;
        variable[11] =  variable[4] /*cla*/;
        variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[11]) /*AbstractArray::add*/;
        variable[12] = NEW_String_string___String___with_native(BOX_NativeString(" is allowed."), TAG_Int(12)); /*new String*/
        variable[13] = variable[12];
        CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[13]) /*AbstractArray::add*/;
        variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[7], variable[8]) /*AbsSyntaxVisitor::error*/;
      } else { /*if*/
        variable[8] = TAG_Bool(( variable[5] /*prev_class*/ ==  NIT_NULL /*null*/) || (( variable[5] /*prev_class*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*prev_class*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*prev_class*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*prev_class*/)( variable[5] /*prev_class*/,  NIT_NULL /*null*/) /*Object::==*/)))));
        variable[7] = variable[8];
        variable[8] = CALL_abstract_collection___Collection___iterator( variable[6] /*order*/)( variable[6] /*order*/) /*AbstractArray::iterator*/;
        while (true) { /*for*/
          variable[9] = CALL_abstract_collection___Iterator___is_ok(variable[8])(variable[8]) /*ArrayIterator::is_ok*/;
          if (!UNTAG_Bool(variable[9])) break; /*for*/
          variable[9] = CALL_abstract_collection___Iterator___item(variable[8])(variable[8]) /*ArrayIterator::item*/;
          variable[10] = variable[9];
          variable[11] = TAG_Bool(( variable[10] /*c*/ ==  variable[5] /*prev_class*/) || (( variable[10] /*c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[10] /*c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[10] /*c*/, variable[5] /*prev_class*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[10] /*c*/)( variable[10] /*c*/,  variable[5] /*prev_class*/) /*Object::==*/)))));
          if (UNTAG_Bool(variable[11])) { /*if*/
            variable[7] =  TAG_Bool(true) /*last_is_found=*/;
          } else { /*if*/
            variable[11] = TAG_Bool(( variable[10] /*c*/ ==  variable[4] /*cla*/) || (( variable[10] /*c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[10] /*c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[10] /*c*/, variable[4] /*cla*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[10] /*c*/)( variable[10] /*c*/,  variable[4] /*cla*/) /*Object::==*/)))));
            if (UNTAG_Bool(variable[11])) { /*if*/
              if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool( variable[7] /*last_is_found*/)))) { /*if*/
		variable[11] = variable[0];
		variable[12] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
		variable[13] = NEW_String_string___String___with_native(BOX_NativeString("Error: Constructor of "), TAG_Int(22)); /*new String*/
		variable[14] = variable[13];
		CALL_abstract_collection___SimpleCollection___add(variable[12])(variable[12], variable[14]) /*AbstractArray::add*/;
		variable[15] =  variable[10] /*c*/;
		variable[15] = CALL_string___Object___to_s(variable[15])(variable[15]) /*Object::to_s*/;
		CALL_abstract_collection___SimpleCollection___add(variable[12])(variable[12], variable[15]) /*AbstractArray::add*/;
		variable[16] = NEW_String_string___String___with_native(BOX_NativeString(" must be invoked before constructor of "), TAG_Int(39)); /*new String*/
		variable[17] = variable[16];
		CALL_abstract_collection___SimpleCollection___add(variable[12])(variable[12], variable[17]) /*AbstractArray::add*/;
		variable[18] =  variable[5] /*prev_class*/;
		variable[18] = CALL_string___Object___to_s(variable[18])(variable[18]) /*Object::to_s*/;
		CALL_abstract_collection___SimpleCollection___add(variable[12])(variable[12], variable[18]) /*AbstractArray::add*/;
		variable[19] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
		variable[20] = variable[19];
		CALL_abstract_collection___SimpleCollection___add(variable[12])(variable[12], variable[20]) /*AbstractArray::add*/;
		variable[12] = CALL_string___Object___to_s(variable[12])(variable[12]) /*Object::to_s*/;
		CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[11], variable[12]) /*AbsSyntaxVisitor::error*/;
              }
              variable[11] = CALL_typing___TypingVisitor___explicit_super_init_calls( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::explicit_super_init_calls*/;
              CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11],  variable[2] /*property*/) /*AbstractArray::add*/;
              goto break_110;
            }
          }
          continue_110: while(0);
          CALL_abstract_collection___Iterator___next(variable[8])(variable[8]) /*ArrayIterator::next*/;
        }
        break_110: while(0);
      }
    }
  }
  return_label109: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ANewExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1095, LOCATE_typing___ANewExpr___after_typing};
    static val_t once_value_112; static int once_bool_112; /* Once value for variable[5]*/
  val_t variable[13];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___ANewExpr___n_type(variable[4])(variable[4]) /*ANewExpr::n_type*/;
  variable[4] = CALL_typing___PType___stype(variable[4])(variable[4]) /*PType::stype*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label111;
  }
  variable[4] = CALL_static_type___MMType___local_class( variable[3] /*t*/)( variable[3] /*t*/) /*MMType::local_class*/;
  variable[4] = CALL_abstractmetamodel___MMLocalClass___global(variable[4])(variable[4]) /*MMLocalClass::global*/;
  variable[4] = CALL_abstractmetamodel___MMGlobalClass___is_abstract(variable[4])(variable[4]) /*MMGlobalClass::is_abstract*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: try to instantiate abstract class "), TAG_Int(41)); /*new String*/
    variable[7] = variable[6];
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[7]) /*AbstractArray::add*/;
    variable[8] = CALL_static_type___MMType___local_class( variable[3] /*t*/)( variable[3] /*t*/) /*MMType::local_class*/;
    variable[9] = variable[8];
    variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[9]) /*AbstractArray::add*/;
    variable[10] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
    variable[11] = variable[10];
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[11]) /*AbstractArray::add*/;
    variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
    goto return_label111;
  }
  /*variable[4] is variable name*/
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___ANewExpr___n_id(variable[5])(variable[5]) /*ANewExpr::n_id*/;
  variable[5] = TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    if (once_bool_112) variable[5] = once_value_112;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("init"), TAG_Int(4)); /*new String*/
      variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
      once_value_112 = variable[5];
      once_bool_112 = true;
    }
    variable[4] = variable[5] /*name=*/;
  } else { /*if*/
    variable[5] = variable[0];
    variable[5] = CALL_parser_nodes___ANewExpr___n_id(variable[5])(variable[5]) /*ANewExpr::n_id*/;
    variable[5] = CALL_syntax_base___Token___to_symbol(variable[5])(variable[5]) /*Token::to_symbol*/;
    variable[4] = variable[5] /*name=*/;
  }
  variable[5] = variable[0];
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___ANewExpr___n_args(variable[6])(variable[6]) /*ANewExpr::n_args*/;
  variable[6] = CALL_array___Collection___to_a(variable[6])(variable[6]) /*Collection::to_a*/;
  CALL_typing___AAbsSendExpr___do_typing(variable[5])(variable[5],  variable[1] /*v*/,  variable[3] /*t*/,  TAG_Bool(false),  TAG_Bool(false),  variable[4] /*name*/, variable[6],  NIT_NULL /*null*/) /*AAbsSendExpr::do_typing*/;
  variable[5] = variable[0];
  variable[5] = CALL_typing___AAbsSendExpr___prop(variable[5])(variable[5]) /*AAbsSendExpr::prop*/;
  variable[5] = TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    goto return_label111;
  }
  variable[5] = variable[0];
  variable[5] = CALL_typing___AAbsSendExpr___prop(variable[5])(variable[5]) /*AAbsSendExpr::prop*/;
  variable[5] = CALL_abstractmetamodel___MMLocalProperty___global(variable[5])(variable[5]) /*MMLocalProperty::global*/;
  variable[5] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[5])(variable[5]) /*MMGlobalProperty::is_init*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
    variable[5] = variable[0];
    variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
    variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
    variable[8] = variable[7];
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[8]) /*AbstractArray::add*/;
    variable[9] = variable[0];
    variable[9] = CALL_typing___AAbsSendExpr___prop(variable[9])(variable[9]) /*AAbsSendExpr::prop*/;
    variable[10] = variable[9];
    variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[10]) /*AbstractArray::add*/;
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" is not a constructor."), TAG_Int(22)); /*new String*/
    variable[12] = variable[11];
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[12]) /*AbstractArray::add*/;
    variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
  }
  variable[5] = variable[0];
  ATTR_typing___PExpr____stype(variable[5]) /*PExpr::_stype*/ =  variable[3] /*t*/;
  return_label111: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ASendExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1132, LOCATE_typing___ASendExpr___after_typing};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  CALL_typing___ASendExpr___do_all_typing(variable[3])(variable[3],  variable[1] /*v*/) /*ASendExpr::do_all_typing*/;
  return_label113: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASendExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1123, LOCATE_typing___ASendExpr___name};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 1123);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t typing___ASendExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1126, LOCATE_typing___ASendExpr___raw_arguments};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 1126);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t typing___ASendExpr___closure_defs(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1129, LOCATE_typing___ASendExpr___closure_defs};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  NIT_NULL /*null*/;
  goto return_label114;
  return_label114: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___ASendExpr___do_all_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1137, LOCATE_typing___ASendExpr___do_all_typing};
  val_t variable[11];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[3])(variable[3]) /*ASendExpr::n_expr*/;
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label115;
  }
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___ASendExpr___n_expr(variable[4])(variable[4]) /*ASendExpr::n_expr*/;
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___ASendExpr___n_expr(variable[5])(variable[5]) /*ASendExpr::n_expr*/;
  variable[5] = CALL_typing___PExpr___is_implicit_self(variable[5])(variable[5]) /*PExpr::is_implicit_self*/;
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___ASendExpr___n_expr(variable[6])(variable[6]) /*ASendExpr::n_expr*/;
  variable[6] = CALL_typing___PExpr___is_self(variable[6])(variable[6]) /*PExpr::is_self*/;
  variable[7] = variable[0];
  variable[7] = CALL_typing___ASendExpr___name(variable[7])(variable[7]) /*ASendExpr::name*/;
  variable[8] = variable[0];
  variable[8] = CALL_typing___ASendExpr___raw_arguments(variable[8])(variable[8]) /*ASendExpr::raw_arguments*/;
  variable[9] = variable[0];
  variable[9] = CALL_typing___ASendExpr___closure_defs(variable[9])(variable[9]) /*ASendExpr::closure_defs*/;
  CALL_typing___AAbsSendExpr___do_typing(variable[3])(variable[3],  variable[1] /*v*/, variable[4], variable[5], variable[6], variable[7], variable[8], variable[9]) /*AAbsSendExpr::do_typing*/;
  variable[3] = variable[0];
  variable[3] = CALL_typing___AAbsSendExpr___prop(variable[3])(variable[3]) /*AAbsSendExpr::prop*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label115;
  }
  variable[3] = variable[0];
  variable[3] = CALL_typing___AAbsSendExpr___prop(variable[3])(variable[3]) /*AAbsSendExpr::prop*/;
  variable[3] = CALL_abstractmetamodel___MMLocalProperty___global(variable[3])(variable[3]) /*MMLocalProperty::global*/;
  variable[3] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[3])(variable[3]) /*MMGlobalProperty::is_init*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    variable[3] = CALL_abstractmetamodel___MMLocalProperty___global(variable[3])(variable[3]) /*MMLocalProperty::global*/;
    variable[3] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[3])(variable[3]) /*MMGlobalProperty::is_init*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
      variable[3] = variable[0];
      variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: try to invoke constructor "), TAG_Int(33)); /*new String*/
      variable[6] = variable[5];
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[6]) /*AbstractArray::add*/;
      variable[7] = variable[0];
      variable[7] = CALL_typing___AAbsSendExpr___prop(variable[7])(variable[7]) /*AAbsSendExpr::prop*/;
      variable[8] = variable[7];
      variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[8]) /*AbstractArray::add*/;
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" in a method."), TAG_Int(13)); /*new String*/
      variable[10] = variable[9];
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[10]) /*AbstractArray::add*/;
      variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[3] = variable[0];
      variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[3])(variable[3]) /*ASendExpr::n_expr*/;
      variable[3] = CALL_typing___PExpr___is_self(variable[3])(variable[3]) /*PExpr::is_self*/;
      if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
        variable[3] = variable[0];
        variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: constructor "), TAG_Int(19)); /*new String*/
        variable[6] = variable[5];
        CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[6]) /*AbstractArray::add*/;
        variable[7] = variable[0];
        variable[7] = CALL_typing___AAbsSendExpr___prop(variable[7])(variable[7]) /*AAbsSendExpr::prop*/;
        variable[8] = variable[7];
        variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[8]) /*AbstractArray::add*/;
        variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" is not invoken on 'self'."), TAG_Int(26)); /*new String*/
        variable[10] = variable[9];
        CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[10]) /*AbstractArray::add*/;
        variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::error*/;
      } else { /*if*/
        variable[3] = variable[0];
        variable[4] = variable[0];
        variable[4] = CALL_typing___AAbsSendExpr___prop(variable[4])(variable[4]) /*AAbsSendExpr::prop*/;
        CALL_typing___ASuperInitCall___register_super_init_call(variable[3])(variable[3],  variable[1] /*v*/, variable[4]) /*ASuperInitCall::register_super_init_call*/;
      }
    }
  }
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_typing___AAbsSendExpr___return_type(variable[4])(variable[4]) /*AAbsSendExpr::return_type*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label115: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ASendReassignExpr___do_all_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1161, LOCATE_typing___ASendReassignExpr___do_all_typing};
  val_t variable[17];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[3])(variable[3]) /*ASendExpr::n_expr*/;
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label116;
  }
  variable[4] = variable[0];
  variable[4] = CALL_typing___ASendExpr___raw_arguments(variable[4])(variable[4]) /*ASendExpr::raw_arguments*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___ASendExpr___n_expr(variable[5])(variable[5]) /*ASendExpr::n_expr*/;
  variable[5] = CALL_syntax_base___PExpr___stype(variable[5])(variable[5]) /*PExpr::stype*/;
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___ASendExpr___n_expr(variable[6])(variable[6]) /*ASendExpr::n_expr*/;
  variable[6] = CALL_typing___PExpr___is_implicit_self(variable[6])(variable[6]) /*PExpr::is_implicit_self*/;
  variable[7] = variable[0];
  variable[7] = CALL_parser_nodes___ASendExpr___n_expr(variable[7])(variable[7]) /*ASendExpr::n_expr*/;
  variable[7] = CALL_typing___PExpr___is_self(variable[7])(variable[7]) /*PExpr::is_self*/;
  variable[8] = variable[0];
  variable[8] = CALL_typing___ASendExpr___name(variable[8])(variable[8]) /*ASendExpr::name*/;
  CALL_typing___AAbsSendExpr___do_typing(variable[4])(variable[4],  variable[1] /*v*/, variable[5], variable[6], variable[7], variable[8],  variable[3] /*raw_args*/,  NIT_NULL /*null*/) /*AAbsSendExpr::do_typing*/;
  variable[4] = variable[0];
  variable[4] = CALL_typing___AAbsSendExpr___prop(variable[4])(variable[4]) /*AAbsSendExpr::prop*/;
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label116;
  }
  variable[4] = variable[0];
  variable[4] = CALL_typing___AAbsSendExpr___prop(variable[4])(variable[4]) /*AAbsSendExpr::prop*/;
  variable[4] = CALL_abstractmetamodel___MMLocalProperty___global(variable[4])(variable[4]) /*MMLocalProperty::global*/;
  variable[4] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[4])(variable[4]) /*MMGlobalProperty::is_init*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    variable[4] = CALL_abstractmetamodel___MMLocalProperty___global(variable[4])(variable[4]) /*MMLocalProperty::global*/;
    variable[4] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[4])(variable[4]) /*MMGlobalProperty::is_init*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[4])))) { /*if*/
      variable[4] = variable[0];
      variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: try to invoke constructor "), TAG_Int(33)); /*new String*/
      variable[7] = variable[6];
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[7]) /*AbstractArray::add*/;
      variable[8] = variable[0];
      variable[8] = CALL_typing___AAbsSendExpr___prop(variable[8])(variable[8]) /*AAbsSendExpr::prop*/;
      variable[9] = variable[8];
      variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[9]) /*AbstractArray::add*/;
      variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" in a method."), TAG_Int(13)); /*new String*/
      variable[11] = variable[10];
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[11]) /*AbstractArray::add*/;
      variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[4] = variable[0];
      variable[4] = CALL_parser_nodes___ASendExpr___n_expr(variable[4])(variable[4]) /*ASendExpr::n_expr*/;
      variable[4] = CALL_typing___PExpr___is_self(variable[4])(variable[4]) /*PExpr::is_self*/;
      if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[4])))) { /*if*/
        variable[4] = variable[0];
        variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
        variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: constructor "), TAG_Int(19)); /*new String*/
        variable[7] = variable[6];
        CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[7]) /*AbstractArray::add*/;
        variable[8] = variable[0];
        variable[8] = CALL_typing___AAbsSendExpr___prop(variable[8])(variable[8]) /*AAbsSendExpr::prop*/;
        variable[9] = variable[8];
        variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[9]) /*AbstractArray::add*/;
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" is not invoken on 'self'."), TAG_Int(26)); /*new String*/
        variable[11] = variable[10];
        CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[11]) /*AbstractArray::add*/;
        variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
      }
    }
  }
  variable[5] = variable[0];
  variable[5] = CALL_typing___AAbsSendExpr___prop(variable[5])(variable[5]) /*AAbsSendExpr::prop*/;
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___ASendExpr___n_expr(variable[6])(variable[6]) /*ASendExpr::n_expr*/;
  variable[6] = CALL_syntax_base___PExpr___stype(variable[6])(variable[6]) /*PExpr::stype*/;
  variable[5] = CALL_static_type___MMLocalProperty___signature_for(variable[5])(variable[5], variable[6]) /*MMLocalProperty::signature_for*/;
  variable[5] = CALL_static_type___MMSignature___return_type(variable[5])(variable[5]) /*MMSignature::return_type*/;
  variable[4] = variable[5];
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___ASendExpr___n_expr(variable[5])(variable[5]) /*ASendExpr::n_expr*/;
  variable[5] = CALL_typing___PExpr___is_self(variable[5])(variable[5]) /*PExpr::is_self*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
    variable[5] = CALL_static_type___MMType___not_for_self( variable[4] /*t*/)( variable[4] /*t*/) /*MMType::not_for_self*/;
    variable[4] = variable[5] /*t=*/;
  }
  variable[5] = variable[0];
  CALL_typing___AReassignFormExpr___do_lvalue_typing(variable[5])(variable[5],  variable[1] /*v*/,  variable[4] /*t*/) /*AReassignFormExpr::do_lvalue_typing*/;
  variable[5] = variable[0];
  variable[6] = variable[0];
  variable[6] = CALL_typing___AAbsSendExpr___prop(variable[6])(variable[6]) /*AAbsSendExpr::prop*/;
  ATTR_typing___ASendReassignExpr____read_prop(variable[5]) /*ASendReassignExpr::_read_prop*/ = variable[6];
  variable[6] = variable[0];
  variable[6] = CALL_typing___AAbsSendExpr___arguments(variable[6])(variable[6]) /*AAbsSendExpr::arguments*/;
  variable[5] = variable[6];
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[6])(variable[6]) /*AReassignFormExpr::n_value*/;
  CALL_abstract_collection___SimpleCollection___add( variable[3] /*raw_args*/)( variable[3] /*raw_args*/, variable[6]) /*AbstractArray::add*/;
  variable[6] = variable[0];
  variable[7] = variable[0];
  variable[7] = CALL_parser_nodes___ASendExpr___n_expr(variable[7])(variable[7]) /*ASendExpr::n_expr*/;
  variable[7] = CALL_syntax_base___PExpr___stype(variable[7])(variable[7]) /*PExpr::stype*/;
  variable[8] = variable[0];
  variable[8] = CALL_parser_nodes___ASendExpr___n_expr(variable[8])(variable[8]) /*ASendExpr::n_expr*/;
  variable[8] = CALL_typing___PExpr___is_implicit_self(variable[8])(variable[8]) /*PExpr::is_implicit_self*/;
  variable[9] = variable[0];
  variable[9] = CALL_parser_nodes___ASendExpr___n_expr(variable[9])(variable[9]) /*ASendExpr::n_expr*/;
  variable[9] = CALL_typing___PExpr___is_self(variable[9])(variable[9]) /*PExpr::is_self*/;
  variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
  variable[11] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
  variable[12] = variable[11];
  CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[12]) /*AbstractArray::add*/;
  variable[13] = variable[0];
  variable[13] = CALL_typing___ASendExpr___name(variable[13])(variable[13]) /*ASendExpr::name*/;
  variable[14] = variable[13];
  variable[14] = CALL_string___Object___to_s(variable[14])(variable[14]) /*Object::to_s*/;
  CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[14]) /*AbstractArray::add*/;
  variable[15] = NEW_String_string___String___with_native(BOX_NativeString("="), TAG_Int(1)); /*new String*/
  variable[16] = variable[15];
  CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[16]) /*AbstractArray::add*/;
  variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
  variable[10] = CALL_symbol___String___to_symbol(variable[10])(variable[10]) /*String::to_symbol*/;
  CALL_typing___AAbsSendExpr___do_typing(variable[6])(variable[6],  variable[1] /*v*/, variable[7], variable[8], variable[9], variable[10],  variable[3] /*raw_args*/,  NIT_NULL /*null*/) /*AAbsSendExpr::do_typing*/;
  variable[6] = variable[0];
  variable[6] = CALL_typing___AAbsSendExpr___prop(variable[6])(variable[6]) /*AAbsSendExpr::prop*/;
  variable[6] = TAG_Bool((variable[6] ==  NIT_NULL /*null*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    goto return_label116;
  }
  variable[6] = variable[0];
  variable[6] = CALL_typing___AAbsSendExpr___prop(variable[6])(variable[6]) /*AAbsSendExpr::prop*/;
  variable[6] = CALL_abstractmetamodel___MMLocalProperty___global(variable[6])(variable[6]) /*MMLocalProperty::global*/;
  variable[6] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[6])(variable[6]) /*MMGlobalProperty::is_init*/;
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    variable[6] = CALL_abstractmetamodel___MMLocalProperty___global(variable[6])(variable[6]) /*MMLocalProperty::global*/;
    variable[6] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[6])(variable[6]) /*MMGlobalProperty::is_init*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
      variable[6] = variable[0];
      variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: try to invoke constructor "), TAG_Int(33)); /*new String*/
      variable[9] = variable[8];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
      variable[10] = variable[0];
      variable[10] = CALL_typing___AAbsSendExpr___prop(variable[10])(variable[10]) /*AAbsSendExpr::prop*/;
      variable[11] = variable[10];
      variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[11]) /*AbstractArray::add*/;
      variable[12] = NEW_String_string___String___with_native(BOX_NativeString(" in a method."), TAG_Int(13)); /*new String*/
      variable[13] = variable[12];
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[13]) /*AbstractArray::add*/;
      variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[6] = variable[0];
      variable[6] = CALL_parser_nodes___ASendExpr___n_expr(variable[6])(variable[6]) /*ASendExpr::n_expr*/;
      variable[6] = CALL_typing___PExpr___is_self(variable[6])(variable[6]) /*PExpr::is_self*/;
      if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
        variable[6] = variable[0];
        variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: constructor "), TAG_Int(19)); /*new String*/
        variable[9] = variable[8];
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[9]) /*AbstractArray::add*/;
        variable[10] = variable[0];
        variable[10] = CALL_typing___AAbsSendExpr___prop(variable[10])(variable[10]) /*AAbsSendExpr::prop*/;
        variable[11] = variable[10];
        variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[11]) /*AbstractArray::add*/;
        variable[12] = NEW_String_string___String___with_native(BOX_NativeString(" is not invoken on 'self'."), TAG_Int(26)); /*new String*/
        variable[13] = variable[12];
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[13]) /*AbstractArray::add*/;
        variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::error*/;
      }
    }
  }
  variable[6] = variable[0];
  ATTR_typing___AAbsSendExpr____arguments(variable[6]) /*AAbsSendExpr::_arguments*/ =  variable[5] /*old_args*/;
  return_label116: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASendReassignExpr___read_prop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1160, LOCATE_typing___ASendReassignExpr___read_prop};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASendReassignExpr____read_prop( self) /*ASendReassignExpr::_read_prop*/;
}
val_t typing___ABinopExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1198, LOCATE_typing___ABinopExpr___raw_arguments};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = NEW_Array_array___Array___with_capacity(TAG_Int(1)); /*new Array[PExpr]*/
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[3])(variable[3]) /*ABinopExpr::n_expr2*/;
  CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[3]) /*AbstractArray::add*/;
  variable[1] = variable[2];
  goto return_label117;
  return_label117: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AEqExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1201, LOCATE_typing___AEqExpr___name};
  static val_t once_value_119; static int once_bool_119; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_119) variable[2] = once_value_119;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("=="), TAG_Int(2)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_119 = variable[2];
    once_bool_119 = true;
  }
  variable[1] = variable[2];
  goto return_label118;
  return_label118: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ANeExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1204, LOCATE_typing___ANeExpr___name};
  static val_t once_value_121; static int once_bool_121; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_121) variable[2] = once_value_121;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("!="), TAG_Int(2)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_121 = variable[2];
    once_bool_121 = true;
  }
  variable[1] = variable[2];
  goto return_label120;
  return_label120: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ALtExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1207, LOCATE_typing___ALtExpr___name};
  static val_t once_value_123; static int once_bool_123; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_123) variable[2] = once_value_123;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("<"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_123 = variable[2];
    once_bool_123 = true;
  }
  variable[1] = variable[2];
  goto return_label122;
  return_label122: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ALeExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1210, LOCATE_typing___ALeExpr___name};
  static val_t once_value_125; static int once_bool_125; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_125) variable[2] = once_value_125;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("<="), TAG_Int(2)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_125 = variable[2];
    once_bool_125 = true;
  }
  variable[1] = variable[2];
  goto return_label124;
  return_label124: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AGtExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1213, LOCATE_typing___AGtExpr___name};
  static val_t once_value_127; static int once_bool_127; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_127) variable[2] = once_value_127;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString(">"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_127 = variable[2];
    once_bool_127 = true;
  }
  variable[1] = variable[2];
  goto return_label126;
  return_label126: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AGeExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1216, LOCATE_typing___AGeExpr___name};
  static val_t once_value_129; static int once_bool_129; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_129) variable[2] = once_value_129;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString(">="), TAG_Int(2)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_129 = variable[2];
    once_bool_129 = true;
  }
  variable[1] = variable[2];
  goto return_label128;
  return_label128: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___APlusExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1219, LOCATE_typing___APlusExpr___name};
  static val_t once_value_131; static int once_bool_131; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_131) variable[2] = once_value_131;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("+"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_131 = variable[2];
    once_bool_131 = true;
  }
  variable[1] = variable[2];
  goto return_label130;
  return_label130: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AMinusExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1222, LOCATE_typing___AMinusExpr___name};
  static val_t once_value_133; static int once_bool_133; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_133) variable[2] = once_value_133;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("-"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_133 = variable[2];
    once_bool_133 = true;
  }
  variable[1] = variable[2];
  goto return_label132;
  return_label132: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AStarshipExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1225, LOCATE_typing___AStarshipExpr___name};
  static val_t once_value_135; static int once_bool_135; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_135) variable[2] = once_value_135;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("<=>"), TAG_Int(3)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_135 = variable[2];
    once_bool_135 = true;
  }
  variable[1] = variable[2];
  goto return_label134;
  return_label134: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AStarExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1228, LOCATE_typing___AStarExpr___name};
  static val_t once_value_137; static int once_bool_137; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_137) variable[2] = once_value_137;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("*"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_137 = variable[2];
    once_bool_137 = true;
  }
  variable[1] = variable[2];
  goto return_label136;
  return_label136: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ASlashExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1231, LOCATE_typing___ASlashExpr___name};
  static val_t once_value_139; static int once_bool_139; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_139) variable[2] = once_value_139;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("/"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_139 = variable[2];
    once_bool_139 = true;
  }
  variable[1] = variable[2];
  goto return_label138;
  return_label138: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___APercentExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1234, LOCATE_typing___APercentExpr___name};
  static val_t once_value_141; static int once_bool_141; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_141) variable[2] = once_value_141;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("%"), TAG_Int(1)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_141 = variable[2];
    once_bool_141 = true;
  }
  variable[1] = variable[2];
  goto return_label140;
  return_label140: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AUminusExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1238, LOCATE_typing___AUminusExpr___name};
  static val_t once_value_143; static int once_bool_143; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_143) variable[2] = once_value_143;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("unary -"), TAG_Int(7)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_143 = variable[2];
    once_bool_143 = true;
  }
  variable[1] = variable[2];
  goto return_label142;
  return_label142: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AUminusExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1239, LOCATE_typing___AUminusExpr___raw_arguments};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  NIT_NULL /*null*/;
  goto return_label144;
  return_label144: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___ACallFormExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1243, LOCATE_typing___ACallFormExpr___after_typing};
  val_t variable[12];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[3])(variable[3]) /*ASendExpr::n_expr*/;
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  variable[4] = variable[3];
  if (UNTAG_Bool(variable[4])) { /* and */
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___ASendExpr___n_expr(variable[4])(variable[4]) /*ASendExpr::n_expr*/;
    variable[4] = CALL_typing___PExpr___is_implicit_self(variable[4])(variable[4]) /*PExpr::is_implicit_self*/;
  }
  variable[3] = variable[4];
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_parser_nodes___ACallFormExpr___n_id(variable[4])(variable[4]) /*ACallFormExpr::n_id*/;
    variable[4] = CALL_syntax_base___Token___to_symbol(variable[4])(variable[4]) /*Token::to_symbol*/;
    variable[3] = variable[4];
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    variable[5] = CALL_typing___VariableContext_____bra(variable[5])(variable[5],  variable[3] /*name*/) /*VariableContext::[]*/;
    variable[4] = variable[5];
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*variable*/ ==  NIT_NULL /*null*/) || (( variable[4] /*variable*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*variable*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*variable*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*variable*/)( variable[4] /*variable*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[5] = TAG_Bool(( variable[4] /*variable*/==NIT_NULL) || VAL_ISA( variable[4] /*variable*/, COLOR_ClosureVariable, ID_ClosureVariable)) /*cast ClosureVariable*/;
      if (UNTAG_Bool(variable[5])) { /*if*/
        variable[6] = variable[0];
        variable[6] = CALL_parser_nodes___ACallFormExpr___n_id(variable[6])(variable[6]) /*ACallFormExpr::n_id*/;
        variable[7] = variable[0];
        variable[7] = CALL_parser_nodes___ACallFormExpr___n_args(variable[7])(variable[7]) /*ACallFormExpr::n_args*/;
        variable[8] = variable[0];
        variable[8] = CALL_parser_nodes___ASendExpr___n_closure_defs(variable[8])(variable[8]) /*ASendExpr::n_closure_defs*/;
        variable[9] = NEW_AClosureCallExpr_parser_nodes___AClosureCallExpr___init(variable[6], variable[7], variable[8]); /*new AClosureCallExpr*/
        variable[6] = variable[9];
        variable[5] = variable[6];
        variable[6] = variable[0];
        CALL_parser_prod___PNode___replace_with(variable[6])(variable[6],  variable[5] /*n*/) /*Prod::replace_with*/;
        CALL_syntax_base___AClosureCallExpr___variable__eq( variable[5] /*n*/)( variable[5] /*n*/,  variable[4] /*variable*/) /*AClosureCallExpr::variable=*/;
        CALL_typing___PNode___after_typing( variable[5] /*n*/)( variable[5] /*n*/,  variable[1] /*v*/) /*AClosureCallExpr::after_typing*/;
        goto return_label145;
      } else { /*if*/
        variable[5] = variable[0];
        variable[5] = CALL_parser_nodes___ACallFormExpr___n_args(variable[5])(variable[5]) /*ACallFormExpr::n_args*/;
        variable[5] = CALL_abstract_collection___Collection___is_empty(variable[5])(variable[5]) /*List::is_empty*/;
        if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
          variable[5] = variable[0];
          variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
          variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
          variable[8] = variable[7];
          CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[8]) /*AbstractArray::add*/;
          variable[9] =  variable[3] /*name*/;
          variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
          CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[9]) /*AbstractArray::add*/;
          variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" is variable, not a function."), TAG_Int(29)); /*new String*/
          variable[11] = variable[10];
          CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[11]) /*AbstractArray::add*/;
          variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
          CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
        }
        variable[6] = variable[0];
        variable[6] = CALL_typing___ACallFormExpr___variable_create(variable[6])(variable[6],  variable[4] /*variable*/) /*ACallFormExpr::variable_create*/;
        variable[5] = variable[6];
        CALL_syntax_base___AVarFormExpr___variable__eq( variable[5] /*vform*/)( variable[5] /*vform*/,  variable[4] /*variable*/) /*AVarFormExpr::variable=*/;
        variable[6] = variable[0];
        CALL_parser_prod___PNode___replace_with(variable[6])(variable[6],  variable[5] /*vform*/) /*Prod::replace_with*/;
        CALL_typing___PNode___after_typing( variable[5] /*vform*/)( variable[5] /*vform*/,  variable[1] /*v*/) /*PNode::after_typing*/;
        goto return_label145;
      }
    }
  }
  CALL_SUPER_typing___ACallFormExpr___after_typing(variable[0])(variable[0], variable[1]) /*super ACallFormExpr::after_typing*/;
  return_label145: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ACallFormExpr___closure_defs(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1270, LOCATE_typing___ACallFormExpr___closure_defs};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___ASendExpr___n_closure_defs(variable[2])(variable[2]) /*ASendExpr::n_closure_defs*/;
  variable[2] = TAG_Bool((variable[2] ==  NIT_NULL /*null*/) || ((variable[2] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[2])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[2], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[2])(variable[2],  NIT_NULL /*null*/) /*Object::==*/)))));
  variable[3] = variable[2];
  if (!UNTAG_Bool(variable[3])) { /* or */
    variable[3] = variable[0];
    variable[3] = CALL_parser_nodes___ASendExpr___n_closure_defs(variable[3])(variable[3]) /*ASendExpr::n_closure_defs*/;
    variable[3] = CALL_abstract_collection___Collection___is_empty(variable[3])(variable[3]) /*List::is_empty*/;
  }
  variable[2] = variable[3];
  if (UNTAG_Bool(variable[2])) { /*if*/
    variable[1] =  NIT_NULL /*null*/;
    goto return_label146;
  } else { /*if*/
    variable[2] = variable[0];
    variable[2] = CALL_parser_nodes___ASendExpr___n_closure_defs(variable[2])(variable[2]) /*ASendExpr::n_closure_defs*/;
    variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
    variable[1] = variable[2];
    goto return_label146;
  }
  return_label146: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallFormExpr___variable_create(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1279, LOCATE_typing___ACallFormExpr___variable_create};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 1279);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t typing___ACallExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1289, LOCATE_typing___ACallExpr___name};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_id(variable[2])(variable[2]) /*ACallFormExpr::n_id*/;
  variable[2] = CALL_syntax_base___Token___to_symbol(variable[2])(variable[2]) /*Token::to_symbol*/;
  variable[1] = variable[2];
  goto return_label147;
  return_label147: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1290, LOCATE_typing___ACallExpr___raw_arguments};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_args(variable[2])(variable[2]) /*ACallFormExpr::n_args*/;
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label148;
  return_label148: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallExpr___variable_create(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1284, LOCATE_typing___ACallExpr___variable_create};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ACallFormExpr___n_id(variable[3])(variable[3]) /*ACallFormExpr::n_id*/;
  variable[4] = NEW_AVarExpr_parser_prod___AVarExpr___init_avarexpr(variable[3]); /*new AVarExpr*/
  variable[3] = variable[4];
  variable[2] = variable[3];
  goto return_label149;
  return_label149: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___ACallAssignExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1299, LOCATE_typing___ACallAssignExpr___name};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_id(variable[2])(variable[2]) /*ACallFormExpr::n_id*/;
  variable[2] = CALL_lexer___Token___text(variable[2])(variable[2]) /*Token::text*/;
  variable[3] = NEW_String_string___String___with_native(BOX_NativeString("="), TAG_Int(1)); /*new String*/
  variable[2] = CALL_string___String_____plus(variable[2])(variable[2], variable[3]) /*String::+*/;
  variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
  variable[1] = variable[2];
  goto return_label150;
  return_label150: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallAssignExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1300, LOCATE_typing___ACallAssignExpr___raw_arguments};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ACallFormExpr___n_args(variable[3])(variable[3]) /*ACallFormExpr::n_args*/;
  variable[3] = CALL_array___Collection___to_a(variable[3])(variable[3]) /*Collection::to_a*/;
  variable[2] = variable[3];
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[3])(variable[3]) /*AAssignFormExpr::n_value*/;
  CALL_abstract_collection___SimpleCollection___add( variable[2] /*res*/)( variable[2] /*res*/, variable[3]) /*AbstractArray::add*/;
  variable[1] =  variable[2] /*res*/;
  goto return_label151;
  return_label151: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallAssignExpr___variable_create(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1294, LOCATE_typing___ACallAssignExpr___variable_create};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ACallFormExpr___n_id(variable[3])(variable[3]) /*ACallFormExpr::n_id*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAssignFormExpr___n_assign(variable[4])(variable[4]) /*AAssignFormExpr::n_assign*/;
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[5])(variable[5]) /*AAssignFormExpr::n_value*/;
  variable[6] = NEW_AVarAssignExpr_parser_prod___AVarAssignExpr___init_avarassignexpr(variable[3], variable[4], variable[5]); /*new AVarAssignExpr*/
  variable[3] = variable[6];
  variable[2] = variable[3];
  goto return_label152;
  return_label152: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___ACallReassignExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1314, LOCATE_typing___ACallReassignExpr___name};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_id(variable[2])(variable[2]) /*ACallFormExpr::n_id*/;
  variable[2] = CALL_syntax_base___Token___to_symbol(variable[2])(variable[2]) /*Token::to_symbol*/;
  variable[1] = variable[2];
  goto return_label153;
  return_label153: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallReassignExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1315, LOCATE_typing___ACallReassignExpr___raw_arguments};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_args(variable[2])(variable[2]) /*ACallFormExpr::n_args*/;
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label154;
  return_label154: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallReassignExpr___variable_create(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1309, LOCATE_typing___ACallReassignExpr___variable_create};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ACallFormExpr___n_id(variable[3])(variable[3]) /*ACallFormExpr::n_id*/;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AReassignFormExpr___n_assign_op(variable[4])(variable[4]) /*AReassignFormExpr::n_assign_op*/;
  variable[5] = variable[0];
  variable[5] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[5])(variable[5]) /*AReassignFormExpr::n_value*/;
  variable[6] = NEW_AVarReassignExpr_parser_prod___AVarReassignExpr___init_avarreassignexpr(variable[3], variable[4], variable[5]); /*new AVarReassignExpr*/
  variable[3] = variable[6];
  variable[2] = variable[3];
  goto return_label155;
  return_label155: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___ABraExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1319, LOCATE_typing___ABraExpr___name};
  static val_t once_value_157; static int once_bool_157; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_157) variable[2] = once_value_157;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("[]"), TAG_Int(2)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_157 = variable[2];
    once_bool_157 = true;
  }
  variable[1] = variable[2];
  goto return_label156;
  return_label156: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1320, LOCATE_typing___ABraExpr___raw_arguments};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___ABraFormExpr___n_args(variable[2])(variable[2]) /*ABraFormExpr::n_args*/;
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label158;
  return_label158: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraAssignExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1324, LOCATE_typing___ABraAssignExpr___name};
  static val_t once_value_160; static int once_bool_160; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_160) variable[2] = once_value_160;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("[]="), TAG_Int(3)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_160 = variable[2];
    once_bool_160 = true;
  }
  variable[1] = variable[2];
  goto return_label159;
  return_label159: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraAssignExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1325, LOCATE_typing___ABraAssignExpr___raw_arguments};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___ABraFormExpr___n_args(variable[3])(variable[3]) /*ABraFormExpr::n_args*/;
  variable[3] = CALL_array___Collection___to_a(variable[3])(variable[3]) /*Collection::to_a*/;
  variable[2] = variable[3];
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[3])(variable[3]) /*AAssignFormExpr::n_value*/;
  CALL_abstract_collection___SimpleCollection___add( variable[2] /*res*/)( variable[2] /*res*/, variable[3]) /*AbstractArray::add*/;
  variable[1] =  variable[2] /*res*/;
  goto return_label161;
  return_label161: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraReassignExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1334, LOCATE_typing___ABraReassignExpr___name};
  static val_t once_value_163; static int once_bool_163; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_163) variable[2] = once_value_163;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("[]"), TAG_Int(2)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_163 = variable[2];
    once_bool_163 = true;
  }
  variable[1] = variable[2];
  goto return_label162;
  return_label162: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraReassignExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1335, LOCATE_typing___ABraReassignExpr___raw_arguments};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___ABraFormExpr___n_args(variable[2])(variable[2]) /*ABraFormExpr::n_args*/;
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label164;
  return_label164: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AInitExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1339, LOCATE_typing___AInitExpr___name};
  static val_t once_value_166; static int once_bool_166; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  if (once_bool_166) variable[2] = once_value_166;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("init"), TAG_Int(4)); /*new String*/
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_166 = variable[2];
    once_bool_166 = true;
  }
  variable[1] = variable[2];
  goto return_label165;
  return_label165: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AInitExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1340, LOCATE_typing___AInitExpr___raw_arguments};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_parser_nodes___AInitExpr___n_args(variable[2])(variable[2]) /*AInitExpr::n_args*/;
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label167;
  return_label167: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___AClosureCallExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1344, LOCATE_typing___AClosureCallExpr___after_typing};
  val_t variable[9];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_syntax_base___AClosureCallExpr___variable(variable[4])(variable[4]) /*AClosureCallExpr::variable*/;
  variable[3] = variable[4];
  variable[5] = CALL_syntax_base___ClosureVariable___closure( variable[3] /*va*/)( variable[3] /*va*/) /*ClosureVariable::closure*/;
  variable[5] = CALL_static_type___MMClosure___signature(variable[5])(variable[5]) /*MMClosure::signature*/;
  variable[4] = variable[5];
  variable[6] = variable[0];
  variable[7] = variable[0];
  variable[7] = CALL_parser_nodes___ACallFormExpr___n_id(variable[7])(variable[7]) /*ACallFormExpr::n_id*/;
  variable[7] = CALL_syntax_base___Token___to_symbol(variable[7])(variable[7]) /*Token::to_symbol*/;
  variable[8] = variable[0];
  variable[8] = CALL_parser_nodes___ACallFormExpr___n_args(variable[8])(variable[8]) /*ACallFormExpr::n_args*/;
  variable[8] = CALL_array___Collection___to_a(variable[8])(variable[8]) /*Collection::to_a*/;
  variable[6] = CALL_typing___AAbsSendExpr___process_signature(variable[6])(variable[6],  variable[1] /*v*/,  variable[4] /*sig*/, variable[7], variable[8]) /*AAbsSendExpr::process_signature*/;
  variable[5] = variable[6];
  variable[6] = variable[0];
  variable[6] = CALL_typing___ASendExpr___closure_defs(variable[6])(variable[6]) /*ACallFormExpr::closure_defs*/;
  variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[6] ==  NIT_NULL /*null*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = variable[0];
    variable[7] = variable[0];
    variable[7] = CALL_parser_nodes___ACallFormExpr___n_id(variable[7])(variable[7]) /*ACallFormExpr::n_id*/;
    variable[7] = CALL_syntax_base___Token___to_symbol(variable[7])(variable[7]) /*Token::to_symbol*/;
    variable[8] = variable[0];
    variable[8] = CALL_typing___ASendExpr___closure_defs(variable[8])(variable[8]) /*ACallFormExpr::closure_defs*/;
    CALL_typing___AAbsSendExpr___process_closures(variable[6])(variable[6],  variable[1] /*v*/,  variable[4] /*sig*/, variable[7], variable[8]) /*AAbsSendExpr::process_closures*/;
  }
  variable[6] = TAG_Bool(( variable[5] /*args*/ ==  NIT_NULL /*null*/) || (( variable[5] /*args*/ != NIT_NULL) && UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*args*/)( variable[5] /*args*/,  NIT_NULL /*null*/) /*AbstractArray::==*/)));
  if (UNTAG_Bool(variable[6])) { /*if*/
    goto return_label168;
  }
  variable[6] = variable[0];
  ATTR_typing___AAbsSendExpr____prop(variable[6]) /*AAbsSendExpr::_prop*/ =  NIT_NULL /*null*/;
  variable[6] = variable[0];
  ATTR_typing___AAbsSendExpr____prop_signature(variable[6]) /*AAbsSendExpr::_prop_signature*/ =  variable[4] /*sig*/;
  variable[6] = variable[0];
  ATTR_typing___AAbsSendExpr____arguments(variable[6]) /*AAbsSendExpr::_arguments*/ =  variable[5] /*args*/;
  variable[6] = variable[0];
  variable[7] = CALL_static_type___MMSignature___return_type( variable[4] /*sig*/)( variable[4] /*sig*/) /*MMSignature::return_type*/;
  ATTR_typing___PExpr____stype(variable[6]) /*PExpr::_stype*/ = variable[7];
  return_label168: while(false);
  tracehead = trace.prev;
  return;
}
void typing___PClosureDef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1362, LOCATE_typing___PClosureDef___accept_typing};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_typing___PClosureDef____accept_typing2(variable[3]) /*PClosureDef::_accept_typing2*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    CALL_SUPER_typing___PClosureDef___accept_typing(variable[0])(variable[0], variable[1]) /*super PClosureDef::accept_typing*/;
  }
  return_label169: while(false);
  tracehead = trace.prev;
  return;
}
void typing___PClosureDef___accept_typing2(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 1368, LOCATE_typing___PClosureDef___accept_typing2};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 1368);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void typing___AClosureDef___accept_typing2(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 1372, LOCATE_typing___AClosureDef___accept_typing2};
  val_t variable[17];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[5] = CALL_static_type___MMClosure___signature( variable[2] /*clos*/)( variable[2] /*clos*/) /*MMClosure::signature*/;
  variable[4] = variable[5];
  variable[5] = CALL_static_type___MMSignature___arity( variable[4] /*sig*/)( variable[4] /*sig*/) /*MMSignature::arity*/;
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___AClosureDef___n_id(variable[6])(variable[6]) /*AClosureDef::n_id*/;
  variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*List::length*/;
  variable[5] = TAG_Bool((variable[5])!=(variable[6]));
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[5] = variable[0];
    variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
    variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)); /*new String*/
    variable[8] = variable[7];
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[8]) /*AbstractArray::add*/;
    variable[9] = CALL_static_type___MMSignature___arity( variable[4] /*sig*/)( variable[4] /*sig*/) /*MMSignature::arity*/;
    variable[10] = variable[9];
    variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[10]) /*AbstractArray::add*/;
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString(" automatic variable names expected, "), TAG_Int(36)); /*new String*/
    variable[12] = variable[11];
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[12]) /*AbstractArray::add*/;
    variable[13] = variable[0];
    variable[13] = CALL_parser_nodes___AClosureDef___n_id(variable[13])(variable[13]) /*AClosureDef::n_id*/;
    variable[13] = CALL_abstract_collection___Collection___length(variable[13])(variable[13]) /*List::length*/;
    variable[14] = variable[13];
    variable[14] = CALL_string___Object___to_s(variable[14])(variable[14]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[14]) /*AbstractArray::add*/;
    variable[15] = NEW_String_string___String___with_native(BOX_NativeString(" found."), TAG_Int(7)); /*new String*/
    variable[16] = variable[15];
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[16]) /*AbstractArray::add*/;
    variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::error*/;
    goto return_label170;
  }
  variable[5] = variable[0];
  CALL_syntax_base___PClosureDef___closure__eq(variable[5])(variable[5],  variable[2] /*clos*/) /*PClosureDef::closure=*/;
  variable[6] = CALL_typing___TypingVisitor___closure( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::closure*/;
  variable[5] = variable[6];
  CALL_typing___TypingVisitor___closure__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[2] /*clos*/) /*TypingVisitor::closure=*/;
  variable[6] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[6] = CALL_typing___VariableContext___sub(variable[6])(variable[6]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[6]) /*TypingVisitor::variable_ctx=*/;
  variable[6] = variable[0];
  variable[7] = NEW_Array_array___Array___init(); /*new Array[AutoVariable]*/
  CALL_syntax_base___PClosureDef___variables__eq(variable[6])(variable[6], variable[7]) /*PClosureDef::variables=*/;
  variable[6] = variable[0];
  variable[6] = CALL_parser_nodes___AClosureDef___n_id(variable[6])(variable[6]) /*AClosureDef::n_id*/;
  variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*List::length*/;
  variable[7] = NEW_Range_range___Range___without_last( TAG_Int(0), variable[6]); /*new Range[Int]*/
  variable[6] = variable[7];
  variable[6] = CALL_abstract_collection___Collection___iterator(variable[6])(variable[6]) /*Range::iterator*/;
  while (true) { /*for*/
    variable[7] = CALL_abstract_collection___Iterator___is_ok(variable[6])(variable[6]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[7])) break; /*for*/
    variable[7] = CALL_abstract_collection___Iterator___item(variable[6])(variable[6]) /*Iterator::item*/;
    variable[8] = variable[7];
    variable[10] = variable[0];
    variable[10] = CALL_parser_nodes___AClosureDef___n_id(variable[10])(variable[10]) /*AClosureDef::n_id*/;
    variable[10] = CALL_abstract_collection___Map_____bra(variable[10])(variable[10],  variable[8] /*i*/) /*List::[]*/;
    variable[10] = CALL_syntax_base___Token___to_symbol(variable[10])(variable[10]) /*Token::to_symbol*/;
    variable[11] = variable[0];
    variable[12] = NEW_AutoVariable_syntax_base___AutoVariable___init(variable[10], variable[11]); /*new AutoVariable*/
    variable[10] = variable[12];
    variable[9] = variable[10];
    variable[10] = variable[0];
    variable[10] = CALL_syntax_base___PClosureDef___variables(variable[10])(variable[10]) /*PClosureDef::variables*/;
    CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10],  variable[9] /*va*/) /*AbstractArray::add*/;
    variable[10] = CALL_static_type___MMSignature_____bra( variable[4] /*sig*/)( variable[4] /*sig*/,  variable[8] /*i*/) /*MMSignature::[]*/;
    CALL_syntax_base___Variable___stype__eq( variable[9] /*va*/)( variable[9] /*va*/, variable[10]) /*Variable::stype=*/;
    variable[10] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    CALL_typing___VariableContext___add(variable[10])(variable[10],  variable[9] /*va*/) /*VariableContext::add*/;
    continue_171: while(0);
    CALL_abstract_collection___Iterator___next(variable[6])(variable[6]) /*Iterator::next*/;
  }
  break_171: while(0);
  variable[6] = variable[0];
  ATTR_typing___PClosureDef____accept_typing2(variable[6]) /*PClosureDef::_accept_typing2*/ =  TAG_Bool(true);
  variable[6] = variable[0];
  CALL_typing___PNode___accept_typing(variable[6])(variable[6],  variable[1] /*v*/) /*PClosureDef::accept_typing*/;
  CALL_typing___TypingVisitor___closure__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[5] /*old_clos*/) /*TypingVisitor::closure=*/;
  return_label170: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AIsaExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1402, LOCATE_typing___AIsaExpr___after_typing};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AIsaExpr___n_expr(variable[4])(variable[4]) /*AIsaExpr::n_expr*/;
  variable[4] = CALL_typing___PExpr___its_variable(variable[4])(variable[4]) /*PExpr::its_variable*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*variable*/ ==  NIT_NULL /*null*/) || (( variable[3] /*variable*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*variable*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*variable*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*variable*/)( variable[3] /*variable*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    variable[6] = variable[0];
    variable[6] = CALL_parser_nodes___AIsaExpr___n_type(variable[6])(variable[6]) /*AIsaExpr::n_type*/;
    variable[6] = CALL_typing___PType___stype(variable[6])(variable[6]) /*PType::stype*/;
    variable[5] = CALL_typing___VariableContext___sub_with(variable[5])(variable[5],  variable[3] /*variable*/, variable[6]) /*VariableContext::sub_with*/;
    ATTR_typing___PExpr____if_true_variable_ctx(variable[4]) /*PExpr::_if_true_variable_ctx*/ = variable[5];
  }
  variable[4] = variable[0];
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[4]) /*PExpr::_stype*/ = variable[5];
  return_label172: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAsCastExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1413, LOCATE_typing___AAsCastExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_parser_nodes___AAsCastExpr___n_expr(variable[3])(variable[3]) /*AAsCastExpr::n_expr*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AAsCastExpr___n_type(variable[4])(variable[4]) /*AAsCastExpr::n_type*/;
  variable[4] = CALL_typing___PType___stype(variable[4])(variable[4]) /*PType::stype*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label173: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AProxyExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1421, LOCATE_typing___AProxyExpr___after_typing};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_parser_nodes___AProxyExpr___n_expr(variable[4])(variable[4]) /*AProxyExpr::n_expr*/;
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  ATTR_typing___PExpr____stype(variable[3]) /*PExpr::_stype*/ = variable[4];
  return_label174: while(false);
  tracehead = trace.prev;
  return;
}
