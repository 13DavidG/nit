/* This C file is generated by NIT to compile module typing. */
#include "typing._sep.h"
void typing___MMSrcModule___do_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 25, LOCATE_typing___MMSrcModule___do_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = NEW_TypingVisitor_typing___TypingVisitor___init( variable[1] /*tc*/, variable[0]) /*new TypingVisitor*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___MMSrcModule___node(variable[0])(variable[0]) /*MMSrcModule::node*/;
  CALL_parser_prod___Visitor___visit( variable[3] /*tv*/)( variable[3] /*tv*/, variable[4]) /*TypingVisitor::visit*/;
  return_label0: while(false);
  tracehead = trace.prev;
  return;
}
void typing___TypingVisitor___visit(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 41, LOCATE_typing___TypingVisitor___visit};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[1] /*n*/ ==  NIT_NULL /*null*/) || (( variable[1] /*n*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[1] /*n*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[1] /*n*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[1] /*n*/)( variable[1] /*n*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    CALL_typing___PNode___accept_typing( variable[1] /*n*/)( variable[1] /*n*/, variable[0]) /*PNode::accept_typing*/;
  }
  return_label1: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___variable_ctx(val_t  self) {
  struct trace_t trace = {NULL, NULL, 46, LOCATE_typing___TypingVisitor___variable_ctx};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____variable_ctx( self) /*TypingVisitor::_variable_ctx*/;
}
void typing___TypingVisitor___variable_ctx__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 46, LOCATE_typing___TypingVisitor___variable_ctx__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____variable_ctx( self) /*TypingVisitor::_variable_ctx*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___base_variable_ctx(val_t  self) {
  struct trace_t trace = {NULL, NULL, 49, LOCATE_typing___TypingVisitor___base_variable_ctx};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____base_variable_ctx( self) /*TypingVisitor::_base_variable_ctx*/;
}
void typing___TypingVisitor___base_variable_ctx__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 49, LOCATE_typing___TypingVisitor___base_variable_ctx__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____base_variable_ctx( self) /*TypingVisitor::_base_variable_ctx*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___escapable_ctx(val_t  self) {
  struct trace_t trace = {NULL, NULL, 52, LOCATE_typing___TypingVisitor___escapable_ctx};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____escapable_ctx( self) /*TypingVisitor::_escapable_ctx*/;
}
void typing___TypingVisitor___escapable_ctx__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 52, LOCATE_typing___TypingVisitor___escapable_ctx__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____escapable_ctx( self) /*TypingVisitor::_escapable_ctx*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___self_var(val_t  self) {
  struct trace_t trace = {NULL, NULL, 55, LOCATE_typing___TypingVisitor___self_var};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____self_var( self) /*TypingVisitor::_self_var*/;
}
void typing___TypingVisitor___self_var__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 55, LOCATE_typing___TypingVisitor___self_var__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____self_var( self) /*TypingVisitor::_self_var*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___top_block(val_t  self) {
  struct trace_t trace = {NULL, NULL, 58, LOCATE_typing___TypingVisitor___top_block};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____top_block( self) /*TypingVisitor::_top_block*/;
}
void typing___TypingVisitor___top_block__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 58, LOCATE_typing___TypingVisitor___top_block__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____top_block( self) /*TypingVisitor::_top_block*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___explicit_super_init_calls(val_t  self) {
  struct trace_t trace = {NULL, NULL, 61, LOCATE_typing___TypingVisitor___explicit_super_init_calls};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____explicit_super_init_calls( self) /*TypingVisitor::_explicit_super_init_calls*/;
}
void typing___TypingVisitor___explicit_super_init_calls__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 61, LOCATE_typing___TypingVisitor___explicit_super_init_calls__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____explicit_super_init_calls( self) /*TypingVisitor::_explicit_super_init_calls*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___explicit_other_init_call(val_t  self) {
  struct trace_t trace = {NULL, NULL, 64, LOCATE_typing___TypingVisitor___explicit_other_init_call};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____explicit_other_init_call( self) /*TypingVisitor::_explicit_other_init_call*/;
}
void typing___TypingVisitor___explicit_other_init_call__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 64, LOCATE_typing___TypingVisitor___explicit_other_init_call__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____explicit_other_init_call( self) /*TypingVisitor::_explicit_other_init_call*/ =  param0;
  tracehead = trace.prev;
  return;
}
void typing___TypingVisitor___use_if_true_variable_ctx(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 67, LOCATE_typing___TypingVisitor___use_if_true_variable_ctx};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___PExpr___if_true_variable_ctx( variable[1] /*e*/)( variable[1] /*e*/) /*PExpr::if_true_variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*ctx*/ ==  NIT_NULL /*null*/) || (( variable[3] /*ctx*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*ctx*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*ctx*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*ctx*/)( variable[3] /*ctx*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    CALL_typing___TypingVisitor___variable_ctx__eq(variable[0])(variable[0],  variable[3] /*ctx*/) /*TypingVisitor::variable_ctx=*/;
  }
  return_label2: while(false);
  tracehead = trace.prev;
  return;
}
void typing___TypingVisitor___use_if_false_variable_ctx(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 74, LOCATE_typing___TypingVisitor___use_if_false_variable_ctx};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___PExpr___if_false_variable_ctx( variable[1] /*e*/)( variable[1] /*e*/) /*PExpr::if_false_variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*ctx*/ ==  NIT_NULL /*null*/) || (( variable[3] /*ctx*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*ctx*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*ctx*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*ctx*/)( variable[3] /*ctx*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    CALL_typing___TypingVisitor___variable_ctx__eq(variable[0])(variable[0],  variable[3] /*ctx*/) /*TypingVisitor::variable_ctx=*/;
  }
  return_label3: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___once_count(val_t  self) {
  struct trace_t trace = {NULL, NULL, 81, LOCATE_typing___TypingVisitor___once_count};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___TypingVisitor____once_count( self) /*TypingVisitor::_once_count*/;
}
void typing___TypingVisitor___once_count__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 81, LOCATE_typing___TypingVisitor___once_count__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  ATTR_typing___TypingVisitor____once_count( self) /*TypingVisitor::_once_count*/ =  param0;
  tracehead = trace.prev;
  return;
}
void typing___TypingVisitor___init(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 84, LOCATE_typing___TypingVisitor___init};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_TypingVisitor].i]) return;
  /* Register variable[3]: Method return value and escape marker */
  CALL_syntax_base___AbsSyntaxVisitor___init(variable[0])(variable[0], variable[1], variable[2], init_table /*YYY*/) /*AbsSyntaxVisitor::init*/;
  return_label4: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_TypingVisitor].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t typing___TypingVisitor___get_default_constructor_for(val_t  self, val_t  param0, val_t  param1, val_t  param2) {
  struct trace_t trace = {NULL, NULL, 86, LOCATE_typing___TypingVisitor___get_default_constructor_for};
        static val_t once_value_7; static int once_bool_7; /* Once value for variable[16]*/
          static val_t once_value_8 = NIT_NULL; /* Once value for string variable[16]*/
        static val_t once_value_10 = NIT_NULL; /* Once value for string variable[14]*/
        static val_t once_value_11 = NIT_NULL; /* Once value for string variable[14]*/
        static val_t once_value_12 = NIT_NULL; /* Once value for string variable[14]*/
      static val_t once_value_13 = NIT_NULL; /* Once value for string variable[11]*/
      static val_t once_value_14 = NIT_NULL; /* Once value for string variable[11]*/
      static val_t once_value_15 = NIT_NULL; /* Once value for string variable[11]*/
      static val_t once_value_16 = NIT_NULL; /* Once value for string variable[11]*/
          static val_t once_value_18 = NIT_NULL; /* Once value for string variable[14]*/
          static val_t once_value_19 = NIT_NULL; /* Once value for string variable[14]*/
          static val_t once_value_20 = NIT_NULL; /* Once value for string variable[14]*/
        static val_t once_value_21 = NIT_NULL; /* Once value for string variable[11]*/
        static val_t once_value_22 = NIT_NULL; /* Once value for string variable[11]*/
        static val_t once_value_23 = NIT_NULL; /* Once value for string variable[11]*/
        static val_t once_value_24 = NIT_NULL; /* Once value for string variable[11]*/
        static val_t once_value_25 = NIT_NULL; /* Once value for string variable[10]*/
        static val_t once_value_26 = NIT_NULL; /* Once value for string variable[10]*/
  val_t variable[17];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Method return value and escape marker */
  /* Register variable[5]: Local variable */
  variable[5] = variable[0];
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = NEW_Array_array___Array___init() /*new Array[MMMethod]*/;
  variable[6] = variable[7];
  /* Register variable[7]: Local variable */
  /* Register variable[8]: Result */
  variable[8] = NEW_Array_array___Array___init() /*new Array[MMMethod]*/;
  variable[7] = variable[8];
  /* Register variable[8]: Local variable */
  /* Register variable[9]: Result */
  variable[9] = CALL_static_type___MMLocalProperty___signature( variable[3] /*prop*/)( variable[3] /*prop*/) /*MMLocalProperty::signature*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_static_type___MMSignature___arity(variable[9])(variable[9]) /*MMSignature::arity*/;
  variable[8] = variable[9];
  /* Register variable[9]: Result */
  variable[9] = CALL_abstractmetamodel___MMLocalClass___global_properties( variable[2] /*c*/)( variable[2] /*c*/) /*MMLocalClass::global_properties*/;
  /* Register variable[9]: For iterator */
  variable[9] = CALL_abstract_collection___Collection___iterator(variable[9])(variable[9]) /*Collection::iterator*/;
  while (true) { /*for*/
    /* Register variable[10]: For 'is_ok' result */
    variable[10] = CALL_abstract_collection___Iterator___is_ok(variable[9])(variable[9]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[10])) break; /*for*/
    variable[10] = CALL_abstract_collection___Iterator___item(variable[9])(variable[9]) /*Iterator::item*/ /* Ensure var: For item*/;
    /* Register variable[11]: Local variable */
    variable[11] = variable[10];
    /* Register variable[12]: Result */
    variable[12] = CALL_abstractmetamodel___MMGlobalProperty___is_init_for( variable[11] /*g*/)( variable[11] /*g*/,  variable[2] /*c*/) /*MMGlobalProperty::is_init_for*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[12])))) { /*if*/
      goto continue_6;
    }
    /* Register variable[12]: Local variable */
    /* Register variable[13]: Result */
    variable[13] = CALL_abstractmetamodel___MMLocalClass_____bra( variable[2] /*c*/)( variable[2] /*c*/,  variable[11] /*g*/) /*MMLocalClass::[]*/;
    variable[12] = variable[13];
    /* Register variable[13]: Local variable */
    /* Register variable[14]: Result */
    variable[14] = CALL_static_type___MMLocalClass___get_type( variable[2] /*c*/)( variable[2] /*c*/) /*MMLocalClass::get_type*/;
    /* Register variable[14]: Result */
    variable[14] = CALL_static_type___MMLocalProperty___signature_for( variable[12] /*gp*/)( variable[12] /*gp*/, variable[14]) /*MMLocalProperty::signature_for*/;
    variable[13] = variable[14];
    /* Register variable[14]: Result */
    variable[14] = TAG_Bool(( variable[12] /*gp*/==NIT_NULL) || VAL_ISA( variable[12] /*gp*/, COLOR_MMSrcMethod, ID_MMSrcMethod)) /*cast MMSrcMethod*/;
    if (!UNTAG_Bool(variable[14])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___TypingVisitor___get_default_constructor_for, LOCATE_typing, 98); nit_exit(1);}
    /* Register variable[14]: Local variable */
    /* Register variable[15]: Result */
    variable[15] = CALL_static_type___MMSignature___arity( variable[13] /*gps*/)( variable[13] /*gps*/) /*MMSignature::arity*/;
    variable[14] = variable[15];
    /* Register variable[15]: Result */
    variable[15] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[3] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*prop*/)( variable[3] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    /* Ensure var variable[15]: Left 'and' operand*/
    if (UNTAG_Bool(variable[15])) { /* and */
      /* Register variable[15]: Result */
      variable[15] = CALL_abstractmetamodel___MMLocalProperty___name( variable[12] /*gp*/)( variable[12] /*gp*/) /*MMLocalProperty::name*/;
      /* Register variable[16]: Result */
      variable[16] = CALL_abstractmetamodel___MMLocalProperty___name( variable[3] /*prop*/)( variable[3] /*prop*/) /*MMLocalProperty::name*/;
      /* Register variable[15]: Result */
      variable[15] = TAG_Bool((variable[15] == variable[16]) || ((variable[15] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[15])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[15],variable[16])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[15])(variable[15], variable[16]) /*Object::==*/)))));
    }
    /* Register variable[15]: Result */
    if (UNTAG_Bool(variable[15])) { /*if*/
      /* Register variable[15]: Result */
      variable[15] = TAG_Bool(( variable[14] /*garity*/)==( TAG_Int(0)));
      /* Ensure var variable[15]: Left 'or' operand*/
      if (!UNTAG_Bool(variable[15])) { /* or */
        /* Register variable[15]: Result */
        variable[15] = TAG_Bool(( variable[8] /*parity*/)==( variable[14] /*garity*/));
        /* Ensure var variable[15]: Left 'and' operand*/
        if (UNTAG_Bool(variable[15])) { /* and */
          /* Register variable[15]: Result */
          variable[15] = CALL_static_type___MMLocalProperty___signature( variable[3] /*prop*/)( variable[3] /*prop*/) /*MMLocalProperty::signature*/;
          /* Register variable[15]: Result */
          variable[15] = CALL_static_type___MMSignature_____l(variable[15])(variable[15],  variable[13] /*gps*/) /*MMSignature::<*/;
        }
        /* Register variable[15]: Result */
      }
      /* Register variable[15]: Result */
      if (UNTAG_Bool(variable[15])) { /*if*/
        variable[4] =  variable[12] /*gp*/;
        goto return_label5;
      } else { /*if*/
        CALL_abstract_collection___SimpleCollection___add( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/,  variable[12] /*gp*/) /*AbstractArray::add*/;
      }
    } else { /*if*/
      /* Register variable[15]: Result */
      variable[15] = TAG_Bool(( variable[14] /*garity*/)==( TAG_Int(0)));
      /* Ensure var variable[15]: Left 'and' operand*/
      if (UNTAG_Bool(variable[15])) { /* and */
        /* Register variable[15]: Result */
        variable[15] = CALL_abstractmetamodel___MMLocalProperty___name( variable[12] /*gp*/)( variable[12] /*gp*/) /*MMLocalProperty::name*/;
        /* Register variable[16]: Once expression result */
        if (once_bool_7) variable[16] = once_value_7;
        else {
          /* Register variable[16]: Once String constant */
          if (once_value_8 != NIT_NULL) variable[16] = once_value_8;
          else {
            variable[16] = NEW_String_string___String___with_native(BOX_NativeString("init"), TAG_Int(4)) /*new String*/;
            once_value_8 = variable[16];
          }
          /* Register variable[16]: Result */
          /* Register variable[16]: Result */
          variable[16] = CALL_symbol___String___to_symbol(variable[16])(variable[16]) /*String::to_symbol*/;
          once_value_7 = variable[16];
          once_bool_7 = true;
        }
        /* Register variable[16]: Result */
        /* Register variable[15]: Result */
        variable[15] = TAG_Bool((variable[15] == variable[16]) || ((variable[15] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[15])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[15],variable[16])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[15])(variable[15], variable[16]) /*Object::==*/)))));
      }
      /* Register variable[15]: Result */
      if (UNTAG_Bool(variable[15])) { /*if*/
        CALL_abstract_collection___SimpleCollection___add( variable[6] /*candidates*/)( variable[6] /*candidates*/,  variable[12] /*gp*/) /*AbstractArray::add*/;
        CALL_abstract_collection___SimpleCollection___add( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/,  variable[12] /*gp*/) /*AbstractArray::add*/;
      } else { /*if*/
        CALL_abstract_collection___SimpleCollection___add( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/,  variable[12] /*gp*/) /*AbstractArray::add*/;
      }
    }
    continue_6: while(0);
    CALL_abstract_collection___Iterator___next(variable[9])(variable[9]) /*Iterator::next*/;
  }
  break_6: while(0);
  /* Register variable[9]: Result */
  variable[9] = CALL_abstract_collection___Collection___length( variable[6] /*candidates*/)( variable[6] /*candidates*/) /*AbstractArrayRead::length*/;
  /* Register variable[9]: Result */
  variable[9] = TAG_Bool((variable[9])==( TAG_Int(1)));
  if (UNTAG_Bool(variable[9])) { /*if*/
    /* Register variable[9]: Result */
    variable[9] = CALL_abstract_collection___Collection___first( variable[6] /*candidates*/)( variable[6] /*candidates*/) /*IndexedCollectionRead::first*/;
    variable[4] = variable[9];
    goto return_label5;
  } else { /*if*/
    /* Register variable[9]: Result */
    variable[9] = CALL_abstract_collection___Collection___length( variable[6] /*candidates*/)( variable[6] /*candidates*/) /*AbstractArrayRead::length*/;
    /* Register variable[9]: Result */
    variable[9] = TAG_Bool(UNTAG_Int(variable[9])>UNTAG_Int( TAG_Int(0)));
    if (UNTAG_Bool(variable[9])) { /*if*/
      /* Register variable[9]: Local variable */
      /* Register variable[10]: Result */
      variable[10] = NEW_Array_array___Array___init() /*new Array[String]*/;
      variable[9] = variable[10];
      /* Register variable[10]: For iterator */
      variable[10] = CALL_abstract_collection___Collection___iterator( variable[6] /*candidates*/)( variable[6] /*candidates*/) /*AbstractArrayRead::iterator*/;
      while (true) { /*for*/
        /* Register variable[11]: For 'is_ok' result */
        variable[11] = CALL_abstract_collection___Iterator___is_ok(variable[10])(variable[10]) /*ArrayIterator::is_ok*/;
        if (!UNTAG_Bool(variable[11])) break; /*for*/
        variable[11] = CALL_abstract_collection___Iterator___item(variable[10])(variable[10]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
        /* Register variable[12]: Local variable */
        variable[12] = variable[11];
        variable[13] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[14]: Once String constant */
        if (once_value_10 != NIT_NULL) variable[14] = once_value_10;
        else {
          variable[14] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
          once_value_10 = variable[14];
        }
        /* Register variable[14]: Result */
        /* Ensure var variable[14]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[14]) /*AbstractArray::add*/;
        /* Register variable[14]: Result */
        variable[14] = CALL_abstractmetamodel___MMLocalProperty___full_name( variable[12] /*p*/)( variable[12] /*p*/) /*MMLocalProperty::full_name*/;
        /* Ensure var variable[14]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[14]) /*AbstractArray::add*/;
        /* Register variable[14]: Once String constant */
        if (once_value_11 != NIT_NULL) variable[14] = once_value_11;
        else {
          variable[14] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
          once_value_11 = variable[14];
        }
        /* Register variable[14]: Result */
        /* Ensure var variable[14]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[14]) /*AbstractArray::add*/;
        /* Register variable[14]: Result */
        variable[14] = CALL_static_type___MMLocalProperty___signature( variable[12] /*p*/)( variable[12] /*p*/) /*MMLocalProperty::signature*/;
        /* Ensure var variable[14]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], CALL_string___Object___to_s(variable[14])(variable[14]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[14]: Once String constant */
        if (once_value_12 != NIT_NULL) variable[14] = once_value_12;
        else {
          variable[14] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
          once_value_12 = variable[14];
        }
        /* Register variable[14]: Result */
        /* Ensure var variable[14]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[14]) /*AbstractArray::add*/;
        /* Register variable[13]: Result */
        variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
        CALL_abstract_collection___SimpleCollection___add( variable[9] /*a*/)( variable[9] /*a*/, variable[13]) /*AbstractArray::add*/;
        continue_9: while(0);
        CALL_abstract_collection___Iterator___next(variable[10])(variable[10]) /*ArrayIterator::next*/;
      }
      break_9: while(0);
      variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[11]: Once String constant */
      if (once_value_13 != NIT_NULL) variable[11] = once_value_13;
      else {
        variable[11] = NEW_String_string___String___with_native(BOX_NativeString("Error: Conflicting default constructor to call for "), TAG_Int(51)) /*new String*/;
        once_value_13 = variable[11];
      }
      /* Register variable[11]: Result */
      /* Ensure var variable[11]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
      variable[11] =  variable[2] /*c*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[11]: Once String constant */
      if (once_value_14 != NIT_NULL) variable[11] = once_value_14;
      else {
        variable[11] = NEW_String_string___String___with_native(BOX_NativeString(": "), TAG_Int(2)) /*new String*/;
        once_value_14 = variable[11];
      }
      /* Register variable[11]: Result */
      /* Ensure var variable[11]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
      /* Register variable[11]: Once String constant */
      if (once_value_15 != NIT_NULL) variable[11] = once_value_15;
      else {
        variable[11] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)) /*new String*/;
        once_value_15 = variable[11];
      }
      /* Register variable[11]: Result */
      /* Register variable[11]: Result */
      variable[11] = CALL_string___Collection___join( variable[9] /*a*/)( variable[9] /*a*/, variable[11]) /*Collection::join*/;
      /* Ensure var variable[11]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
      /* Register variable[11]: Once String constant */
      if (once_value_16 != NIT_NULL) variable[11] = once_value_16;
      else {
        variable[11] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
        once_value_16 = variable[11];
      }
      /* Register variable[11]: Result */
      /* Ensure var variable[11]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
      /* Register variable[10]: Result */
      variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[5] /*v*/)( variable[5] /*v*/,  variable[1] /*n*/, variable[10]) /*AbsSyntaxVisitor::error*/;
      variable[4] =  NIT_NULL /*null*/;
      goto return_label5;
    } else { /*if*/
      /* Register variable[9]: Result */
      variable[9] = CALL_abstract_collection___Collection___length( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/) /*AbstractArrayRead::length*/;
      /* Register variable[9]: Result */
      variable[9] = TAG_Bool(UNTAG_Int(variable[9])>UNTAG_Int( TAG_Int(0)));
      if (UNTAG_Bool(variable[9])) { /*if*/
        /* Register variable[9]: Local variable */
        /* Register variable[10]: Result */
        variable[10] = NEW_Array_array___Array___init() /*new Array[String]*/;
        variable[9] = variable[10];
        /* Register variable[10]: For iterator */
        variable[10] = CALL_abstract_collection___Collection___iterator( variable[7] /*false_candidates*/)( variable[7] /*false_candidates*/) /*AbstractArrayRead::iterator*/;
        while (true) { /*for*/
          /* Register variable[11]: For 'is_ok' result */
          variable[11] = CALL_abstract_collection___Iterator___is_ok(variable[10])(variable[10]) /*ArrayIterator::is_ok*/;
          if (!UNTAG_Bool(variable[11])) break; /*for*/
          variable[11] = CALL_abstract_collection___Iterator___item(variable[10])(variable[10]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
          /* Register variable[12]: Local variable */
          variable[12] = variable[11];
          variable[13] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
          /* Register variable[14]: Once String constant */
          if (once_value_18 != NIT_NULL) variable[14] = once_value_18;
          else {
            variable[14] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
            once_value_18 = variable[14];
          }
          /* Register variable[14]: Result */
          /* Ensure var variable[14]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[14]) /*AbstractArray::add*/;
          /* Register variable[14]: Result */
          variable[14] = CALL_abstractmetamodel___MMLocalProperty___full_name( variable[12] /*p*/)( variable[12] /*p*/) /*MMLocalProperty::full_name*/;
          /* Ensure var variable[14]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[14]) /*AbstractArray::add*/;
          /* Register variable[14]: Once String constant */
          if (once_value_19 != NIT_NULL) variable[14] = once_value_19;
          else {
            variable[14] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
            once_value_19 = variable[14];
          }
          /* Register variable[14]: Result */
          /* Ensure var variable[14]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[14]) /*AbstractArray::add*/;
          /* Register variable[14]: Result */
          variable[14] = CALL_static_type___MMLocalProperty___signature( variable[12] /*p*/)( variable[12] /*p*/) /*MMLocalProperty::signature*/;
          /* Ensure var variable[14]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], CALL_string___Object___to_s(variable[14])(variable[14]) /*Object::to_s*/) /*AbstractArray::add*/;
          /* Register variable[14]: Once String constant */
          if (once_value_20 != NIT_NULL) variable[14] = once_value_20;
          else {
            variable[14] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
            once_value_20 = variable[14];
          }
          /* Register variable[14]: Result */
          /* Ensure var variable[14]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[13])(variable[13], variable[14]) /*AbstractArray::add*/;
          /* Register variable[13]: Result */
          variable[13] = CALL_string___Object___to_s(variable[13])(variable[13]) /*Object::to_s*/;
          CALL_abstract_collection___SimpleCollection___add( variable[9] /*a*/)( variable[9] /*a*/, variable[13]) /*AbstractArray::add*/;
          continue_17: while(0);
          CALL_abstract_collection___Iterator___next(variable[10])(variable[10]) /*ArrayIterator::next*/;
        }
        break_17: while(0);
        variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[11]: Once String constant */
        if (once_value_21 != NIT_NULL) variable[11] = once_value_21;
        else {
          variable[11] = NEW_String_string___String___with_native(BOX_NativeString("Error: there is no available compatible constrctor in "), TAG_Int(54)) /*new String*/;
          once_value_21 = variable[11];
        }
        /* Register variable[11]: Result */
        /* Ensure var variable[11]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
        variable[11] =  variable[2] /*c*/ /* Ensure var: super-string element*/;
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[11]: Once String constant */
        if (once_value_22 != NIT_NULL) variable[11] = once_value_22;
        else {
          variable[11] = NEW_String_string___String___with_native(BOX_NativeString(". Discarded candidates are "), TAG_Int(27)) /*new String*/;
          once_value_22 = variable[11];
        }
        /* Register variable[11]: Result */
        /* Ensure var variable[11]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
        /* Register variable[11]: Once String constant */
        if (once_value_23 != NIT_NULL) variable[11] = once_value_23;
        else {
          variable[11] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)) /*new String*/;
          once_value_23 = variable[11];
        }
        /* Register variable[11]: Result */
        /* Register variable[11]: Result */
        variable[11] = CALL_string___Collection___join( variable[9] /*a*/)( variable[9] /*a*/, variable[11]) /*Collection::join*/;
        /* Ensure var variable[11]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
        /* Register variable[11]: Once String constant */
        if (once_value_24 != NIT_NULL) variable[11] = once_value_24;
        else {
          variable[11] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
          once_value_24 = variable[11];
        }
        /* Register variable[11]: Result */
        /* Ensure var variable[11]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
        /* Register variable[10]: Result */
        variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[5] /*v*/)( variable[5] /*v*/,  variable[1] /*n*/, variable[10]) /*AbsSyntaxVisitor::error*/;
        variable[4] =  NIT_NULL /*null*/;
        goto return_label5;
      } else { /*if*/
        variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[10]: Once String constant */
        if (once_value_25 != NIT_NULL) variable[10] = once_value_25;
        else {
          variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: there is no available compatible constrctor in "), TAG_Int(54)) /*new String*/;
          once_value_25 = variable[10];
        }
        /* Register variable[10]: Result */
        /* Ensure var variable[10]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
        variable[10] =  variable[2] /*c*/ /* Ensure var: super-string element*/;
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[10]: Once String constant */
        if (once_value_26 != NIT_NULL) variable[10] = once_value_26;
        else {
          variable[10] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
          once_value_26 = variable[10];
        }
        /* Register variable[10]: Result */
        /* Ensure var variable[10]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
        /* Register variable[9]: Result */
        variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[5] /*v*/)( variable[5] /*v*/,  variable[1] /*n*/, variable[9]) /*AbsSyntaxVisitor::error*/;
        variable[4] =  NIT_NULL /*null*/;
        goto return_label5;
      }
    }
  }
  return_label5: while(false);
  tracehead = trace.prev;
  return variable[4];
}
void typing___PNode___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 140, LOCATE_typing___PNode___accept_typing};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_syntax_base___PNode___accept_abs_syntax_visitor(variable[0])(variable[0],  variable[1] /*v*/) /*PNode::accept_abs_syntax_visitor*/;
  CALL_typing___PNode___after_typing(variable[0])(variable[0],  variable[1] /*v*/) /*PNode::after_typing*/;
  return_label27: while(false);
  tracehead = trace.prev;
  return;
}
void typing___PNode___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 145, LOCATE_typing___PNode___after_typing};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  return_label28: while(false);
  tracehead = trace.prev;
  return;
}
void typing___PClassdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 149, LOCATE_typing___PClassdef___accept_typing};
  static val_t once_value_30 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Once String constant */
  if (once_value_30 != NIT_NULL) variable[3] = once_value_30;
  else {
    variable[3] = NEW_String_string___String___with_native(BOX_NativeString("self"), TAG_Int(4)) /*new String*/;
    once_value_30 = variable[3];
  }
  /* Register variable[3]: Result */
  /* Register variable[3]: Result */
  variable[3] = CALL_symbol___String___to_symbol(variable[3])(variable[3]) /*String::to_symbol*/;
  /* Register variable[3]: Result */
  variable[3] = NEW_ParamVariable_syntax_base___ParamVariable___init(variable[3], variable[0]) /*new ParamVariable*/;
  CALL_typing___TypingVisitor___self_var__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::self_var=*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___PClassdef___local_class(variable[0])(variable[0]) /*PClassdef::local_class*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMLocalClass___get_type(variable[4])(variable[4]) /*MMLocalClass::get_type*/;
  CALL_syntax_base___Variable___stype__eq(variable[3])(variable[3], variable[4]) /*Variable::stype=*/;
  CALL_SUPER_typing___PClassdef___accept_typing(variable[0])(variable[0], variable[1]) /*super PClassdef::accept_typing*/;
  return_label29: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAttrPropdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 158, LOCATE_typing___AAttrPropdef___accept_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_SUPER_typing___AAttrPropdef___accept_typing(variable[0])(variable[0], variable[1]) /*super AAttrPropdef::accept_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAttrPropdef___n_expr(variable[0])(variable[0]) /*AAttrPropdef::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___AAttrPropdef___n_expr(variable[0])(variable[0]) /*AAttrPropdef::n_expr*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___AAttrPropdef___prop(variable[0])(variable[0]) /*AAttrPropdef::prop*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_static_type___MMLocalProperty___signature(variable[4])(variable[4]) /*MMLocalProperty::signature*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_static_type___MMSignature___return_type(variable[4])(variable[4]) /*MMSignature::return_type*/;
    CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  }
  return_label31: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AMethPropdef___self_var(val_t  self) {
  struct trace_t trace = {NULL, NULL, 168, LOCATE_typing___AMethPropdef___self_var};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AMethPropdef____self_var( self) /*AMethPropdef::_self_var*/;
}
void typing___AMethPropdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 169, LOCATE_typing___AMethPropdef___accept_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = NEW_RootVariableContext_control_flow___RootVariableContext___init( variable[1] /*v*/, variable[0]) /*new RootVariableContext*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::base_variable_ctx=*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
  ATTR_typing___AMethPropdef____self_var(variable[0]) /*AMethPropdef::_self_var*/ = variable[3];
  CALL_SUPER_typing___AMethPropdef___accept_typing(variable[0])(variable[0], variable[1]) /*super AMethPropdef::accept_typing*/;
  return_label32: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AConcreteMethPropdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 179, LOCATE_typing___AConcreteMethPropdef___accept_typing};
    static val_t once_value_34 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_SUPER_typing___AConcreteMethPropdef___accept_typing(variable[0])(variable[0], variable[1]) /*super AConcreteMethPropdef::accept_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_control_flow___VariableContext___unreash(variable[3])(variable[3]) /*VariableContext::unreash*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3])==( TAG_Bool(false)));
  /* Ensure var variable[3]: Left 'and' operand*/
  if (UNTAG_Bool(variable[3])) { /* and */
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___AMethPropdef___method(variable[0])(variable[0]) /*AMethPropdef::method*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_static_type___MMLocalProperty___signature(variable[3])(variable[3]) /*MMLocalProperty::signature*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_static_type___MMSignature___return_type(variable[3])(variable[3]) /*MMSignature::return_type*/;
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  }
  /* Register variable[3]: Result */
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Once String constant */
    if (once_value_34 != NIT_NULL) variable[3] = once_value_34;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString("Control error: Reached end of function (a 'return' with a value was expected)."), TAG_Int(78)) /*new String*/;
      once_value_34 = variable[3];
    }
    /* Register variable[3]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::error*/;
  }
  return_label33: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AConcreteInitPropdef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 191, LOCATE_typing___AConcreteInitPropdef___accept_typing};
  val_t variable[14];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AConcreteMethPropdef___n_block(variable[0])(variable[0]) /*AConcreteMethPropdef::n_block*/;
  CALL_typing___TypingVisitor___top_block__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::top_block=*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AConcreteInitPropdef___explicit_super_init_calls(variable[0])(variable[0]) /*AConcreteInitPropdef::explicit_super_init_calls*/;
  CALL_typing___TypingVisitor___explicit_super_init_calls__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::explicit_super_init_calls=*/;
  CALL_typing___TypingVisitor___explicit_other_init_call__eq( variable[1] /*v*/)( variable[1] /*v*/,  TAG_Bool(false)) /*TypingVisitor::explicit_other_init_call=*/;
  CALL_SUPER_typing___AConcreteInitPropdef___accept_typing(variable[0])(variable[0], variable[1]) /*super AConcreteInitPropdef::accept_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___explicit_other_init_call( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::explicit_other_init_call*/;
  /* Ensure var variable[3]: Left 'or' operand*/
  if (!UNTAG_Bool(variable[3])) { /* or */
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___AMethPropdef___method(variable[0])(variable[0]) /*AMethPropdef::method*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_abstractmetamodel___MMLocalProperty___global(variable[3])(variable[3]) /*MMLocalProperty::global*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[3])(variable[3]) /*MMGlobalProperty::intro*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___AMethPropdef___method(variable[0])(variable[0]) /*AMethPropdef::method*/;
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] == variable[4]) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3],variable[4])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3], variable[4]) /*Object::==*/)))))));
  }
  /* Register variable[3]: Result */
  if (UNTAG_Bool(variable[3])) { /*if*/
  } else { /*if*/
    /* Register variable[3]: Local variable */
    variable[3] =  TAG_Int(0);
    /* Register variable[4]: Local variable */
    /* Register variable[5]: Result */
    variable[5] = CALL_typing___AConcreteInitPropdef___explicit_super_init_calls(variable[0])(variable[0]) /*AConcreteInitPropdef::explicit_super_init_calls*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArrayRead::length*/;
    variable[4] = variable[5];
    /* Register variable[5]: Local variable */
    variable[5] =  NIT_NULL /*null*/;
    /* Register variable[6]: Local variable */
    variable[6] =  NIT_NULL /*null*/;
    /* Register variable[7]: Result */
    variable[7] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
    if (UNTAG_Bool(variable[7])) { /*if*/
      /* Register variable[7]: Result */
      variable[7] = CALL_typing___AConcreteInitPropdef___explicit_super_init_calls(variable[0])(variable[0]) /*AConcreteInitPropdef::explicit_super_init_calls*/;
      /* Register variable[8]: Local variable */
      variable[8] = variable[7];
      /* Register variable[9]: Local variable */
      variable[9] =  variable[3] /*i*/;
      /* Register variable[10]: Method return value and escape marker */
      /* Register variable[11]: Result */
      variable[11] = TAG_Bool(UNTAG_Int( variable[9] /*index*/)>=UNTAG_Int( TAG_Int(0)));
      /* Ensure var variable[11]: Left 'and' operand*/
      if (UNTAG_Bool(variable[11])) { /* and */
        /* Register variable[11]: Result */
        variable[11] = ATTR_array___AbstractArrayRead____length(variable[8]) /*AbstractArrayRead::_length*/;
        /* Register variable[11]: Result */
        variable[11] = TAG_Bool(UNTAG_Int( variable[9] /*index*/)<UNTAG_Int(variable[11]));
      }
      /* Register variable[11]: Result */
      if (!UNTAG_Bool(variable[11])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 234); nit_exit(1);}
      /* Register variable[11]: Result */
      variable[11] = ATTR_array___Array____items(variable[8]) /*Array::_items*/;
      /* Register variable[11]: Result */
      variable[11] = UNBOX_NativeArray(variable[11])[UNTAG_Int( variable[9] /*index*/)];
      variable[10] = variable[11];
      goto return_label36;
      return_label36: while(false);
      /* Register variable[7]: Result */
      variable[7] = variable[10];
      variable[5] = variable[7] /*cur_m=*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_abstractmetamodel___MMLocalProperty___global( variable[5] /*cur_m*/)( variable[5] /*cur_m*/) /*MMLocalProperty::global*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[7])(variable[7]) /*MMGlobalProperty::intro*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_abstractmetamodel___MMLocalProperty___local_class(variable[7])(variable[7]) /*MMLocalProperty::local_class*/;
      /* Register variable[8]: Result */
      variable[8] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_abstractmetamodel___MMLocalClass___for_module(variable[7])(variable[7], variable[8]) /*MMLocalClass::for_module*/;
      variable[6] = variable[7] /*cur_c=*/;
    }
    /* Register variable[7]: Local variable */
    variable[7] =  TAG_Int(0);
    while (true) { /*while*/
      /* Register variable[8]: Result */
      variable[8] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
      /* Register variable[8]: Result */
      variable[8] = CALL_abstractmetamodel___MMLocalClass___cshe(variable[8])(variable[8]) /*MMLocalClass::cshe*/;
      /* Register variable[8]: Result */
      variable[8] = CALL_partial_order___PartialOrderElement___direct_greaters(variable[8])(variable[8]) /*PartialOrderElement::direct_greaters*/;
      /* Register variable[8]: Result */
      variable[8] = CALL_abstract_collection___Collection___length(variable[8])(variable[8]) /*AbstractArrayRead::length*/;
      /* Register variable[8]: Result */
      variable[8] = TAG_Bool(UNTAG_Int( variable[7] /*j*/)<UNTAG_Int(variable[8]));
      if (!UNTAG_Bool(variable[8])) break; /* while*/
      /* Register variable[8]: Local variable */
      /* Register variable[9]: Result */
      variable[9] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
      /* Register variable[9]: Result */
      variable[9] = CALL_abstractmetamodel___MMLocalClass___cshe(variable[9])(variable[9]) /*MMLocalClass::cshe*/;
      /* Register variable[9]: Result */
      variable[9] = CALL_partial_order___PartialOrderElement___direct_greaters(variable[9])(variable[9]) /*PartialOrderElement::direct_greaters*/;
      /* Register variable[10]: Local variable */
      variable[10] = variable[9];
      /* Register variable[11]: Local variable */
      variable[11] =  variable[7] /*j*/;
      /* Register variable[12]: Method return value and escape marker */
      /* Register variable[13]: Result */
      variable[13] = TAG_Bool(UNTAG_Int( variable[11] /*index*/)>=UNTAG_Int( TAG_Int(0)));
      /* Ensure var variable[13]: Left 'and' operand*/
      if (UNTAG_Bool(variable[13])) { /* and */
        /* Register variable[13]: Result */
        variable[13] = ATTR_array___AbstractArrayRead____length(variable[10]) /*AbstractArrayRead::_length*/;
        /* Register variable[13]: Result */
        variable[13] = TAG_Bool(UNTAG_Int( variable[11] /*index*/)<UNTAG_Int(variable[13]));
      }
      /* Register variable[13]: Result */
      if (!UNTAG_Bool(variable[13])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 234); nit_exit(1);}
      /* Register variable[13]: Result */
      variable[13] = ATTR_array___Array____items(variable[10]) /*Array::_items*/;
      /* Register variable[13]: Result */
      variable[13] = UNBOX_NativeArray(variable[13])[UNTAG_Int( variable[11] /*index*/)];
      variable[12] = variable[13];
      goto return_label38;
      return_label38: while(false);
      /* Register variable[9]: Result */
      variable[9] = variable[12];
      variable[8] = variable[9];
      /* Register variable[9]: Result */
      variable[9] = CALL_abstractmetamodel___MMLocalClass___global( variable[8] /*c*/)( variable[8] /*c*/) /*MMLocalClass::global*/;
      /* Register variable[9]: Result */
      variable[9] = CALL_abstractmetamodel___MMGlobalClass___is_interface(variable[9])(variable[9]) /*MMGlobalClass::is_interface*/;
      /* Ensure var variable[9]: Left 'or' operand*/
      if (!UNTAG_Bool(variable[9])) { /* or */
        /* Register variable[9]: Result */
        variable[9] = CALL_abstractmetamodel___MMLocalClass___global( variable[8] /*c*/)( variable[8] /*c*/) /*MMLocalClass::global*/;
        /* Register variable[9]: Result */
        variable[9] = CALL_abstractmetamodel___MMGlobalClass___is_universal(variable[9])(variable[9]) /*MMGlobalClass::is_universal*/;
      }
      /* Register variable[9]: Result */
      /* Ensure var variable[9]: Left 'or' operand*/
      if (!UNTAG_Bool(variable[9])) { /* or */
        /* Register variable[9]: Result */
        variable[9] = CALL_abstractmetamodel___MMLocalClass___global( variable[8] /*c*/)( variable[8] /*c*/) /*MMLocalClass::global*/;
        /* Register variable[9]: Result */
        variable[9] = CALL_abstractmetamodel___MMGlobalClass___is_mixin(variable[9])(variable[9]) /*MMGlobalClass::is_mixin*/;
      }
      /* Register variable[9]: Result */
      if (UNTAG_Bool(variable[9])) { /*if*/
        variable[7] = TAG_Int(UNTAG_Int(variable[7])+UNTAG_Int( TAG_Int(1))) /*j*/;
      } else { /*if*/
        /* Register variable[9]: Result */
        variable[9] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[6] /*cur_c*/ ==  NIT_NULL /*null*/) || (( variable[6] /*cur_c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[6] /*cur_c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[6] /*cur_c*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[6] /*cur_c*/)( variable[6] /*cur_c*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
        /* Ensure var variable[9]: Left 'and' operand*/
        if (UNTAG_Bool(variable[9])) { /* and */
          /* Register variable[9]: Result */
          variable[9] = CALL_abstractmetamodel___MMLocalClass___cshe( variable[8] /*c*/)( variable[8] /*c*/) /*MMLocalClass::cshe*/;
          /* Register variable[9]: Result */
          variable[9] = CALL_partial_order___PartialOrderElement_____leq(variable[9])(variable[9],  variable[6] /*cur_c*/) /*PartialOrderElement::<=*/;
          /* Ensure var variable[9]: Left 'or' operand*/
          if (!UNTAG_Bool(variable[9])) { /* or */
            /* Register variable[9]: Result */
            variable[9] = CALL_abstractmetamodel___MMLocalClass___global( variable[6] /*cur_c*/)( variable[6] /*cur_c*/) /*MMLocalClass::global*/;
            /* Register variable[9]: Result */
            variable[9] = CALL_abstractmetamodel___MMGlobalClass___is_mixin(variable[9])(variable[9]) /*MMGlobalClass::is_mixin*/;
          }
          /* Register variable[9]: Result */
        }
        /* Register variable[9]: Result */
        if (UNTAG_Bool(variable[9])) { /*if*/
          /* Register variable[9]: Result */
          variable[9] = TAG_Bool(( variable[8] /*c*/ ==  variable[6] /*cur_c*/) || (( variable[8] /*c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[8] /*c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[8] /*c*/, variable[6] /*cur_c*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[8] /*c*/)( variable[8] /*c*/,  variable[6] /*cur_c*/) /*Object::==*/)))));
          if (UNTAG_Bool(variable[9])) { /*if*/
            variable[7] = TAG_Int(UNTAG_Int(variable[7])+UNTAG_Int( TAG_Int(1))) /*j*/;
          }
          /* Register variable[9]: Result */
          variable[9] = CALL_typing___AConcreteInitPropdef___super_init_calls(variable[0])(variable[0]) /*AConcreteInitPropdef::super_init_calls*/;
          CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9],  variable[5] /*cur_m*/) /*AbstractArray::add*/;
          variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
          /* Register variable[9]: Result */
          variable[9] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
          if (UNTAG_Bool(variable[9])) { /*if*/
            /* Register variable[9]: Result */
            variable[9] = CALL_typing___AConcreteInitPropdef___explicit_super_init_calls(variable[0])(variable[0]) /*AConcreteInitPropdef::explicit_super_init_calls*/;
            /* Register variable[10]: Local variable */
            variable[10] = variable[9];
            /* Register variable[11]: Local variable */
            variable[11] =  variable[3] /*i*/;
            /* Register variable[12]: Method return value and escape marker */
            /* Register variable[13]: Result */
            variable[13] = TAG_Bool(UNTAG_Int( variable[11] /*index*/)>=UNTAG_Int( TAG_Int(0)));
            /* Ensure var variable[13]: Left 'and' operand*/
            if (UNTAG_Bool(variable[13])) { /* and */
              /* Register variable[13]: Result */
              variable[13] = ATTR_array___AbstractArrayRead____length(variable[10]) /*AbstractArrayRead::_length*/;
              /* Register variable[13]: Result */
              variable[13] = TAG_Bool(UNTAG_Int( variable[11] /*index*/)<UNTAG_Int(variable[13]));
            }
            /* Register variable[13]: Result */
            if (!UNTAG_Bool(variable[13])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 234); nit_exit(1);}
            /* Register variable[13]: Result */
            variable[13] = ATTR_array___Array____items(variable[10]) /*Array::_items*/;
            /* Register variable[13]: Result */
            variable[13] = UNBOX_NativeArray(variable[13])[UNTAG_Int( variable[11] /*index*/)];
            variable[12] = variable[13];
            goto return_label39;
            return_label39: while(false);
            /* Register variable[9]: Result */
            variable[9] = variable[12];
            variable[5] = variable[9] /*cur_m=*/;
            /* Register variable[9]: Result */
            variable[9] = CALL_abstractmetamodel___MMLocalProperty___global( variable[5] /*cur_m*/)( variable[5] /*cur_m*/) /*MMLocalProperty::global*/;
            /* Register variable[9]: Result */
            variable[9] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[9])(variable[9]) /*MMGlobalProperty::intro*/;
            /* Register variable[9]: Result */
            variable[9] = CALL_abstractmetamodel___MMLocalProperty___local_class(variable[9])(variable[9]) /*MMLocalProperty::local_class*/;
            /* Register variable[10]: Result */
            variable[10] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
            /* Register variable[9]: Result */
            variable[9] = CALL_abstractmetamodel___MMLocalClass___for_module(variable[9])(variable[9], variable[10]) /*MMLocalClass::for_module*/;
            variable[6] = variable[9] /*cur_c=*/;
          } else { /*if*/
            variable[5] =  NIT_NULL /*null*/ /*cur_m=*/;
            variable[6] =  NIT_NULL /*null*/ /*cur_c=*/;
          }
        } else { /*if*/
          /* Register variable[9]: Local variable */
          /* Register variable[10]: Result */
          variable[10] = CALL_syntax_base___AMethPropdef___method(variable[0])(variable[0]) /*AMethPropdef::method*/;
          /* Register variable[10]: Result */
          variable[10] = CALL_typing___TypingVisitor___get_default_constructor_for( variable[1] /*v*/)( variable[1] /*v*/, variable[0],  variable[8] /*c*/, variable[10]) /*TypingVisitor::get_default_constructor_for*/;
          variable[9] = variable[10];
          /* Register variable[10]: Result */
          variable[10] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[9] /*p*/ ==  NIT_NULL /*null*/) || (( variable[9] /*p*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[9] /*p*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[9] /*p*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[9] /*p*/)( variable[9] /*p*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
          if (UNTAG_Bool(variable[10])) { /*if*/
            /* Register variable[10]: Result */
            variable[10] = CALL_typing___AConcreteInitPropdef___super_init_calls(variable[0])(variable[0]) /*AConcreteInitPropdef::super_init_calls*/;
            CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10],  variable[9] /*p*/) /*AbstractArray::add*/;
          }
          variable[7] = TAG_Int(UNTAG_Int(variable[7])+UNTAG_Int( TAG_Int(1))) /*j*/;
        }
      }
      continue_37: while(0);
    }
    break_37: while(0);
  }
  return_label35: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AConcreteInitPropdef___super_init_calls(val_t  self) {
  struct trace_t trace = {NULL, NULL, 189, LOCATE_typing___AConcreteInitPropdef___super_init_calls};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AConcreteInitPropdef____super_init_calls( self) /*AConcreteInitPropdef::_super_init_calls*/;
}
val_t typing___AConcreteInitPropdef___explicit_super_init_calls(val_t  self) {
  struct trace_t trace = {NULL, NULL, 190, LOCATE_typing___AConcreteInitPropdef___explicit_super_init_calls};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AConcreteInitPropdef____explicit_super_init_calls( self) /*AConcreteInitPropdef::_explicit_super_init_calls*/;
}
void typing___PParam___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 237, LOCATE_typing___PParam___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Result */
    variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___PParam___variable(variable[0])(variable[0]) /*PParam::variable*/;
    CALL_control_flow___VariableContext___add(variable[3])(variable[3], variable[4]) /*VariableContext::add*/;
  }
  return_label40: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AClosureDecl___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 250, LOCATE_typing___AClosureDecl___accept_typing};
        static val_t once_value_42 = NIT_NULL; /* Once value for string variable[5]*/
          static val_t once_value_43 = NIT_NULL; /* Once value for string variable[5]*/
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___PClosureDecl___variable(variable[0])(variable[0]) /*PClosureDecl::variable*/;
  CALL_control_flow___VariableContext___add(variable[3])(variable[3], variable[4]) /*VariableContext::add*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___base_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::base_variable_ctx*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::base_variable_ctx=*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_control_flow___VariableContext___sub(variable[5])(variable[5], variable[0]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___PClosureDecl___variable(variable[0])(variable[0]) /*PClosureDecl::variable*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___ClosureVariable___closure(variable[5])(variable[5]) /*ClosureVariable::closure*/;
  /* Register variable[5]: Result */
  variable[5] = NEW_EscapableClosure_escape___EscapableClosure___init(variable[0], variable[5],  NIT_NULL /*null*/) /*new EscapableClosure*/;
  ATTR_typing___AClosureDecl____escapable(variable[0]) /*AClosureDecl::_escapable*/ = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
  /* Register variable[6]: Result */
  variable[6] = ATTR_typing___AClosureDecl____escapable(variable[0]) /*AClosureDecl::_escapable*/;
  CALL_escape___EscapableContext___push(variable[5])(variable[5], variable[6]) /*EscapableContext::push*/;
  CALL_SUPER_typing___AClosureDecl___accept_typing(variable[0])(variable[0], variable[1]) /*super AClosureDecl::accept_typing*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AClosureDecl___n_expr(variable[0])(variable[0]) /*AClosureDecl::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_control_flow___VariableContext___unreash(variable[5])(variable[5]) /*VariableContext::unreash*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool((variable[5])==( TAG_Bool(false)));
    if (UNTAG_Bool(variable[5])) { /*if*/
      /* Register variable[5]: Result */
      variable[5] = CALL_syntax_base___PClosureDecl___variable(variable[0])(variable[0]) /*PClosureDecl::variable*/;
      /* Register variable[5]: Result */
      variable[5] = CALL_syntax_base___ClosureVariable___closure(variable[5])(variable[5]) /*ClosureVariable::closure*/;
      /* Register variable[5]: Result */
      variable[5] = CALL_static_type___MMClosure___signature(variable[5])(variable[5]) /*MMClosure::signature*/;
      /* Register variable[5]: Result */
      variable[5] = CALL_static_type___MMSignature___return_type(variable[5])(variable[5]) /*MMSignature::return_type*/;
      /* Register variable[5]: Result */
      variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
      if (UNTAG_Bool(variable[5])) { /*if*/
        /* Register variable[5]: Once String constant */
        if (once_value_42 != NIT_NULL) variable[5] = once_value_42;
        else {
          variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Control error: Reached end of block (a 'continue' with a value was expected)."), TAG_Int(77)) /*new String*/;
          once_value_42 = variable[5];
        }
        /* Register variable[5]: Result */
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
      } else { /*if*/
        /* Register variable[5]: Result */
        variable[5] = CALL_syntax_base___PClosureDecl___variable(variable[0])(variable[0]) /*PClosureDecl::variable*/;
        /* Register variable[5]: Result */
        variable[5] = CALL_syntax_base___ClosureVariable___closure(variable[5])(variable[5]) /*ClosureVariable::closure*/;
        /* Register variable[5]: Result */
        variable[5] = CALL_static_type___MMClosure___is_break(variable[5])(variable[5]) /*MMClosure::is_break*/;
        if (UNTAG_Bool(variable[5])) { /*if*/
          /* Register variable[5]: Once String constant */
          if (once_value_43 != NIT_NULL) variable[5] = once_value_43;
          else {
            variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Control error: Reached end of break block (an 'abort' was expected)."), TAG_Int(68)) /*new String*/;
            once_value_43 = variable[5];
          }
          /* Register variable[5]: Result */
          CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
        }
      }
    }
  }
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_control_flow___VariableContext___merge( variable[3] /*old_var_ctx*/)( variable[3] /*old_var_ctx*/, variable[5]) /*VariableContext::merge*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[4] /*old_base_var_ctx*/) /*TypingVisitor::base_variable_ctx=*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
  CALL_escape___EscapableContext___pop(variable[5])(variable[5]) /*EscapableContext::pop*/;
  return_label41: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AClosureDecl___escapable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 247, LOCATE_typing___AClosureDecl___escapable};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AClosureDecl____escapable( self) /*AClosureDecl::_escapable*/;
}
void typing___PType___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 284, LOCATE_typing___PType___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PType___get_stype(variable[0])(variable[0],  variable[1] /*v*/) /*PType::get_stype*/;
  ATTR_typing___PType____stype(variable[0]) /*PType::_stype*/ = variable[3];
  return_label44: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___PType___stype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 283, LOCATE_typing___PType___stype};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___PType____stype( self) /*PType::_stype*/;
}
val_t typing___PExpr___is_typed(val_t  self) {
  struct trace_t trace = {NULL, NULL, 291, LOCATE_typing___PExpr___is_typed};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___PExpr____is_typed( self) /*PExpr::_is_typed*/;
}
val_t typing___PExpr___is_statement(val_t  self) {
  struct trace_t trace = {NULL, NULL, 292, LOCATE_typing___PExpr___is_statement};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  /* Register variable[2]: Result */
  variable[2] = TAG_Bool((variable[2] ==  NIT_NULL /*null*/) || ((variable[2] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[2])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[2], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[2])(variable[2],  NIT_NULL /*null*/) /*Object::==*/)))));
  variable[1] = variable[2];
  goto return_label45;
  return_label45: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___PExpr___stype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 293, LOCATE_typing___PExpr___stype};
    static val_t once_value_47 = NIT_NULL; /* Once value for string variable[3]*/
    static val_t once_value_48 = NIT_NULL; /* Once value for string variable[3]*/
    static val_t once_value_49 = NIT_NULL; /* Once value for string variable[3]*/
    static val_t once_value_50 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_syntax_base___PExpr___is_typed(variable[0])(variable[0]) /*PExpr::is_typed*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[2])))) { /*if*/
    variable[2] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[3]: Once String constant */
    if (once_value_47 != NIT_NULL) variable[3] = once_value_47;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_47 = variable[3];
    }
    /* Register variable[3]: Result */
    /* Ensure var variable[3]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[3]) /*AbstractArray::add*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_prod___PNode___locate(variable[0])(variable[0]) /*Prod::locate*/;
    /* Ensure var variable[3]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[3]) /*AbstractArray::add*/;
    /* Register variable[3]: Once String constant */
    if (once_value_48 != NIT_NULL) variable[3] = once_value_48;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString(": not is_typed"), TAG_Int(14)) /*new String*/;
      once_value_48 = variable[3];
    }
    /* Register variable[3]: Result */
    /* Ensure var variable[3]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[3]) /*AbstractArray::add*/;
    /* Register variable[2]: Result */
    variable[2] = CALL_string___Object___to_s(variable[2])(variable[2]) /*Object::to_s*/;
    CALL_file___Object___print(variable[0])(variable[0], variable[2]) /*Object::print*/;
    fprintf(stderr, "Aborted"); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___PExpr___stype, LOCATE_typing, 297); nit_exit(1);
  }
  /* Register variable[2]: Result */
  variable[2] = CALL_syntax_base___PExpr___is_statement(variable[0])(variable[0]) /*PExpr::is_statement*/;
  if (UNTAG_Bool(variable[2])) { /*if*/
    variable[2] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[3]: Once String constant */
    if (once_value_49 != NIT_NULL) variable[3] = once_value_49;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_49 = variable[3];
    }
    /* Register variable[3]: Result */
    /* Ensure var variable[3]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[3]) /*AbstractArray::add*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_prod___PNode___locate(variable[0])(variable[0]) /*Prod::locate*/;
    /* Ensure var variable[3]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[3]) /*AbstractArray::add*/;
    /* Register variable[3]: Once String constant */
    if (once_value_50 != NIT_NULL) variable[3] = once_value_50;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString(": is_statement"), TAG_Int(14)) /*new String*/;
      once_value_50 = variable[3];
    }
    /* Register variable[3]: Result */
    /* Ensure var variable[3]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[3]) /*AbstractArray::add*/;
    /* Register variable[2]: Result */
    variable[2] = CALL_string___Object___to_s(variable[2])(variable[2]) /*Object::to_s*/;
    CALL_file___Object___print(variable[0])(variable[0], variable[2]) /*Object::print*/;
    fprintf(stderr, "Aborted"); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___PExpr___stype, LOCATE_typing, 301); nit_exit(1);
  }
  /* Register variable[2]: Result */
  variable[2] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  variable[1] = variable[2];
  goto return_label46;
  return_label46: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___PExpr___is_implicit_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 307, LOCATE_typing___PExpr___is_implicit_self};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  TAG_Bool(false);
  goto return_label51;
  return_label51: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___PExpr___is_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 310, LOCATE_typing___PExpr___is_self};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  TAG_Bool(false);
  goto return_label52;
  return_label52: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___PExpr___its_variable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 313, LOCATE_typing___PExpr___its_variable};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  NIT_NULL /*null*/;
  goto return_label53;
  return_label53: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___PExpr___if_true_variable_ctx(val_t  self) {
  struct trace_t trace = {NULL, NULL, 316, LOCATE_typing___PExpr___if_true_variable_ctx};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___PExpr____if_true_variable_ctx( self) /*PExpr::_if_true_variable_ctx*/;
}
val_t typing___PExpr___if_false_variable_ctx(val_t  self) {
  struct trace_t trace = {NULL, NULL, 319, LOCATE_typing___PExpr___if_false_variable_ctx};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___PExpr____if_false_variable_ctx( self) /*PExpr::_if_false_variable_ctx*/;
}
void typing___AVardeclExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 324, LOCATE_typing___AVardeclExpr___after_typing};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AVardeclExpr___n_id(variable[0])(variable[0]) /*AVardeclExpr::n_id*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___Token___to_symbol(variable[4])(variable[4]) /*Token::to_symbol*/;
  /* Register variable[4]: Result */
  variable[4] = NEW_VarVariable_syntax_base___VarVariable___init(variable[4], variable[0]) /*new VarVariable*/;
  variable[3] = variable[4];
  CALL_syntax_base___AVardeclExpr___variable__eq(variable[0])(variable[0],  variable[3] /*va*/) /*AVardeclExpr::variable=*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_control_flow___VariableContext___add(variable[4])(variable[4],  variable[3] /*va*/) /*VariableContext::add*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[0])(variable[0]) /*AVardeclExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    CALL_control_flow___VariableContext___mark_is_set(variable[4])(variable[4],  variable[3] /*va*/) /*VariableContext::mark_is_set*/;
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AVardeclExpr___n_type(variable[0])(variable[0]) /*AVardeclExpr::n_type*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AVardeclExpr___n_type(variable[0])(variable[0]) /*AVardeclExpr::n_type*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___PType___stype(variable[4])(variable[4]) /*PType::stype*/;
    CALL_syntax_base___Variable___stype__eq( variable[3] /*va*/)( variable[3] /*va*/, variable[4]) /*Variable::stype=*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[0])(variable[0]) /*AVardeclExpr::n_expr*/;
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[4])) { /*if*/
      /* Register variable[4]: Result */
      variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[0])(variable[0]) /*AVardeclExpr::n_expr*/;
      /* Register variable[5]: Result */
      variable[5] = CALL_syntax_base___Variable___stype( variable[3] /*va*/)( variable[3] /*va*/) /*Variable::stype*/;
      CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
    }
  } else { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[0])(variable[0]) /*AVardeclExpr::n_expr*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*AbsSyntaxVisitor::check_expr*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[4])))) { /*if*/
      goto return_label54;
    }
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AVardeclExpr___n_expr(variable[0])(variable[0]) /*AVardeclExpr::n_expr*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
    CALL_syntax_base___Variable___stype__eq( variable[3] /*va*/)( variable[3] /*va*/, variable[4]) /*Variable::stype=*/;
  }
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label54: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ABlockExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 345, LOCATE_typing___ABlockExpr___accept_typing};
      static val_t once_value_57 = NIT_NULL; /* Once value for string variable[7]*/
  val_t variable[8];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_control_flow___VariableContext___sub(variable[4])(variable[4], variable[0]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___ABlockExpr___n_expr(variable[0])(variable[0]) /*ABlockExpr::n_expr*/;
  /* Register variable[4]: For iterator */
  variable[4] = CALL_abstract_collection___Collection___iterator(variable[4])(variable[4]) /*List::iterator*/;
  while (true) { /*for*/
    /* Register variable[5]: For 'is_ok' result */
    variable[5] = CALL_abstract_collection___Iterator___is_ok(variable[4])(variable[4]) /*ListIterator::is_ok*/;
    if (!UNTAG_Bool(variable[5])) break; /*for*/
    variable[5] = CALL_abstract_collection___Iterator___item(variable[4])(variable[4]) /*ListIterator::item*/ /* Ensure var: For item*/;
    /* Register variable[6]: Local variable */
    variable[6] = variable[5];
    /* Register variable[7]: Result */
    variable[7] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_control_flow___VariableContext___unreash(variable[7])(variable[7]) /*VariableContext::unreash*/;
    /* Ensure var variable[7]: Left 'and' operand*/
    if (UNTAG_Bool(variable[7])) { /* and */
      /* Register variable[7]: Result */
      variable[7] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_control_flow___VariableContext___already_unreash(variable[7])(variable[7]) /*VariableContext::already_unreash*/;
      variable[7] =  TAG_Bool(!UNTAG_Bool(variable[7]));
    }
    /* Register variable[7]: Result */
    if (UNTAG_Bool(variable[7])) { /*if*/
      /* Register variable[7]: Result */
      variable[7] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
      CALL_control_flow___VariableContext___already_unreash__eq(variable[7])(variable[7],  TAG_Bool(true)) /*VariableContext::already_unreash=*/;
      /* Register variable[7]: Once String constant */
      if (once_value_57 != NIT_NULL) variable[7] = once_value_57;
      else {
        variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Warning: unreachable statement."), TAG_Int(31)) /*new String*/;
        once_value_57 = variable[7];
      }
      /* Register variable[7]: Result */
      CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/,  variable[6] /*e*/, variable[7]) /*AbsSyntaxVisitor::warning*/;
    }
    CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/,  variable[6] /*e*/) /*TypingVisitor::visit*/;
    continue_56: while(0);
    CALL_abstract_collection___Iterator___next(variable[4])(variable[4]) /*ListIterator::next*/;
  }
  break_56: while(0);
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_control_flow___VariableContext___merge( variable[3] /*old_var_ctx*/)( variable[3] /*old_var_ctx*/, variable[4]) /*VariableContext::merge*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label55: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AReturnExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 365, LOCATE_typing___AReturnExpr___after_typing};
    static val_t once_value_59 = NIT_NULL; /* Once value for string variable[4]*/
      static val_t once_value_60 = NIT_NULL; /* Once value for string variable[4]*/
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_control_flow___VariableContext___unreash__eq(variable[3])(variable[3],  TAG_Bool(true)) /*VariableContext::unreash=*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMLocalProperty___signature(variable[4])(variable[4]) /*MMLocalProperty::signature*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMSignature___return_type(variable[4])(variable[4]) /*MMSignature::return_type*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AReturnExpr___n_expr(variable[0])(variable[0]) /*AReturnExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  /* Ensure var variable[4]: Left 'and' operand*/
  if (UNTAG_Bool(variable[4])) { /* and */
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  }
  /* Register variable[4]: Result */
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Once String constant */
    if (once_value_59 != NIT_NULL) variable[4] = once_value_59;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString("Error: Return without value in a function."), TAG_Int(42)) /*new String*/;
      once_value_59 = variable[4];
    }
    /* Register variable[4]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
  } else { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AReturnExpr___n_expr(variable[0])(variable[0]) /*AReturnExpr::n_expr*/;
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
    /* Ensure var variable[4]: Left 'and' operand*/
    if (UNTAG_Bool(variable[4])) { /* and */
      /* Register variable[4]: Result */
      variable[4] = TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
    }
    /* Register variable[4]: Result */
    if (UNTAG_Bool(variable[4])) { /*if*/
      /* Register variable[4]: Once String constant */
      if (once_value_60 != NIT_NULL) variable[4] = once_value_60;
      else {
        variable[4] = NEW_String_string___String___with_native(BOX_NativeString("Error: Return with value in a procedure."), TAG_Int(40)) /*new String*/;
        once_value_60 = variable[4];
      }
      /* Register variable[4]: Result */
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[4]: Result */
      variable[4] = CALL_parser_nodes___AReturnExpr___n_expr(variable[0])(variable[0]) /*AReturnExpr::n_expr*/;
      /* Register variable[4]: Result */
      variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
      /* Ensure var variable[4]: Left 'and' operand*/
      if (UNTAG_Bool(variable[4])) { /* and */
        /* Register variable[4]: Result */
        variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
      }
      /* Register variable[4]: Result */
      if (UNTAG_Bool(variable[4])) { /*if*/
        /* Register variable[4]: Result */
        variable[4] = CALL_parser_nodes___AReturnExpr___n_expr(variable[0])(variable[0]) /*AReturnExpr::n_expr*/;
        CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4],  variable[3] /*t*/) /*AbsSyntaxVisitor::check_conform_expr*/;
      }
    }
  }
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label58: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AContinueExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 381, LOCATE_typing___AContinueExpr___after_typing};
    static val_t once_value_62 = NIT_NULL; /* Once value for string variable[4]*/
    static val_t once_value_63 = NIT_NULL; /* Once value for string variable[5]*/
      static val_t once_value_64 = NIT_NULL; /* Once value for string variable[5]*/
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_control_flow___VariableContext___unreash__eq(variable[3])(variable[3],  TAG_Bool(true)) /*VariableContext::unreash=*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_escape___AEscapeExpr___compute_escapable_block(variable[0])(variable[0], variable[4]) /*AEscapeExpr::compute_escapable_block*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[3] /*esc*/ ==  NIT_NULL /*null*/) || (( variable[3] /*esc*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*esc*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*esc*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*esc*/)( variable[3] /*esc*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label61;
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_escape___EscapableBlock___is_break_block( variable[3] /*esc*/)( variable[3] /*esc*/) /*EscapableBlock::is_break_block*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Once String constant */
    if (once_value_62 != NIT_NULL) variable[4] = once_value_62;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString("Error: 'continue' forbiden in break blocks."), TAG_Int(43)) /*new String*/;
      once_value_62 = variable[4];
    }
    /* Register variable[4]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
    goto return_label61;
  }
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_escape___EscapableBlock___continue_stype( variable[3] /*esc*/)( variable[3] /*esc*/) /*EscapableBlock::continue_stype*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AContinueExpr___n_expr(variable[0])(variable[0]) /*AContinueExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))));
  /* Ensure var variable[5]: Left 'and' operand*/
  if (UNTAG_Bool(variable[5])) { /* and */
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*t*/ ==  NIT_NULL /*null*/) || (( variable[4] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*t*/)( variable[4] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  }
  /* Register variable[5]: Result */
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Once String constant */
    if (once_value_63 != NIT_NULL) variable[5] = once_value_63;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: continue with a value required in this block."), TAG_Int(52)) /*new String*/;
      once_value_63 = variable[5];
    }
    /* Register variable[5]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
  } else { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_parser_nodes___AContinueExpr___n_expr(variable[0])(variable[0]) /*AContinueExpr::n_expr*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
    /* Ensure var variable[5]: Left 'and' operand*/
    if (UNTAG_Bool(variable[5])) { /* and */
      /* Register variable[5]: Result */
      variable[5] = TAG_Bool(( variable[4] /*t*/ ==  NIT_NULL /*null*/) || (( variable[4] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*t*/)( variable[4] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
    }
    /* Register variable[5]: Result */
    if (UNTAG_Bool(variable[5])) { /*if*/
      /* Register variable[5]: Once String constant */
      if (once_value_64 != NIT_NULL) variable[5] = once_value_64;
      else {
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: continue without value required in this block."), TAG_Int(53)) /*new String*/;
        once_value_64 = variable[5];
      }
      /* Register variable[5]: Result */
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[5]: Result */
      variable[5] = CALL_parser_nodes___AContinueExpr___n_expr(variable[0])(variable[0]) /*AContinueExpr::n_expr*/;
      /* Register variable[5]: Result */
      variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
      /* Ensure var variable[5]: Left 'and' operand*/
      if (UNTAG_Bool(variable[5])) { /* and */
        /* Register variable[5]: Result */
        variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*t*/ ==  NIT_NULL /*null*/) || (( variable[4] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*t*/)( variable[4] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
      }
      /* Register variable[5]: Result */
      if (UNTAG_Bool(variable[5])) { /*if*/
        /* Register variable[5]: Result */
        variable[5] = CALL_parser_nodes___AContinueExpr___n_expr(variable[0])(variable[0]) /*AContinueExpr::n_expr*/;
        CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[5],  variable[4] /*t*/) /*AbsSyntaxVisitor::check_conform_expr*/;
      }
    }
  }
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label61: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ABreakExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 405, LOCATE_typing___ABreakExpr___after_typing};
    static val_t once_value_66 = NIT_NULL; /* Once value for string variable[5]*/
      static val_t once_value_67 = NIT_NULL; /* Once value for string variable[5]*/
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_control_flow___VariableContext___unreash__eq(variable[3])(variable[3],  TAG_Bool(true)) /*VariableContext::unreash=*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_escape___AEscapeExpr___compute_escapable_block(variable[0])(variable[0], variable[4]) /*AEscapeExpr::compute_escapable_block*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[3] /*esc*/ ==  NIT_NULL /*null*/) || (( variable[3] /*esc*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*esc*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*esc*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*esc*/)( variable[3] /*esc*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label65;
  }
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_escape___EscapableBlock___break_list( variable[3] /*esc*/)( variable[3] /*esc*/) /*EscapableBlock::break_list*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___ABreakExpr___n_expr(variable[0])(variable[0]) /*ABreakExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))));
  /* Ensure var variable[5]: Left 'and' operand*/
  if (UNTAG_Bool(variable[5])) { /* and */
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*bl*/ ==  NIT_NULL /*null*/) || (( variable[4] /*bl*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*bl*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*bl*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*bl*/)( variable[4] /*bl*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  }
  /* Register variable[5]: Result */
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Once String constant */
    if (once_value_66 != NIT_NULL) variable[5] = once_value_66;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: break with a value required in this block."), TAG_Int(49)) /*new String*/;
      once_value_66 = variable[5];
    }
    /* Register variable[5]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
  } else { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_parser_nodes___ABreakExpr___n_expr(variable[0])(variable[0]) /*ABreakExpr::n_expr*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
    /* Ensure var variable[5]: Left 'and' operand*/
    if (UNTAG_Bool(variable[5])) { /* and */
      /* Register variable[5]: Result */
      variable[5] = TAG_Bool(( variable[4] /*bl*/ ==  NIT_NULL /*null*/) || (( variable[4] /*bl*/ != NIT_NULL) && UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*bl*/)( variable[4] /*bl*/,  NIT_NULL /*null*/) /*AbstractArrayRead::==*/)));
    }
    /* Register variable[5]: Result */
    if (UNTAG_Bool(variable[5])) { /*if*/
      /* Register variable[5]: Once String constant */
      if (once_value_67 != NIT_NULL) variable[5] = once_value_67;
      else {
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: break without value required in this block."), TAG_Int(50)) /*new String*/;
        once_value_67 = variable[5];
      }
      /* Register variable[5]: Result */
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[5]: Result */
      variable[5] = CALL_parser_nodes___ABreakExpr___n_expr(variable[0])(variable[0]) /*ABreakExpr::n_expr*/;
      /* Register variable[5]: Result */
      variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
      /* Ensure var variable[5]: Left 'and' operand*/
      if (UNTAG_Bool(variable[5])) { /* and */
        /* Register variable[5]: Result */
        variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*bl*/ ==  NIT_NULL /*null*/) || (( variable[4] /*bl*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*bl*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*bl*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*bl*/)( variable[4] /*bl*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
      }
      /* Register variable[5]: Result */
      if (UNTAG_Bool(variable[5])) { /*if*/
        /* Register variable[5]: Result */
        variable[5] = CALL_parser_nodes___ABreakExpr___n_expr(variable[0])(variable[0]) /*ABreakExpr::n_expr*/;
        CALL_abstract_collection___SimpleCollection___add( variable[4] /*bl*/)( variable[4] /*bl*/, variable[5]) /*AbstractArray::add*/;
      }
    }
  }
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label65: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAbortExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 425, LOCATE_typing___AAbortExpr___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_control_flow___VariableContext___unreash__eq(variable[3])(variable[3],  TAG_Bool(true)) /*VariableContext::unreash=*/;
  return_label68: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AIfExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 432, LOCATE_typing___AIfExpr___accept_typing};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfExpr___n_expr(variable[0])(variable[0]) /*AIfExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfExpr___n_expr(variable[0])(variable[0]) /*AIfExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfExpr___n_expr(variable[0])(variable[0]) /*AIfExpr::n_expr*/;
  CALL_typing___TypingVisitor___use_if_true_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::use_if_true_variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfExpr___n_then(variable[0])(variable[0]) /*AIfExpr::n_then*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_parser_nodes___AIfExpr___n_then(variable[0])(variable[0]) /*AIfExpr::n_then*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_control_flow___VariableContext___sub(variable[4])(variable[4], variable[5]) /*VariableContext::sub*/;
    CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::variable_ctx=*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AIfExpr___n_then(variable[0])(variable[0]) /*AIfExpr::n_then*/;
    CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  }
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[4] = variable[5];
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AIfExpr___n_expr(variable[0])(variable[0]) /*AIfExpr::n_expr*/;
  CALL_typing___TypingVisitor___use_if_false_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::use_if_false_variable_ctx*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AIfExpr___n_else(variable[0])(variable[0]) /*AIfExpr::n_else*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_parser_nodes___AIfExpr___n_else(variable[0])(variable[0]) /*AIfExpr::n_else*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_control_flow___VariableContext___sub(variable[5])(variable[5], variable[6]) /*VariableContext::sub*/;
    CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::variable_ctx=*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_parser_nodes___AIfExpr___n_else(variable[0])(variable[0]) /*AIfExpr::n_else*/;
    CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::visit*/;
  }
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___TypingVisitor___base_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::base_variable_ctx*/;
  CALL_control_flow___VariableContext___merge2( variable[3] /*old_var_ctx*/)( variable[3] /*old_var_ctx*/,  variable[4] /*then_var_ctx*/, variable[5], variable[6]) /*VariableContext::merge2*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label69: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AWhileExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 471, LOCATE_typing___AWhileExpr___accept_typing};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = NEW_EscapableBlock_escape___EscapableBlock___init(variable[0]) /*new EscapableBlock*/;
  ATTR_typing___AWhileExpr____escapable(variable[0]) /*AWhileExpr::_escapable*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = ATTR_typing___AWhileExpr____escapable(variable[0]) /*AWhileExpr::_escapable*/;
  CALL_escape___EscapableContext___push(variable[3])(variable[3], variable[4]) /*EscapableContext::push*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___base_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::base_variable_ctx*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::base_variable_ctx=*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_control_flow___VariableContext___sub(variable[5])(variable[5], variable[0]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AWhileExpr___n_expr(variable[0])(variable[0]) /*AWhileExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::visit*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AWhileExpr___n_expr(variable[0])(variable[0]) /*AWhileExpr::n_expr*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[5], variable[6]) /*AbsSyntaxVisitor::check_conform_expr*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AWhileExpr___n_expr(variable[0])(variable[0]) /*AWhileExpr::n_expr*/;
  CALL_typing___TypingVisitor___use_if_true_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::use_if_true_variable_ctx*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AWhileExpr___n_block(variable[0])(variable[0]) /*AWhileExpr::n_block*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_parser_nodes___AWhileExpr___n_block(variable[0])(variable[0]) /*AWhileExpr::n_block*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_control_flow___VariableContext___sub(variable[5])(variable[5], variable[6]) /*VariableContext::sub*/;
    CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::variable_ctx=*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_parser_nodes___AWhileExpr___n_block(variable[0])(variable[0]) /*AWhileExpr::n_block*/;
    CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::visit*/;
  }
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[4] /*old_base_var_ctx*/) /*TypingVisitor::base_variable_ctx=*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
  CALL_escape___EscapableContext___pop(variable[5])(variable[5]) /*EscapableContext::pop*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label70: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AWhileExpr___escapable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 468, LOCATE_typing___AWhileExpr___escapable};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AWhileExpr____escapable( self) /*AWhileExpr::_escapable*/;
}
void typing___AForExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 508, LOCATE_typing___AForExpr___accept_typing};
  static val_t once_value_72; static int once_bool_72; /* Once value for variable[8]*/
    static val_t once_value_73 = NIT_NULL; /* Once value for string variable[8]*/
    static val_t once_value_74 = NIT_NULL; /* Once value for string variable[7]*/
  static val_t once_value_75; static int once_bool_75; /* Once value for variable[9]*/
    static val_t once_value_76 = NIT_NULL; /* Once value for string variable[9]*/
    static val_t once_value_77 = NIT_NULL; /* Once value for string variable[9]*/
    static val_t once_value_78 = NIT_NULL; /* Once value for string variable[9]*/
  static val_t once_value_79; static int once_bool_79; /* Once value for variable[9]*/
    static val_t once_value_80 = NIT_NULL; /* Once value for string variable[9]*/
    static val_t once_value_81 = NIT_NULL; /* Once value for string variable[9]*/
    static val_t once_value_82 = NIT_NULL; /* Once value for string variable[9]*/
  static val_t once_value_83; static int once_bool_83; /* Once value for variable[9]*/
    static val_t once_value_84 = NIT_NULL; /* Once value for string variable[9]*/
    static val_t once_value_85 = NIT_NULL; /* Once value for string variable[9]*/
    static val_t once_value_86 = NIT_NULL; /* Once value for string variable[9]*/
  val_t variable[10];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = NEW_EscapableBlock_escape___EscapableBlock___init(variable[0]) /*new EscapableBlock*/;
  ATTR_typing___AForExpr____escapable(variable[0]) /*AForExpr::_escapable*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = ATTR_typing___AForExpr____escapable(variable[0]) /*AForExpr::_escapable*/;
  CALL_escape___EscapableContext___push(variable[3])(variable[3], variable[4]) /*EscapableContext::push*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___base_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::base_variable_ctx*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::base_variable_ctx=*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_control_flow___VariableContext___sub(variable[5])(variable[5], variable[0]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[5]) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AForExpr___n_id(variable[0])(variable[0]) /*AForExpr::n_id*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___Token___to_symbol(variable[6])(variable[6]) /*Token::to_symbol*/;
  /* Register variable[6]: Result */
  variable[6] = NEW_AutoVariable_syntax_base___AutoVariable___init(variable[6], variable[0]) /*new AutoVariable*/;
  variable[5] = variable[6];
  CALL_syntax_base___AForExpr___variable__eq(variable[0])(variable[0],  variable[5] /*va*/) /*AForExpr::variable=*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_control_flow___VariableContext___add(variable[6])(variable[6],  variable[5] /*va*/) /*VariableContext::add*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AForExpr___n_expr(variable[0])(variable[0]) /*AForExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[6]) /*TypingVisitor::visit*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AForExpr___n_expr(variable[0])(variable[0]) /*AForExpr::n_expr*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___AbsSyntaxVisitor___type_collection( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_collection*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[6], variable[7]) /*AbsSyntaxVisitor::check_conform_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
    goto return_label71;
  }
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_parser_nodes___AForExpr___n_expr(variable[0])(variable[0]) /*AForExpr::n_expr*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___PExpr___stype(variable[7])(variable[7]) /*PExpr::stype*/;
  variable[6] = variable[7];
  /* Register variable[7]: Result */
  variable[7] = CALL_static_type___MMType___local_class( variable[6] /*expr_type*/)( variable[6] /*expr_type*/) /*MMType::local_class*/;
  /* Register variable[8]: Once expression result */
  if (once_bool_72) variable[8] = once_value_72;
  else {
    /* Register variable[8]: Once String constant */
    if (once_value_73 != NIT_NULL) variable[8] = once_value_73;
    else {
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString("iterator"), TAG_Int(8)) /*new String*/;
      once_value_73 = variable[8];
    }
    /* Register variable[8]: Result */
    /* Register variable[8]: Result */
    variable[8] = CALL_symbol___String___to_symbol(variable[8])(variable[8]) /*String::to_symbol*/;
    once_value_72 = variable[8];
    once_bool_72 = true;
  }
  /* Register variable[8]: Result */
  /* Register variable[7]: Result */
  variable[7] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[7])(variable[7], variable[8]) /*MMLocalClass::select_method*/;
  ATTR_typing___AForExpr____meth_iterator(variable[0]) /*AForExpr::_meth_iterator*/ = variable[7];
  /* Register variable[7]: Result */
  variable[7] = ATTR_typing___AForExpr____meth_iterator(variable[0]) /*AForExpr::_meth_iterator*/;
  /* Register variable[7]: Result */
  variable[7] = TAG_Bool((variable[7] ==  NIT_NULL /*null*/) || ((variable[7] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[7])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[7], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[7])(variable[7],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[7])) { /*if*/
    /* Register variable[7]: Once String constant */
    if (once_value_74 != NIT_NULL) variable[7] = once_value_74;
    else {
      variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Error: Collection MUST have an iterate method"), TAG_Int(45)) /*new String*/;
      once_value_74 = variable[7];
    }
    /* Register variable[7]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::error*/;
    goto return_label71;
  }
  /* Register variable[7]: Local variable */
  /* Register variable[8]: Result */
  variable[8] = ATTR_typing___AForExpr____meth_iterator(variable[0]) /*AForExpr::_meth_iterator*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMLocalProperty___signature_for(variable[8])(variable[8],  variable[6] /*expr_type*/) /*MMLocalProperty::signature_for*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMSignature___return_type(variable[8])(variable[8]) /*MMSignature::return_type*/;
  variable[7] = variable[8];
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMType___local_class( variable[7] /*iter_type*/)( variable[7] /*iter_type*/) /*MMType::local_class*/;
  /* Register variable[9]: Once expression result */
  if (once_bool_75) variable[9] = once_value_75;
  else {
    /* Register variable[9]: Once String constant */
    if (once_value_76 != NIT_NULL) variable[9] = once_value_76;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("is_ok"), TAG_Int(5)) /*new String*/;
      once_value_76 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Register variable[9]: Result */
    variable[9] = CALL_symbol___String___to_symbol(variable[9])(variable[9]) /*String::to_symbol*/;
    once_value_75 = variable[9];
    once_bool_75 = true;
  }
  /* Register variable[9]: Result */
  /* Register variable[8]: Result */
  variable[8] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[8])(variable[8], variable[9]) /*MMLocalClass::select_method*/;
  ATTR_typing___AForExpr____meth_is_ok(variable[0]) /*AForExpr::_meth_is_ok*/ = variable[8];
  /* Register variable[8]: Result */
  variable[8] = ATTR_typing___AForExpr____meth_is_ok(variable[0]) /*AForExpr::_meth_is_ok*/;
  /* Register variable[8]: Result */
  variable[8] = TAG_Bool((variable[8] ==  NIT_NULL /*null*/) || ((variable[8] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[8])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[8], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[8])(variable[8],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[8])) { /*if*/
    variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[9]: Once String constant */
    if (once_value_77 != NIT_NULL) variable[9] = once_value_77;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
      once_value_77 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Ensure var variable[9]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
    variable[9] =  variable[7] /*iter_type*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[9]: Once String constant */
    if (once_value_78 != NIT_NULL) variable[9] = once_value_78;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have an is_ok method"), TAG_Int(26)) /*new String*/;
      once_value_78 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Ensure var variable[9]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[8]) /*AbsSyntaxVisitor::error*/;
    goto return_label71;
  }
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMType___local_class( variable[7] /*iter_type*/)( variable[7] /*iter_type*/) /*MMType::local_class*/;
  /* Register variable[9]: Once expression result */
  if (once_bool_79) variable[9] = once_value_79;
  else {
    /* Register variable[9]: Once String constant */
    if (once_value_80 != NIT_NULL) variable[9] = once_value_80;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("item"), TAG_Int(4)) /*new String*/;
      once_value_80 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Register variable[9]: Result */
    variable[9] = CALL_symbol___String___to_symbol(variable[9])(variable[9]) /*String::to_symbol*/;
    once_value_79 = variable[9];
    once_bool_79 = true;
  }
  /* Register variable[9]: Result */
  /* Register variable[8]: Result */
  variable[8] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[8])(variable[8], variable[9]) /*MMLocalClass::select_method*/;
  ATTR_typing___AForExpr____meth_item(variable[0]) /*AForExpr::_meth_item*/ = variable[8];
  /* Register variable[8]: Result */
  variable[8] = ATTR_typing___AForExpr____meth_item(variable[0]) /*AForExpr::_meth_item*/;
  /* Register variable[8]: Result */
  variable[8] = TAG_Bool((variable[8] ==  NIT_NULL /*null*/) || ((variable[8] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[8])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[8], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[8])(variable[8],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[8])) { /*if*/
    variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[9]: Once String constant */
    if (once_value_81 != NIT_NULL) variable[9] = once_value_81;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
      once_value_81 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Ensure var variable[9]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
    variable[9] =  variable[7] /*iter_type*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[9]: Once String constant */
    if (once_value_82 != NIT_NULL) variable[9] = once_value_82;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have an item method"), TAG_Int(25)) /*new String*/;
      once_value_82 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Ensure var variable[9]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[8]) /*AbsSyntaxVisitor::error*/;
    goto return_label71;
  }
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMType___local_class( variable[7] /*iter_type*/)( variable[7] /*iter_type*/) /*MMType::local_class*/;
  /* Register variable[9]: Once expression result */
  if (once_bool_83) variable[9] = once_value_83;
  else {
    /* Register variable[9]: Once String constant */
    if (once_value_84 != NIT_NULL) variable[9] = once_value_84;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("next"), TAG_Int(4)) /*new String*/;
      once_value_84 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Register variable[9]: Result */
    variable[9] = CALL_symbol___String___to_symbol(variable[9])(variable[9]) /*String::to_symbol*/;
    once_value_83 = variable[9];
    once_bool_83 = true;
  }
  /* Register variable[9]: Result */
  /* Register variable[8]: Result */
  variable[8] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[8])(variable[8], variable[9]) /*MMLocalClass::select_method*/;
  ATTR_typing___AForExpr____meth_next(variable[0]) /*AForExpr::_meth_next*/ = variable[8];
  /* Register variable[8]: Result */
  variable[8] = ATTR_typing___AForExpr____meth_next(variable[0]) /*AForExpr::_meth_next*/;
  /* Register variable[8]: Result */
  variable[8] = TAG_Bool((variable[8] ==  NIT_NULL /*null*/) || ((variable[8] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[8])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[8], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[8])(variable[8],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[8])) { /*if*/
    variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[9]: Once String constant */
    if (once_value_85 != NIT_NULL) variable[9] = once_value_85;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
      once_value_85 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Ensure var variable[9]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
    variable[9] =  variable[7] /*iter_type*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[9]: Once String constant */
    if (once_value_86 != NIT_NULL) variable[9] = once_value_86;
    else {
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have a next method"), TAG_Int(24)) /*new String*/;
      once_value_86 = variable[9];
    }
    /* Register variable[9]: Result */
    /* Ensure var variable[9]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[8]) /*AbsSyntaxVisitor::error*/;
    goto return_label71;
  }
  /* Register variable[8]: Local variable */
  /* Register variable[9]: Result */
  variable[9] = ATTR_typing___AForExpr____meth_item(variable[0]) /*AForExpr::_meth_item*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_static_type___MMLocalProperty___signature_for(variable[9])(variable[9],  variable[7] /*iter_type*/) /*MMLocalProperty::signature_for*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_static_type___MMSignature___return_type(variable[9])(variable[9]) /*MMSignature::return_type*/;
  variable[8] = variable[9];
  /* Register variable[9]: Result */
  variable[9] = CALL_parser_nodes___AForExpr___n_expr(variable[0])(variable[0]) /*AForExpr::n_expr*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_typing___PExpr___is_self(variable[9])(variable[9]) /*PExpr::is_self*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[9])))) { /*if*/
    /* Register variable[9]: Result */
    variable[9] = CALL_static_type___MMType___not_for_self( variable[8] /*t*/)( variable[8] /*t*/) /*MMType::not_for_self*/;
    variable[8] = variable[9] /*t=*/;
  }
  CALL_syntax_base___Variable___stype__eq( variable[5] /*va*/)( variable[5] /*va*/,  variable[8] /*t*/) /*Variable::stype=*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_parser_nodes___AForExpr___n_block(variable[0])(variable[0]) /*AForExpr::n_block*/;
  /* Register variable[9]: Result */
  variable[9] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[9] ==  NIT_NULL /*null*/) || ((variable[9] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[9])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[9], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[9])(variable[9],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[9])) { /*if*/
    /* Register variable[9]: Result */
    variable[9] = CALL_parser_nodes___AForExpr___n_block(variable[0])(variable[0]) /*AForExpr::n_block*/;
    CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[9]) /*TypingVisitor::visit*/;
  }
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[4] /*old_base_var_ctx*/) /*TypingVisitor::base_variable_ctx=*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
  CALL_escape___EscapableContext___pop(variable[9])(variable[9]) /*EscapableContext::pop*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label71: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AForExpr___escapable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 501, LOCATE_typing___AForExpr___escapable};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForExpr____escapable( self) /*AForExpr::_escapable*/;
}
val_t typing___AForExpr___meth_iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 504, LOCATE_typing___AForExpr___meth_iterator};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForExpr____meth_iterator( self) /*AForExpr::_meth_iterator*/;
}
val_t typing___AForExpr___meth_is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 505, LOCATE_typing___AForExpr___meth_is_ok};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForExpr____meth_is_ok( self) /*AForExpr::_meth_is_ok*/;
}
val_t typing___AForExpr___meth_item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 506, LOCATE_typing___AForExpr___meth_item};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForExpr____meth_item( self) /*AForExpr::_meth_item*/;
}
val_t typing___AForExpr___meth_next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 507, LOCATE_typing___AForExpr___meth_next};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AForExpr____meth_next( self) /*AForExpr::_meth_next*/;
}
void typing___AAssertExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 561, LOCATE_typing___AAssertExpr___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAssertExpr___n_expr(variable[0])(variable[0]) /*AAssertExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAssertExpr___n_expr(variable[0])(variable[0]) /*AAssertExpr::n_expr*/;
  CALL_typing___TypingVisitor___use_if_true_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::use_if_true_variable_ctx*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label87: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AVarExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 572, LOCATE_typing___AVarExpr___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  CALL_control_flow___VariableContext___check_is_set(variable[3])(variable[3], variable[0], variable[4]) /*VariableContext::check_is_set*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_control_flow___VariableContext___stype(variable[3])(variable[3], variable[4]) /*VariableContext::stype*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ = variable[3];
  return_label88: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AVarExpr___its_variable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 570, LOCATE_typing___AVarExpr___its_variable};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  variable[1] = variable[2];
  goto return_label89;
  return_label89: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___AVarAssignExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 581, LOCATE_typing___AVarAssignExpr___after_typing};
  val_t variable[8];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  CALL_control_flow___VariableContext___mark_is_set(variable[3])(variable[3], variable[4]) /*VariableContext::mark_is_set*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_control_flow___VariableContext___stype(variable[4])(variable[4], variable[5]) /*VariableContext::stype*/;
  variable[3] = variable[4];
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___base_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::base_variable_ctx*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_control_flow___VariableContext___stype(variable[5])(variable[5], variable[6]) /*VariableContext::stype*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[0])(variable[0]) /*AAssignFormExpr::n_value*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[5],  variable[4] /*btype*/) /*AbsSyntaxVisitor::check_conform_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
    goto return_label90;
  }
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[0])(variable[0]) /*AAssignFormExpr::n_value*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___PExpr___stype(variable[7])(variable[7]) /*PExpr::stype*/;
  CALL_control_flow___VariableContext___stype__eq(variable[5])(variable[5], variable[6], variable[7]) /*VariableContext::stype=*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label90: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AReassignFormExpr___do_rvalue_typing(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 598, LOCATE_typing___AReassignFormExpr___do_rvalue_typing};
    static val_t once_value_92 = NIT_NULL; /* Once value for string variable[7]*/
    static val_t once_value_93 = NIT_NULL; /* Once value for string variable[7]*/
    static val_t once_value_94 = NIT_NULL; /* Once value for string variable[7]*/
  val_t variable[10];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[2] /*type_lvalue*/ ==  NIT_NULL /*null*/) || (( variable[2] /*type_lvalue*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[2] /*type_lvalue*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[2] /*type_lvalue*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[2] /*type_lvalue*/)( variable[2] /*type_lvalue*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[3] =  NIT_NULL /*null*/;
    goto return_label91;
  }
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AReassignFormExpr___n_assign_op(variable[0])(variable[0]) /*AReassignFormExpr::n_assign_op*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___PAssignOp___method_name(variable[5])(variable[5]) /*PAssignOp::method_name*/;
  variable[4] = variable[5];
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_static_type___MMType___local_class( variable[2] /*type_lvalue*/)( variable[2] /*type_lvalue*/) /*MMType::local_class*/;
  variable[5] = variable[6];
  /* Register variable[6]: Result */
  variable[6] = CALL_abstractmetamodel___MMLocalClass___has_global_property_by_name( variable[5] /*lc*/)( variable[5] /*lc*/,  variable[4] /*name*/) /*MMLocalClass::has_global_property_by_name*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
    variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[7]: Once String constant */
    if (once_value_92 != NIT_NULL) variable[7] = once_value_92;
    else {
      variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Error: Method '"), TAG_Int(15)) /*new String*/;
      once_value_92 = variable[7];
    }
    /* Register variable[7]: Result */
    /* Ensure var variable[7]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[7]) /*AbstractArray::add*/;
    variable[7] =  variable[4] /*name*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[7]: Once String constant */
    if (once_value_93 != NIT_NULL) variable[7] = once_value_93;
    else {
      variable[7] = NEW_String_string___String___with_native(BOX_NativeString("' doesn't exists in "), TAG_Int(20)) /*new String*/;
      once_value_93 = variable[7];
    }
    /* Register variable[7]: Result */
    /* Ensure var variable[7]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[7]) /*AbstractArray::add*/;
    variable[7] =  variable[2] /*type_lvalue*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[7]: Once String constant */
    if (once_value_94 != NIT_NULL) variable[7] = once_value_94;
    else {
      variable[7] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
      once_value_94 = variable[7];
    }
    /* Register variable[7]: Result */
    /* Ensure var variable[7]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[7]) /*AbstractArray::add*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[6]) /*AbsSyntaxVisitor::error*/;
    variable[3] =  NIT_NULL /*null*/;
    goto return_label91;
  }
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_abstractmetamodel___MMLocalClass___select_method( variable[5] /*lc*/)( variable[5] /*lc*/,  variable[4] /*name*/) /*MMLocalClass::select_method*/;
  variable[6] = variable[7];
  /* Register variable[7]: Result */
  variable[7] = CALL_abstractmetamodel___MMLocalProperty___global( variable[6] /*prop*/)( variable[6] /*prop*/) /*MMLocalProperty::global*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
  CALL_syntax_base___MMGlobalProperty___check_visibility(variable[7])(variable[7],  variable[1] /*v*/, variable[0], variable[8],  TAG_Bool(false)) /*MMGlobalProperty::check_visibility*/;
  /* Register variable[7]: Local variable */
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMLocalProperty___signature_for( variable[6] /*prop*/)( variable[6] /*prop*/,  variable[2] /*type_lvalue*/) /*MMLocalProperty::signature_for*/;
  variable[7] = variable[8];
  ATTR_typing___AReassignFormExpr____assign_method(variable[0]) /*AReassignFormExpr::_assign_method*/ =  variable[6] /*prop*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[0])(variable[0]) /*AReassignFormExpr::n_value*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_static_type___MMSignature_____bra( variable[7] /*psig*/)( variable[7] /*psig*/,  TAG_Int(0)) /*MMSignature::[]*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_static_type___MMType___not_for_self(variable[9])(variable[9]) /*MMType::not_for_self*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[8], variable[9]) /*AbsSyntaxVisitor::check_conform_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[8])))) { /*if*/
    variable[3] =  NIT_NULL /*null*/;
    goto return_label91;
  }
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMSignature___return_type( variable[7] /*psig*/)( variable[7] /*psig*/) /*MMSignature::return_type*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMType___not_for_self(variable[8])(variable[8]) /*MMType::not_for_self*/;
  variable[3] = variable[8];
  goto return_label91;
  return_label91: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t typing___AReassignFormExpr___assign_method(val_t  self) {
  struct trace_t trace = {NULL, NULL, 620, LOCATE_typing___AReassignFormExpr___assign_method};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AReassignFormExpr____assign_method( self) /*AReassignFormExpr::_assign_method*/;
}
void typing___AVarReassignExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 625, LOCATE_typing___AVarReassignExpr___after_typing};
  val_t variable[8];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  CALL_control_flow___VariableContext___check_is_set(variable[3])(variable[3], variable[0], variable[4]) /*VariableContext::check_is_set*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  CALL_control_flow___VariableContext___mark_is_set(variable[3])(variable[3], variable[4]) /*VariableContext::mark_is_set*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_control_flow___VariableContext___stype(variable[4])(variable[4], variable[5]) /*VariableContext::stype*/;
  variable[3] = variable[4];
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___AReassignFormExpr___do_rvalue_typing(variable[0])(variable[0],  variable[1] /*v*/,  variable[3] /*t*/) /*AReassignFormExpr::do_rvalue_typing*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(( variable[4] /*t2*/ ==  NIT_NULL /*null*/) || (( variable[4] /*t2*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*t2*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*t2*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*t2*/)( variable[4] /*t2*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    goto return_label95;
  }
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___TypingVisitor___base_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::base_variable_ctx*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_control_flow___VariableContext___stype(variable[6])(variable[6], variable[7]) /*VariableContext::stype*/;
  variable[5] = variable[6];
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[0])(variable[0]) /*AReassignFormExpr::n_value*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___AbsSyntaxVisitor___check_conform( variable[1] /*v*/)( variable[1] /*v*/, variable[6],  variable[4] /*t2*/,  variable[5] /*btype*/) /*AbsSyntaxVisitor::check_conform*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
    goto return_label95;
  }
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___AVarFormExpr___variable(variable[0])(variable[0]) /*AVarFormExpr::variable*/;
  CALL_control_flow___VariableContext___stype__eq(variable[6])(variable[6], variable[7],  variable[4] /*t2*/) /*VariableContext::stype=*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label95: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___PAssignOp___method_name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 645, LOCATE_typing___PAssignOp___method_name};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 645);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t typing___APlusAssignOp___method_name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 648, LOCATE_typing___APlusAssignOp___method_name};
  static val_t once_value_97; static int once_bool_97; /* Once value for variable[2]*/
    static val_t once_value_98 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_97) variable[2] = once_value_97;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_98 != NIT_NULL) variable[2] = once_value_98;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("+"), TAG_Int(1)) /*new String*/;
      once_value_98 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_97 = variable[2];
    once_bool_97 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label96;
  return_label96: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AMinusAssignOp___method_name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 651, LOCATE_typing___AMinusAssignOp___method_name};
  static val_t once_value_100; static int once_bool_100; /* Once value for variable[2]*/
    static val_t once_value_101 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_100) variable[2] = once_value_100;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_101 != NIT_NULL) variable[2] = once_value_101;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("-"), TAG_Int(1)) /*new String*/;
      once_value_101 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_100 = variable[2];
    once_bool_100 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label99;
  return_label99: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___ASelfExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 657, LOCATE_typing___ASelfExpr___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
  CALL_syntax_base___ASelfExpr___variable__eq(variable[0])(variable[0], variable[3]) /*ASelfExpr::variable=*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___ASelfExpr___variable(variable[0])(variable[0]) /*ASelfExpr::variable*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_control_flow___VariableContext___stype(variable[3])(variable[3], variable[4]) /*VariableContext::stype*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label102: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASelfExpr___is_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 664, LOCATE_typing___ASelfExpr___is_self};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  TAG_Bool(true);
  goto return_label103;
  return_label103: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ASelfExpr___its_variable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 655, LOCATE_typing___ASelfExpr___its_variable};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_syntax_base___ASelfExpr___variable(variable[0])(variable[0]) /*ASelfExpr::variable*/;
  variable[1] = variable[2];
  goto return_label104;
  return_label104: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AImplicitSelfExpr___is_implicit_self(val_t  self) {
  struct trace_t trace = {NULL, NULL, 668, LOCATE_typing___AImplicitSelfExpr___is_implicit_self};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  TAG_Bool(true);
  goto return_label105;
  return_label105: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___AIfexprExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 672, LOCATE_typing___AIfexprExpr___accept_typing};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_expr(variable[0])(variable[0]) /*AIfexprExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_expr(variable[0])(variable[0]) /*AIfexprExpr::n_expr*/;
  CALL_typing___TypingVisitor___use_if_true_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::use_if_true_variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_then(variable[0])(variable[0]) /*AIfexprExpr::n_then*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_expr(variable[0])(variable[0]) /*AIfexprExpr::n_expr*/;
  CALL_typing___TypingVisitor___use_if_false_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::use_if_false_variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_else(variable[0])(variable[0]) /*AIfexprExpr::n_else*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIfexprExpr___n_expr(variable[0])(variable[0]) /*AIfexprExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(2)) /*new Array[PExpr]*/ /* Ensure var: Literal array*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AIfexprExpr___n_then(variable[0])(variable[0]) /*AIfexprExpr::n_then*/;
  CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AIfexprExpr___n_else(variable[0])(variable[0]) /*AIfexprExpr::n_else*/;
  CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[6]) /*AbstractArray::add*/;
  /* Register variable[4]: Result */
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_multiexpr( variable[1] /*v*/)( variable[1] /*v*/,  NIT_NULL /*null*/, variable[4]) /*AbsSyntaxVisitor::check_conform_multiexpr*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[4];
  /* Register variable[4]: Result */
  variable[4] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ = variable[4];
  return_label106: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ABoolExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 691, LOCATE_typing___ABoolExpr___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label107: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AOrExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 699, LOCATE_typing___AOrExpr___accept_typing};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AOrExpr___n_expr(variable[0])(variable[0]) /*AOrExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AOrExpr___n_expr(variable[0])(variable[0]) /*AOrExpr::n_expr*/;
  CALL_typing___TypingVisitor___use_if_false_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::use_if_false_variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AOrExpr___n_expr2(variable[0])(variable[0]) /*AOrExpr::n_expr2*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AOrExpr___n_expr2(variable[0])(variable[0]) /*AOrExpr::n_expr2*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___PExpr___if_false_variable_ctx(variable[4])(variable[4]) /*PExpr::if_false_variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AOrExpr___n_expr2(variable[0])(variable[0]) /*AOrExpr::n_expr2*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___PExpr___if_false_variable_ctx(variable[4])(variable[4]) /*PExpr::if_false_variable_ctx*/;
    ATTR_typing___PExpr____if_false_variable_ctx(variable[0]) /*PExpr::_if_false_variable_ctx*/ = variable[4];
  } else { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    ATTR_typing___PExpr____if_false_variable_ctx(variable[0]) /*PExpr::_if_false_variable_ctx*/ = variable[4];
  }
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AOrExpr___n_expr(variable[0])(variable[0]) /*AOrExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AOrExpr___n_expr2(variable[0])(variable[0]) /*AOrExpr::n_expr2*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[4];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label108: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAndExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 723, LOCATE_typing___AAndExpr___accept_typing};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr(variable[0])(variable[0]) /*AAndExpr::n_expr*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr(variable[0])(variable[0]) /*AAndExpr::n_expr*/;
  CALL_typing___TypingVisitor___use_if_true_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::use_if_true_variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr2(variable[0])(variable[0]) /*AAndExpr::n_expr2*/;
  CALL_parser_prod___Visitor___visit( variable[1] /*v*/)( variable[1] /*v*/, variable[4]) /*TypingVisitor::visit*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr2(variable[0])(variable[0]) /*AAndExpr::n_expr2*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AAndExpr___n_expr2(variable[0])(variable[0]) /*AAndExpr::n_expr2*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___PExpr___if_true_variable_ctx(variable[4])(variable[4]) /*PExpr::if_true_variable_ctx*/;
    ATTR_typing___PExpr____if_true_variable_ctx(variable[0]) /*PExpr::_if_true_variable_ctx*/ = variable[4];
  } else { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    ATTR_typing___PExpr____if_true_variable_ctx(variable[0]) /*PExpr::_if_true_variable_ctx*/ = variable[4];
  }
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr(variable[0])(variable[0]) /*AAndExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAndExpr___n_expr2(variable[0])(variable[0]) /*AAndExpr::n_expr2*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::check_conform_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[4];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label109: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ANotExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 747, LOCATE_typing___ANotExpr___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ANotExpr___n_expr(variable[0])(variable[0]) /*ANotExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ANotExpr___n_expr(variable[0])(variable[0]) /*ANotExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___PExpr____if_true_variable_ctx(variable[3]) /*PExpr::_if_true_variable_ctx*/;
  ATTR_typing___PExpr____if_false_variable_ctx(variable[0]) /*PExpr::_if_false_variable_ctx*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ANotExpr___n_expr(variable[0])(variable[0]) /*ANotExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___PExpr____if_false_variable_ctx(variable[3]) /*PExpr::_if_false_variable_ctx*/;
  ATTR_typing___PExpr____if_true_variable_ctx(variable[0]) /*PExpr::_if_true_variable_ctx*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label110: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AIntExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 761, LOCATE_typing___AIntExpr___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_int( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_int*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label111: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AFloatExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 769, LOCATE_typing___AFloatExpr___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_float( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_float*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label112: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ACharExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 777, LOCATE_typing___ACharExpr___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_char( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_char*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label113: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AStringFormExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 786, LOCATE_typing___AStringFormExpr___after_typing};
  static val_t once_value_115; static int once_bool_115; /* Once value for variable[4]*/
    static val_t once_value_116 = NIT_NULL; /* Once value for string variable[4]*/
    static val_t once_value_117 = NIT_NULL; /* Once value for string variable[4]*/
    static val_t once_value_118 = NIT_NULL; /* Once value for string variable[4]*/
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_string( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_string*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_static_type___MMType___local_class(variable[3])(variable[3]) /*MMType::local_class*/;
  /* Register variable[4]: Once expression result */
  if (once_bool_115) variable[4] = once_value_115;
  else {
    /* Register variable[4]: Once String constant */
    if (once_value_116 != NIT_NULL) variable[4] = once_value_116;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString("with_native"), TAG_Int(11)) /*new String*/;
      once_value_116 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Register variable[4]: Result */
    variable[4] = CALL_symbol___String___to_symbol(variable[4])(variable[4]) /*String::to_symbol*/;
    once_value_115 = variable[4];
    once_bool_115 = true;
  }
  /* Register variable[4]: Result */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[3])(variable[3], variable[4]) /*MMLocalClass::select_method*/;
  ATTR_typing___AStringFormExpr____meth_with_native(variable[0]) /*AStringFormExpr::_meth_with_native*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___AStringFormExpr____meth_with_native(variable[0]) /*AStringFormExpr::_meth_with_native*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[4]: Once String constant */
    if (once_value_117 != NIT_NULL) variable[4] = once_value_117;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_117 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
    /* Register variable[4]: Result */
    variable[4] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[4]: Once String constant */
    if (once_value_118 != NIT_NULL) variable[4] = once_value_118;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have a with_native method."), TAG_Int(32)) /*new String*/;
      once_value_118 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_string___Object___to_s(variable[3])(variable[3]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::error*/;
  }
  return_label114: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AStringFormExpr___meth_with_native(val_t  self) {
  struct trace_t trace = {NULL, NULL, 785, LOCATE_typing___AStringFormExpr___meth_with_native};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AStringFormExpr____meth_with_native( self) /*AStringFormExpr::_meth_with_native*/;
}
void typing___ASuperstringExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 800, LOCATE_typing___ASuperstringExpr___after_typing};
  static val_t once_value_120; static int once_bool_120; /* Once value for variable[4]*/
    static val_t once_value_121 = NIT_NULL; /* Once value for string variable[4]*/
    static val_t once_value_122 = NIT_NULL; /* Once value for string variable[4]*/
    static val_t once_value_123 = NIT_NULL; /* Once value for string variable[4]*/
  static val_t once_value_124; static int once_bool_124; /* Once value for variable[4]*/
    static val_t once_value_125 = NIT_NULL; /* Once value for string variable[4]*/
    static val_t once_value_126 = NIT_NULL; /* Once value for string variable[4]*/
    static val_t once_value_127 = NIT_NULL; /* Once value for string variable[4]*/
  static val_t once_value_128; static int once_bool_128; /* Once value for variable[4]*/
    static val_t once_value_129 = NIT_NULL; /* Once value for string variable[4]*/
    static val_t once_value_130 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_string( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_string*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_array( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::type_array*/;
  ATTR_typing___ASuperstringExpr____atype(variable[0]) /*ASuperstringExpr::_atype*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___ASuperstringExpr____atype(variable[0]) /*ASuperstringExpr::_atype*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_static_type___MMType___local_class(variable[3])(variable[3]) /*MMType::local_class*/;
  /* Register variable[4]: Once expression result */
  if (once_bool_120) variable[4] = once_value_120;
  else {
    /* Register variable[4]: Once String constant */
    if (once_value_121 != NIT_NULL) variable[4] = once_value_121;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString("with_capacity"), TAG_Int(13)) /*new String*/;
      once_value_121 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Register variable[4]: Result */
    variable[4] = CALL_symbol___String___to_symbol(variable[4])(variable[4]) /*String::to_symbol*/;
    once_value_120 = variable[4];
    once_bool_120 = true;
  }
  /* Register variable[4]: Result */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[3])(variable[3], variable[4]) /*MMLocalClass::select_method*/;
  ATTR_typing___ASuperstringExpr____meth_with_capacity(variable[0]) /*ASuperstringExpr::_meth_with_capacity*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___ASuperstringExpr____meth_with_capacity(variable[0]) /*ASuperstringExpr::_meth_with_capacity*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[4]: Once String constant */
    if (once_value_122 != NIT_NULL) variable[4] = once_value_122;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_122 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
    /* Register variable[4]: Result */
    variable[4] = ATTR_typing___ASuperstringExpr____atype(variable[0]) /*ASuperstringExpr::_atype*/;
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[4]: Once String constant */
    if (once_value_123 != NIT_NULL) variable[4] = once_value_123;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have a with_capacity method."), TAG_Int(34)) /*new String*/;
      once_value_123 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_string___Object___to_s(variable[3])(variable[3]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::error*/;
  }
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___ASuperstringExpr____atype(variable[0]) /*ASuperstringExpr::_atype*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_static_type___MMType___local_class(variable[3])(variable[3]) /*MMType::local_class*/;
  /* Register variable[4]: Once expression result */
  if (once_bool_124) variable[4] = once_value_124;
  else {
    /* Register variable[4]: Once String constant */
    if (once_value_125 != NIT_NULL) variable[4] = once_value_125;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString("add"), TAG_Int(3)) /*new String*/;
      once_value_125 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Register variable[4]: Result */
    variable[4] = CALL_symbol___String___to_symbol(variable[4])(variable[4]) /*String::to_symbol*/;
    once_value_124 = variable[4];
    once_bool_124 = true;
  }
  /* Register variable[4]: Result */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[3])(variable[3], variable[4]) /*MMLocalClass::select_method*/;
  ATTR_typing___ASuperstringExpr____meth_add(variable[0]) /*ASuperstringExpr::_meth_add*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___ASuperstringExpr____meth_add(variable[0]) /*ASuperstringExpr::_meth_add*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[4]: Once String constant */
    if (once_value_126 != NIT_NULL) variable[4] = once_value_126;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_126 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
    /* Register variable[4]: Result */
    variable[4] = ATTR_typing___ASuperstringExpr____atype(variable[0]) /*ASuperstringExpr::_atype*/;
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[4]: Once String constant */
    if (once_value_127 != NIT_NULL) variable[4] = once_value_127;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have an add method."), TAG_Int(25)) /*new String*/;
      once_value_127 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Ensure var variable[4]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_string___Object___to_s(variable[3])(variable[3]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::error*/;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_object( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_object*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_static_type___MMType___local_class(variable[3])(variable[3]) /*MMType::local_class*/;
  /* Register variable[4]: Once expression result */
  if (once_bool_128) variable[4] = once_value_128;
  else {
    /* Register variable[4]: Once String constant */
    if (once_value_129 != NIT_NULL) variable[4] = once_value_129;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString("to_s"), TAG_Int(4)) /*new String*/;
      once_value_129 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Register variable[4]: Result */
    variable[4] = CALL_symbol___String___to_symbol(variable[4])(variable[4]) /*String::to_symbol*/;
    once_value_128 = variable[4];
    once_bool_128 = true;
  }
  /* Register variable[4]: Result */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[3])(variable[3], variable[4]) /*MMLocalClass::select_method*/;
  ATTR_typing___ASuperstringExpr____meth_to_s(variable[0]) /*ASuperstringExpr::_meth_to_s*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___ASuperstringExpr____meth_to_s(variable[0]) /*ASuperstringExpr::_meth_to_s*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Once String constant */
    if (once_value_130 != NIT_NULL) variable[3] = once_value_130;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString("Object MUST have a to_s method."), TAG_Int(31)) /*new String*/;
      once_value_130 = variable[3];
    }
    /* Register variable[3]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::error*/;
  }
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label119: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASuperstringExpr___meth_with_capacity(val_t  self) {
  struct trace_t trace = {NULL, NULL, 796, LOCATE_typing___ASuperstringExpr___meth_with_capacity};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperstringExpr____meth_with_capacity( self) /*ASuperstringExpr::_meth_with_capacity*/;
}
val_t typing___ASuperstringExpr___meth_add(val_t  self) {
  struct trace_t trace = {NULL, NULL, 797, LOCATE_typing___ASuperstringExpr___meth_add};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperstringExpr____meth_add( self) /*ASuperstringExpr::_meth_add*/;
}
val_t typing___ASuperstringExpr___meth_to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 798, LOCATE_typing___ASuperstringExpr___meth_to_s};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperstringExpr____meth_to_s( self) /*ASuperstringExpr::_meth_to_s*/;
}
val_t typing___ASuperstringExpr___atype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 799, LOCATE_typing___ASuperstringExpr___atype};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperstringExpr____atype( self) /*ASuperstringExpr::_atype*/;
}
void typing___ANullExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 815, LOCATE_typing___ANullExpr___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_none( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_none*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label131: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AArrayExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 826, LOCATE_typing___AArrayExpr___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AArrayExpr___n_exprs(variable[0])(variable[0]) /*AArrayExpr::n_exprs*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_multiexpr( variable[1] /*v*/)( variable[1] /*v*/,  NIT_NULL /*null*/, variable[4]) /*AbsSyntaxVisitor::check_conform_multiexpr*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[3] /*stype*/ ==  NIT_NULL /*null*/) || (( variable[3] /*stype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*stype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*stype*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*stype*/)( variable[3] /*stype*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label132;
  }
  CALL_typing___AArrayExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/,  variable[3] /*stype*/) /*AArrayExpr::do_typing*/;
  return_label132: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AArrayExpr___meth_with_capacity(val_t  self) {
  struct trace_t trace = {NULL, NULL, 823, LOCATE_typing___AArrayExpr___meth_with_capacity};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AArrayExpr____meth_with_capacity( self) /*AArrayExpr::_meth_with_capacity*/;
}
val_t typing___AArrayExpr___meth_add(val_t  self) {
  struct trace_t trace = {NULL, NULL, 824, LOCATE_typing___AArrayExpr___meth_add};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AArrayExpr____meth_add( self) /*AArrayExpr::_meth_add*/;
}
void typing___AArrayExpr___do_typing(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 833, LOCATE_typing___AArrayExpr___do_typing};
  static val_t once_value_134; static int once_bool_134; /* Once value for variable[5]*/
    static val_t once_value_135 = NIT_NULL; /* Once value for string variable[5]*/
    static val_t once_value_136 = NIT_NULL; /* Once value for string variable[5]*/
    static val_t once_value_137 = NIT_NULL; /* Once value for string variable[5]*/
  static val_t once_value_138; static int once_bool_138; /* Once value for variable[5]*/
    static val_t once_value_139 = NIT_NULL; /* Once value for string variable[5]*/
    static val_t once_value_140 = NIT_NULL; /* Once value for string variable[5]*/
    static val_t once_value_141 = NIT_NULL; /* Once value for string variable[5]*/
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_array( variable[1] /*v*/)( variable[1] /*v*/,  variable[2] /*element_type*/) /*AbsSyntaxVisitor::type_array*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[4];
  /* Register variable[4]: Result */
  variable[4] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMType___local_class(variable[4])(variable[4]) /*MMType::local_class*/;
  /* Register variable[5]: Once expression result */
  if (once_bool_134) variable[5] = once_value_134;
  else {
    /* Register variable[5]: Once String constant */
    if (once_value_135 != NIT_NULL) variable[5] = once_value_135;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("with_capacity"), TAG_Int(13)) /*new String*/;
      once_value_135 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Register variable[5]: Result */
    variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
    once_value_134 = variable[5];
    once_bool_134 = true;
  }
  /* Register variable[5]: Result */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[4])(variable[4], variable[5]) /*MMLocalClass::select_method*/;
  ATTR_typing___AArrayExpr____meth_with_capacity(variable[0]) /*AArrayExpr::_meth_with_capacity*/ = variable[4];
  /* Register variable[4]: Result */
  variable[4] = ATTR_typing___AArrayExpr____meth_with_capacity(variable[0]) /*AArrayExpr::_meth_with_capacity*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[5]: Once String constant */
    if (once_value_136 != NIT_NULL) variable[5] = once_value_136;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_136 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
    /* Register variable[5]: Result */
    variable[5] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[5]: Once String constant */
    if (once_value_137 != NIT_NULL) variable[5] = once_value_137;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have a with_capacity method."), TAG_Int(34)) /*new String*/;
      once_value_137 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
  }
  /* Register variable[4]: Result */
  variable[4] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMType___local_class(variable[4])(variable[4]) /*MMType::local_class*/;
  /* Register variable[5]: Once expression result */
  if (once_bool_138) variable[5] = once_value_138;
  else {
    /* Register variable[5]: Once String constant */
    if (once_value_139 != NIT_NULL) variable[5] = once_value_139;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("add"), TAG_Int(3)) /*new String*/;
      once_value_139 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Register variable[5]: Result */
    variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
    once_value_138 = variable[5];
    once_bool_138 = true;
  }
  /* Register variable[5]: Result */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[4])(variable[4], variable[5]) /*MMLocalClass::select_method*/;
  ATTR_typing___AArrayExpr____meth_add(variable[0]) /*AArrayExpr::_meth_add*/ = variable[4];
  /* Register variable[4]: Result */
  variable[4] = ATTR_typing___AArrayExpr____meth_add(variable[0]) /*AArrayExpr::_meth_add*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[5]: Once String constant */
    if (once_value_140 != NIT_NULL) variable[5] = once_value_140;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_140 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
    /* Register variable[5]: Result */
    variable[5] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[5]: Once String constant */
    if (once_value_141 != NIT_NULL) variable[5] = once_value_141;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString(" MUST have an add method."), TAG_Int(25)) /*new String*/;
      once_value_141 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
  }
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label133: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ARangeExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 848, LOCATE_typing___ARangeExpr___after_typing};
      static val_t once_value_143 = NIT_NULL; /* Once value for string variable[6]*/
      static val_t once_value_144 = NIT_NULL; /* Once value for string variable[6]*/
      static val_t once_value_145 = NIT_NULL; /* Once value for string variable[6]*/
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ARangeExpr___n_expr(variable[0])(variable[0]) /*ARangeExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3])) /* Ensure var: Left 'or' operand*/;
  if (!UNTAG_Bool(variable[3])) { /* or */
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ARangeExpr___n_expr2(variable[0])(variable[0]) /*ARangeExpr::n_expr2*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
    variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3]));
  }
  /* Register variable[3]: Result */
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label142;
  }
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___ARangeExpr___n_expr(variable[0])(variable[0]) /*ARangeExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  variable[3] = variable[4];
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___ARangeExpr___n_expr2(variable[0])(variable[0]) /*ARangeExpr::n_expr2*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___PExpr___stype(variable[5])(variable[5]) /*PExpr::stype*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_static_type___MMType_____l( variable[3] /*ntype*/)( variable[3] /*ntype*/,  variable[4] /*ntype2*/) /*MMType::<*/;
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[3] =  variable[4] /*ntype2*/ /*ntype=*/;
  } else { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_static_type___MMType_____l( variable[4] /*ntype2*/)( variable[4] /*ntype2*/,  variable[3] /*ntype*/) /*MMType::<*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
      variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[6]: Once String constant */
      if (once_value_143 != NIT_NULL) variable[6] = once_value_143;
      else {
        variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Type error: "), TAG_Int(12)) /*new String*/;
        once_value_143 = variable[6];
      }
      /* Register variable[6]: Result */
      /* Ensure var variable[6]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
      variable[6] =  variable[3] /*ntype*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[6]: Once String constant */
      if (once_value_144 != NIT_NULL) variable[6] = once_value_144;
      else {
        variable[6] = NEW_String_string___String___with_native(BOX_NativeString(" incompatible with "), TAG_Int(19)) /*new String*/;
        once_value_144 = variable[6];
      }
      /* Register variable[6]: Result */
      /* Ensure var variable[6]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
      variable[6] =  variable[4] /*ntype2*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[6]: Once String constant */
      if (once_value_145 != NIT_NULL) variable[6] = once_value_145;
      else {
        variable[6] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
        once_value_145 = variable[6];
      }
      /* Register variable[6]: Result */
      /* Ensure var variable[6]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
      /* Register variable[5]: Result */
      variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
      goto return_label142;
    }
  }
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___AbsSyntaxVisitor___type_discrete( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_discrete*/;
  variable[5] = variable[6];
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___ARangeExpr___n_expr(variable[0])(variable[0]) /*ARangeExpr::n_expr*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[6],  variable[5] /*dtype*/) /*AbsSyntaxVisitor::check_conform_expr*/;
  variable[6] =  TAG_Bool(!UNTAG_Bool(variable[6])) /* Ensure var: Left 'or' operand*/;
  if (!UNTAG_Bool(variable[6])) { /* or */
    /* Register variable[6]: Result */
    variable[6] = CALL_parser_nodes___ARangeExpr___n_expr2(variable[0])(variable[0]) /*ARangeExpr::n_expr2*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[6],  variable[5] /*dtype*/) /*AbsSyntaxVisitor::check_conform_expr*/;
    variable[6] =  TAG_Bool(!UNTAG_Bool(variable[6]));
  }
  /* Register variable[6]: Result */
  if (UNTAG_Bool(variable[6])) { /*if*/
    goto return_label142;
  }
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___AbsSyntaxVisitor___type_range( variable[1] /*v*/)( variable[1] /*v*/,  variable[3] /*ntype*/) /*AbsSyntaxVisitor::type_range*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[6];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label142: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ARangeExpr___meth_init(val_t  self) {
  struct trace_t trace = {NULL, NULL, 847, LOCATE_typing___ARangeExpr___meth_init};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ARangeExpr____meth_init( self) /*ARangeExpr::_meth_init*/;
}
void typing___ACrangeExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 867, LOCATE_typing___ACrangeExpr___after_typing};
  static val_t once_value_147; static int once_bool_147; /* Once value for variable[4]*/
    static val_t once_value_148 = NIT_NULL; /* Once value for string variable[4]*/
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_SUPER_typing___ACrangeExpr___after_typing(variable[0])(variable[0], variable[1]) /*super ACrangeExpr::after_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___stype(variable[0])(variable[0]) /*PExpr::stype*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_static_type___MMType___local_class(variable[3])(variable[3]) /*MMType::local_class*/;
  /* Register variable[4]: Once expression result */
  if (once_bool_147) variable[4] = once_value_147;
  else {
    /* Register variable[4]: Once String constant */
    if (once_value_148 != NIT_NULL) variable[4] = once_value_148;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString("init"), TAG_Int(4)) /*new String*/;
      once_value_148 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Register variable[4]: Result */
    variable[4] = CALL_symbol___String___to_symbol(variable[4])(variable[4]) /*String::to_symbol*/;
    once_value_147 = variable[4];
    once_bool_147 = true;
  }
  /* Register variable[4]: Result */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[3])(variable[3], variable[4]) /*MMLocalClass::select_method*/;
  ATTR_typing___ARangeExpr____meth_init(variable[0]) /*ARangeExpr::_meth_init*/ = variable[3];
  return_label146: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AOrangeExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 874, LOCATE_typing___AOrangeExpr___after_typing};
  static val_t once_value_150; static int once_bool_150; /* Once value for variable[4]*/
    static val_t once_value_151 = NIT_NULL; /* Once value for string variable[4]*/
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_SUPER_typing___AOrangeExpr___after_typing(variable[0])(variable[0], variable[1]) /*super AOrangeExpr::after_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___stype(variable[0])(variable[0]) /*PExpr::stype*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_static_type___MMType___local_class(variable[3])(variable[3]) /*MMType::local_class*/;
  /* Register variable[4]: Once expression result */
  if (once_bool_150) variable[4] = once_value_150;
  else {
    /* Register variable[4]: Once String constant */
    if (once_value_151 != NIT_NULL) variable[4] = once_value_151;
    else {
      variable[4] = NEW_String_string___String___with_native(BOX_NativeString("without_last"), TAG_Int(12)) /*new String*/;
      once_value_151 = variable[4];
    }
    /* Register variable[4]: Result */
    /* Register variable[4]: Result */
    variable[4] = CALL_symbol___String___to_symbol(variable[4])(variable[4]) /*String::to_symbol*/;
    once_value_150 = variable[4];
    once_bool_150 = true;
  }
  /* Register variable[4]: Result */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstractmetamodel___MMLocalClass___select_method(variable[3])(variable[3], variable[4]) /*MMLocalClass::select_method*/;
  ATTR_typing___ARangeExpr____meth_init(variable[0]) /*ARangeExpr::_meth_init*/ = variable[3];
  return_label149: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ASuperExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 886, LOCATE_typing___ASuperExpr___after_typing};
          static val_t once_value_154 = NIT_NULL; /* Once value for string variable[9]*/
          static val_t once_value_155 = NIT_NULL; /* Once value for string variable[9]*/
          static val_t once_value_156 = NIT_NULL; /* Once value for string variable[9]*/
        static val_t once_value_157 = NIT_NULL; /* Once value for string variable[6]*/
        static val_t once_value_158 = NIT_NULL; /* Once value for string variable[6]*/
          static val_t once_value_159 = NIT_NULL; /* Once value for string variable[6]*/
          static val_t once_value_160 = NIT_NULL; /* Once value for string variable[6]*/
          static val_t once_value_161 = NIT_NULL; /* Once value for string variable[6]*/
          static val_t once_value_162 = NIT_NULL; /* Once value for string variable[6]*/
      static val_t once_value_163 = NIT_NULL; /* Once value for string variable[5]*/
      static val_t once_value_164 = NIT_NULL; /* Once value for string variable[5]*/
  val_t variable[12];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstractmetamodel___MMLocalProperty___prhe(variable[4])(variable[4]) /*MMLocalProperty::prhe*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_partial_order___PartialOrderElement___direct_greaters(variable[4])(variable[4]) /*PartialOrderElement::direct_greaters*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___is_empty( variable[3] /*precs*/)( variable[3] /*precs*/) /*AbstractArrayRead::is_empty*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[4])))) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    CALL_abstractmetamodel___MMLocalProperty___need_super__eq(variable[4])(variable[4],  TAG_Bool(true)) /*MMLocalProperty::need_super=*/;
  } else { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_abstractmetamodel___MMLocalProperty___global(variable[4])(variable[4]) /*MMLocalProperty::global*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[4])(variable[4]) /*MMGlobalProperty::is_init*/;
    if (UNTAG_Bool(variable[4])) { /*if*/
      /* Register variable[4]: Local variable */
      /* Register variable[5]: Result */
      variable[5] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
      /* Register variable[6]: Result */
      variable[6] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
      /* Register variable[6]: Result */
      variable[6] = CALL_abstractmetamodel___MMLocalProperty___name(variable[6])(variable[6]) /*MMLocalProperty::name*/;
      /* Register variable[5]: Result */
      variable[5] = CALL_abstractmetamodel___MMLocalClass___super_methods_named(variable[5])(variable[5], variable[6]) /*MMLocalClass::super_methods_named*/;
      variable[4] = variable[5];
      /* Register variable[5]: For iterator */
      variable[5] = CALL_abstract_collection___Collection___iterator( variable[4] /*base_precs*/)( variable[4] /*base_precs*/) /*AbstractArrayRead::iterator*/;
      while (true) { /*for*/
        /* Register variable[6]: For 'is_ok' result */
        variable[6] = CALL_abstract_collection___Iterator___is_ok(variable[5])(variable[5]) /*ArrayIterator::is_ok*/;
        if (!UNTAG_Bool(variable[6])) break; /*for*/
        variable[6] = CALL_abstract_collection___Iterator___item(variable[5])(variable[5]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
        /* Register variable[7]: Local variable */
        variable[7] = variable[6];
        /* Register variable[8]: Result */
        variable[8] = CALL_abstractmetamodel___MMLocalProperty___global( variable[7] /*p*/)( variable[7] /*p*/) /*MMLocalProperty::global*/;
        /* Register variable[8]: Result */
        variable[8] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[8])(variable[8]) /*MMGlobalProperty::is_init*/;
        if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[8])))) { /*if*/
          variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
          /* Register variable[9]: Once String constant */
          if (once_value_154 != NIT_NULL) variable[9] = once_value_154;
          else {
            variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
            once_value_154 = variable[9];
          }
          /* Register variable[9]: Result */
          /* Ensure var variable[9]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
          /* Register variable[9]: Result */
          variable[9] = CALL_abstractmetamodel___MMLocalProperty___local_class( variable[7] /*p*/)( variable[7] /*p*/) /*MMLocalProperty::local_class*/;
          /* Ensure var variable[9]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
          /* Register variable[9]: Once String constant */
          if (once_value_155 != NIT_NULL) variable[9] = once_value_155;
          else {
            variable[9] = NEW_String_string___String___with_native(BOX_NativeString("::"), TAG_Int(2)) /*new String*/;
            once_value_155 = variable[9];
          }
          /* Register variable[9]: Result */
          /* Ensure var variable[9]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
          variable[9] =  variable[7] /*p*/ /* Ensure var: super-string element*/;
          CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
          /* Register variable[9]: Once String constant */
          if (once_value_156 != NIT_NULL) variable[9] = once_value_156;
          else {
            variable[9] = NEW_String_string___String___with_native(BOX_NativeString(" is not a constructor."), TAG_Int(22)) /*new String*/;
            once_value_156 = variable[9];
          }
          /* Register variable[9]: Result */
          /* Ensure var variable[9]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
          /* Register variable[8]: Result */
          variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
          CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[8]) /*AbsSyntaxVisitor::error*/;
        } else { /*if*/
          /* Register variable[8]: Result */
          variable[8] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
          /* Register variable[9]: Result */
          variable[9] = CALL_abstractmetamodel___MMLocalProperty___global( variable[7] /*p*/)( variable[7] /*p*/) /*MMLocalProperty::global*/;
          /* Register variable[8]: Result */
          variable[8] = CALL_abstractmetamodel___MMLocalClass_____bra(variable[8])(variable[8], variable[9]) /*MMLocalClass::[]*/;
          CALL_abstract_collection___SimpleCollection___add( variable[3] /*precs*/)( variable[3] /*precs*/, variable[8]) /*AbstractArray::add*/;
        }
        continue_153: while(0);
        CALL_abstract_collection___Iterator___next(variable[5])(variable[5]) /*ArrayIterator::next*/;
      }
      break_153: while(0);
      /* Register variable[5]: Result */
      variable[5] = CALL_abstract_collection___Collection___is_empty( variable[3] /*precs*/)( variable[3] /*precs*/) /*AbstractArrayRead::is_empty*/;
      if (UNTAG_Bool(variable[5])) { /*if*/
        variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[6]: Once String constant */
        if (once_value_157 != NIT_NULL) variable[6] = once_value_157;
        else {
          variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: No contructor named "), TAG_Int(27)) /*new String*/;
          once_value_157 = variable[6];
        }
        /* Register variable[6]: Result */
        /* Ensure var variable[6]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
        /* Register variable[6]: Result */
        variable[6] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
        /* Register variable[6]: Result */
        variable[6] = CALL_abstractmetamodel___MMLocalProperty___name(variable[6])(variable[6]) /*MMLocalProperty::name*/;
        /* Ensure var variable[6]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[6]: Once String constant */
        if (once_value_158 != NIT_NULL) variable[6] = once_value_158;
        else {
          variable[6] = NEW_String_string___String___with_native(BOX_NativeString(" in superclasses."), TAG_Int(17)) /*new String*/;
          once_value_158 = variable[6];
        }
        /* Register variable[6]: Result */
        /* Ensure var variable[6]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
        /* Register variable[5]: Result */
        variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
        goto return_label152;
      } else { /*if*/
        /* Register variable[5]: Result */
        variable[5] = CALL_abstract_collection___Collection___length( variable[3] /*precs*/)( variable[3] /*precs*/) /*AbstractArrayRead::length*/;
        /* Register variable[5]: Result */
        variable[5] = TAG_Bool(UNTAG_Int(variable[5])>UNTAG_Int( TAG_Int(1)));
        if (UNTAG_Bool(variable[5])) { /*if*/
          variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
          /* Register variable[6]: Once String constant */
          if (once_value_159 != NIT_NULL) variable[6] = once_value_159;
          else {
            variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: Conflicting contructors named "), TAG_Int(37)) /*new String*/;
            once_value_159 = variable[6];
          }
          /* Register variable[6]: Result */
          /* Ensure var variable[6]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
          /* Register variable[6]: Result */
          variable[6] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
          /* Register variable[6]: Result */
          variable[6] = CALL_abstractmetamodel___MMLocalProperty___name(variable[6])(variable[6]) /*MMLocalProperty::name*/;
          /* Ensure var variable[6]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/) /*AbstractArray::add*/;
          /* Register variable[6]: Once String constant */
          if (once_value_160 != NIT_NULL) variable[6] = once_value_160;
          else {
            variable[6] = NEW_String_string___String___with_native(BOX_NativeString(" in superclasses: "), TAG_Int(18)) /*new String*/;
            once_value_160 = variable[6];
          }
          /* Register variable[6]: Result */
          /* Ensure var variable[6]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
          /* Register variable[6]: Once String constant */
          if (once_value_161 != NIT_NULL) variable[6] = once_value_161;
          else {
            variable[6] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)) /*new String*/;
            once_value_161 = variable[6];
          }
          /* Register variable[6]: Result */
          /* Register variable[6]: Result */
          variable[6] = CALL_string___Collection___join( variable[3] /*precs*/)( variable[3] /*precs*/, variable[6]) /*Collection::join*/;
          /* Ensure var variable[6]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
          /* Register variable[6]: Once String constant */
          if (once_value_162 != NIT_NULL) variable[6] = once_value_162;
          else {
            variable[6] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
            once_value_162 = variable[6];
          }
          /* Register variable[6]: Result */
          /* Ensure var variable[6]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
          /* Register variable[5]: Result */
          variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
          CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
          goto return_label152;
        }
      }
      /* Register variable[5]: Local variable */
      /* Register variable[6]: Result */
      variable[6] = CALL_abstract_collection___Collection___first( variable[4] /*base_precs*/)( variable[4] /*base_precs*/) /*IndexedCollectionRead::first*/;
      variable[5] = variable[6];
      /* Register variable[6]: Result */
      variable[6] = TAG_Bool(( variable[5] /*p*/==NIT_NULL) || VAL_ISA( variable[5] /*p*/, COLOR_MMMethod, ID_MMMethod)) /*cast MMMethod*/;
      if (!UNTAG_Bool(variable[6])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___ASuperExpr___after_typing, LOCATE_typing, 908); nit_exit(1);}
      ATTR_typing___ASuperExpr____init_in_superclass(variable[0]) /*ASuperExpr::_init_in_superclass*/ =  variable[5] /*p*/;
      CALL_typing___ASuperInitCall___register_super_init_call(variable[0])(variable[0],  variable[1] /*v*/,  variable[5] /*p*/) /*ASuperInitCall::register_super_init_call*/;
      /* Register variable[6]: Result */
      variable[6] = CALL_parser_nodes___ASuperExpr___n_args(variable[0])(variable[0]) /*ASuperExpr::n_args*/;
      /* Register variable[6]: Result */
      variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*List::length*/;
      /* Register variable[6]: Result */
      variable[6] = TAG_Bool(UNTAG_Int(variable[6])>UNTAG_Int( TAG_Int(0)));
      if (UNTAG_Bool(variable[6])) { /*if*/
        /* Register variable[6]: Local variable */
        /* Register variable[7]: Result */
        variable[7] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
        /* Register variable[7]: Result */
        variable[7] = CALL_syntax_base___Variable___stype(variable[7])(variable[7]) /*Variable::stype*/;
        /* Register variable[7]: Result */
        variable[7] = CALL_typing___AAbsSendExpr___get_signature(variable[0])(variable[0],  variable[1] /*v*/, variable[7],  variable[5] /*p*/,  TAG_Bool(true)) /*AAbsSendExpr::get_signature*/;
        variable[6] = variable[7];
        /* Register variable[7]: Result */
        variable[7] = CALL_abstractmetamodel___MMLocalProperty___name( variable[5] /*p*/)( variable[5] /*p*/) /*MMLocalProperty::name*/;
        /* Register variable[8]: Result */
        variable[8] = CALL_parser_nodes___ASuperExpr___n_args(variable[0])(variable[0]) /*ASuperExpr::n_args*/;
        /* Register variable[8]: Result */
        variable[8] = CALL_array___Collection___to_a(variable[8])(variable[8]) /*Collection::to_a*/;
        /* Register variable[7]: Result */
        variable[7] = CALL_typing___AAbsAbsSendExpr___process_signature(variable[0])(variable[0],  variable[1] /*v*/,  variable[6] /*signature*/, variable[7], variable[8]) /*AAbsAbsSendExpr::process_signature*/;
        ATTR_typing___AAbsAbsSendExpr____arguments(variable[0]) /*AAbsAbsSendExpr::_arguments*/ = variable[7];
      }
    } else { /*if*/
      variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[5]: Once String constant */
      if (once_value_163 != NIT_NULL) variable[5] = once_value_163;
      else {
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: No super method to call for "), TAG_Int(35)) /*new String*/;
        once_value_163 = variable[5];
      }
      /* Register variable[5]: Result */
      /* Ensure var variable[5]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
      /* Register variable[5]: Result */
      variable[5] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
      /* Ensure var variable[5]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[5]: Once String constant */
      if (once_value_164 != NIT_NULL) variable[5] = once_value_164;
      else {
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
        once_value_164 = variable[5];
      }
      /* Register variable[5]: Result */
      /* Ensure var variable[5]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
      /* Register variable[4]: Result */
      variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
      goto return_label152;
    }
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___first( variable[3] /*precs*/)( variable[3] /*precs*/) /*IndexedCollectionRead::first*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___Variable___stype(variable[5])(variable[5]) /*Variable::stype*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMLocalProperty___signature_for(variable[4])(variable[4], variable[5]) /*MMLocalProperty::signature_for*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMSignature___return_type(variable[4])(variable[4]) /*MMSignature::return_type*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Local variable */
    /* Register variable[5]: Result */
    variable[5] = NEW_Array_array___Array___init() /*new Array[MMType]*/;
    variable[4] = variable[5];
    /* Register variable[5]: Local variable */
    variable[5] =  NIT_NULL /*null*/;
    /* Register variable[6]: For iterator */
    variable[6] = CALL_abstract_collection___Collection___iterator( variable[3] /*precs*/)( variable[3] /*precs*/) /*AbstractArrayRead::iterator*/;
    while (true) { /*for*/
      /* Register variable[7]: For 'is_ok' result */
      variable[7] = CALL_abstract_collection___Iterator___is_ok(variable[6])(variable[6]) /*ArrayIterator::is_ok*/;
      if (!UNTAG_Bool(variable[7])) break; /*for*/
      variable[7] = CALL_abstract_collection___Iterator___item(variable[6])(variable[6]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
      /* Register variable[8]: Local variable */
      variable[8] = variable[7];
      /* Register variable[9]: Result */
      variable[9] = TAG_Bool(( variable[8] /*prop*/==NIT_NULL) || VAL_ISA( variable[8] /*prop*/, COLOR_MMMethod, ID_MMMethod)) /*cast MMMethod*/;
      if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___ASuperExpr___after_typing, LOCATE_typing, 924); nit_exit(1);}
      /* Register variable[9]: Local variable */
      /* Register variable[10]: Result */
      variable[10] = CALL_typing___TypingVisitor___self_var( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::self_var*/;
      /* Register variable[10]: Result */
      variable[10] = CALL_syntax_base___Variable___stype(variable[10])(variable[10]) /*Variable::stype*/;
      /* Register variable[10]: Result */
      variable[10] = CALL_static_type___MMLocalProperty___signature_for( variable[8] /*prop*/)( variable[8] /*prop*/, variable[10]) /*MMLocalProperty::signature_for*/;
      /* Register variable[10]: Result */
      variable[10] = CALL_static_type___MMSignature___return_type(variable[10])(variable[10]) /*MMSignature::return_type*/;
      /* Register variable[11]: Result */
      variable[11] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
      /* Register variable[10]: Result */
      variable[10] = CALL_static_type___MMType___for_module(variable[10])(variable[10], variable[11]) /*MMType::for_module*/;
      /* Register variable[11]: Result */
      variable[11] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
      /* Register variable[11]: Result */
      variable[11] = CALL_static_type___MMLocalProperty___signature(variable[11])(variable[11]) /*MMLocalProperty::signature*/;
      /* Register variable[11]: Result */
      variable[11] = CALL_static_type___MMSignature___recv(variable[11])(variable[11]) /*MMSignature::recv*/;
      /* Register variable[10]: Result */
      variable[10] = CALL_static_type___MMType___adapt_to(variable[10])(variable[10], variable[11]) /*MMType::adapt_to*/;
      variable[9] = variable[10];
      CALL_abstract_collection___SimpleCollection___add( variable[4] /*stypes*/)( variable[4] /*stypes*/,  variable[9] /*t*/) /*AbstractArray::add*/;
      /* Register variable[10]: Result */
      variable[10] = TAG_Bool(( variable[5] /*stype*/ ==  NIT_NULL /*null*/) || (( variable[5] /*stype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*stype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*stype*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*stype*/)( variable[5] /*stype*/,  NIT_NULL /*null*/) /*Object::==*/)))));
      /* Ensure var variable[10]: Left 'or' operand*/
      if (!UNTAG_Bool(variable[10])) { /* or */
        /* Register variable[10]: Result */
        variable[10] = CALL_static_type___MMType_____l( variable[5] /*stype*/)( variable[5] /*stype*/,  variable[9] /*t*/) /*MMType::<*/;
      }
      /* Register variable[10]: Result */
      if (UNTAG_Bool(variable[10])) { /*if*/
        variable[5] =  variable[9] /*t*/ /*stype=*/;
      }
      continue_165: while(0);
      CALL_abstract_collection___Iterator___next(variable[6])(variable[6]) /*ArrayIterator::next*/;
    }
    break_165: while(0);
    /* Register variable[6]: For iterator */
    variable[6] = CALL_abstract_collection___Collection___iterator( variable[4] /*stypes*/)( variable[4] /*stypes*/) /*AbstractArrayRead::iterator*/;
    while (true) { /*for*/
      /* Register variable[7]: For 'is_ok' result */
      variable[7] = CALL_abstract_collection___Iterator___is_ok(variable[6])(variable[6]) /*ArrayIterator::is_ok*/;
      if (!UNTAG_Bool(variable[7])) break; /*for*/
      variable[7] = CALL_abstract_collection___Iterator___item(variable[6])(variable[6]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
      /* Register variable[8]: Local variable */
      variable[8] = variable[7];
      CALL_syntax_base___AbsSyntaxVisitor___check_conform( variable[1] /*v*/)( variable[1] /*v*/, variable[0],  variable[8] /*t*/,  variable[5] /*stype*/) /*AbsSyntaxVisitor::check_conform*/;
      continue_166: while(0);
      CALL_abstract_collection___Iterator___next(variable[6])(variable[6]) /*ArrayIterator::next*/;
    }
    break_166: while(0);
    ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ =  variable[5] /*stype*/;
  }
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(( variable[4] /*p*/==NIT_NULL) || VAL_ISA( variable[4] /*p*/, COLOR_MMSrcMethod, ID_MMSrcMethod)) /*cast MMSrcMethod*/;
  if (!UNTAG_Bool(variable[5])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___ASuperExpr___after_typing, LOCATE_typing, 937); nit_exit(1);}
  ATTR_typing___AAbsSendExpr____prop(variable[0]) /*AAbsSendExpr::_prop*/ =  variable[4] /*p*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label152: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASuperExpr___init_in_superclass(val_t  self) {
  struct trace_t trace = {NULL, NULL, 884, LOCATE_typing___ASuperExpr___init_in_superclass};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASuperExpr____init_in_superclass( self) /*ASuperExpr::_init_in_superclass*/;
}
val_t typing___AAttrFormExpr___prop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 944, LOCATE_typing___AAttrFormExpr___prop};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAttrFormExpr____prop( self) /*AAttrFormExpr::_prop*/;
}
val_t typing___AAttrFormExpr___attr_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 947, LOCATE_typing___AAttrFormExpr___attr_type};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAttrFormExpr____attr_type( self) /*AAttrFormExpr::_attr_type*/;
}
void typing___AAttrFormExpr___do_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 950, LOCATE_typing___AAttrFormExpr___do_typing};
    static val_t once_value_168 = NIT_NULL; /* Once value for string variable[7]*/
    static val_t once_value_169 = NIT_NULL; /* Once value for string variable[7]*/
    static val_t once_value_170 = NIT_NULL; /* Once value for string variable[7]*/
    static val_t once_value_171 = NIT_NULL; /* Once value for string variable[8]*/
    static val_t once_value_172 = NIT_NULL; /* Once value for string variable[8]*/
    static val_t once_value_173 = NIT_NULL; /* Once value for string variable[8]*/
    static val_t once_value_174 = NIT_NULL; /* Once value for string variable[8]*/
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAttrFormExpr___n_expr(variable[0])(variable[0]) /*AAttrFormExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label167;
  }
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAttrFormExpr___n_expr(variable[0])(variable[0]) /*AAttrFormExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  variable[3] = variable[4];
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AAttrFormExpr___n_id(variable[0])(variable[0]) /*AAttrFormExpr::n_id*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___Token___to_symbol(variable[5])(variable[5]) /*Token::to_symbol*/;
  variable[4] = variable[5];
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_static_type___MMType___local_class( variable[3] /*type_recv*/)( variable[3] /*type_recv*/) /*MMType::local_class*/;
  variable[5] = variable[6];
  /* Register variable[6]: Result */
  variable[6] = CALL_abstractmetamodel___MMLocalClass___has_global_property_by_name( variable[5] /*lc*/)( variable[5] /*lc*/,  variable[4] /*name*/) /*MMLocalClass::has_global_property_by_name*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
    variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[7]: Once String constant */
    if (once_value_168 != NIT_NULL) variable[7] = once_value_168;
    else {
      variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Error: Attribute "), TAG_Int(17)) /*new String*/;
      once_value_168 = variable[7];
    }
    /* Register variable[7]: Result */
    /* Ensure var variable[7]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[7]) /*AbstractArray::add*/;
    variable[7] =  variable[4] /*name*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[7]: Once String constant */
    if (once_value_169 != NIT_NULL) variable[7] = once_value_169;
    else {
      variable[7] = NEW_String_string___String___with_native(BOX_NativeString(" doesn't exists in "), TAG_Int(19)) /*new String*/;
      once_value_169 = variable[7];
    }
    /* Register variable[7]: Result */
    /* Ensure var variable[7]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[7]) /*AbstractArray::add*/;
    variable[7] =  variable[3] /*type_recv*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[7]: Once String constant */
    if (once_value_170 != NIT_NULL) variable[7] = once_value_170;
    else {
      variable[7] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
      once_value_170 = variable[7];
    }
    /* Register variable[7]: Result */
    /* Ensure var variable[7]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[7]) /*AbstractArray::add*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[6]) /*AbsSyntaxVisitor::error*/;
    goto return_label167;
  }
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_abstractmetamodel___MMLocalClass___select_attribute( variable[5] /*lc*/)( variable[5] /*lc*/,  variable[4] /*name*/) /*MMLocalClass::select_attribute*/;
  variable[6] = variable[7];
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_abstractmetamodel___MMLocalProperty___global( variable[6] /*prop*/)( variable[6] /*prop*/) /*MMLocalProperty::global*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_abstractmetamodel___MMGlobalProperty___local_class(variable[8])(variable[8]) /*MMGlobalProperty::local_class*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_abstractmetamodel___MMLocalClass___module(variable[8])(variable[8]) /*MMLocalClass::module*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_abstractmetamodel___MMModule___visibility_for(variable[7])(variable[7], variable[8]) /*MMModule::visibility_for*/;
  /* Register variable[7]: Result */
  variable[7] = TAG_Bool(UNTAG_Int(variable[7])<UNTAG_Int( TAG_Int(3)));
  if (UNTAG_Bool(variable[7])) { /*if*/
    variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(7)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[8]: Once String constant */
    if (once_value_171 != NIT_NULL) variable[8] = once_value_171;
    else {
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: Attribute "), TAG_Int(17)) /*new String*/;
      once_value_171 = variable[8];
    }
    /* Register variable[8]: Result */
    /* Ensure var variable[8]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
    variable[8] =  variable[4] /*name*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[8]: Once String constant */
    if (once_value_172 != NIT_NULL) variable[8] = once_value_172;
    else {
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString(" from "), TAG_Int(6)) /*new String*/;
      once_value_172 = variable[8];
    }
    /* Register variable[8]: Result */
    /* Ensure var variable[8]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_abstractmetamodel___MMLocalProperty___global( variable[6] /*prop*/)( variable[6] /*prop*/) /*MMLocalProperty::global*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_abstractmetamodel___MMGlobalProperty___local_class(variable[8])(variable[8]) /*MMGlobalProperty::local_class*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_abstractmetamodel___MMLocalClass___module(variable[8])(variable[8]) /*MMLocalClass::module*/;
    /* Ensure var variable[8]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[8]: Once String constant */
    if (once_value_173 != NIT_NULL) variable[8] = once_value_173;
    else {
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString(" is invisible in "), TAG_Int(17)) /*new String*/;
      once_value_173 = variable[8];
    }
    /* Register variable[8]: Result */
    /* Ensure var variable[8]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
    /* Ensure var variable[8]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[8]: Once String constant */
    if (once_value_174 != NIT_NULL) variable[8] = once_value_174;
    else {
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_174 = variable[8];
    }
    /* Register variable[8]: Result */
    /* Ensure var variable[8]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::error*/;
  }
  ATTR_typing___AAttrFormExpr____prop(variable[0]) /*AAttrFormExpr::_prop*/ =  variable[6] /*prop*/;
  /* Register variable[7]: Local variable */
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMLocalProperty___signature_for( variable[6] /*prop*/)( variable[6] /*prop*/,  variable[3] /*type_recv*/) /*MMLocalProperty::signature_for*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMSignature___return_type(variable[8])(variable[8]) /*MMSignature::return_type*/;
  variable[7] = variable[8];
  /* Register variable[8]: Result */
  variable[8] = CALL_parser_nodes___AAttrFormExpr___n_expr(variable[0])(variable[0]) /*AAttrFormExpr::n_expr*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_typing___PExpr___is_self(variable[8])(variable[8]) /*PExpr::is_self*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[8])))) { /*if*/
    /* Register variable[8]: Result */
    variable[8] = CALL_static_type___MMType___not_for_self( variable[7] /*at*/)( variable[7] /*at*/) /*MMType::not_for_self*/;
    variable[7] = variable[8] /*at=*/;
  }
  ATTR_typing___AAttrFormExpr____attr_type(variable[0]) /*AAttrFormExpr::_attr_type*/ =  variable[7] /*at*/;
  return_label167: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAttrExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 973, LOCATE_typing___AAttrExpr___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_typing___AAttrFormExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/) /*AAttrFormExpr::do_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAttrFormExpr___prop(variable[0])(variable[0]) /*AAttrFormExpr::prop*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label175;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAttrFormExpr___attr_type(variable[0])(variable[0]) /*AAttrFormExpr::attr_type*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label175: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAttrAssignExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 983, LOCATE_typing___AAttrAssignExpr___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_typing___AAttrFormExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/) /*AAttrFormExpr::do_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAttrFormExpr___prop(variable[0])(variable[0]) /*AAttrFormExpr::prop*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label176;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[0])(variable[0]) /*AAssignFormExpr::n_value*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___AAttrFormExpr___attr_type(variable[0])(variable[0]) /*AAttrFormExpr::attr_type*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3], variable[4]) /*AbsSyntaxVisitor::check_conform_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label176;
  }
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label176: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAttrReassignExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 993, LOCATE_typing___AAttrReassignExpr___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_typing___AAttrFormExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/) /*AAttrFormExpr::do_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAttrFormExpr___prop(variable[0])(variable[0]) /*AAttrFormExpr::prop*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label177;
  }
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___AAttrFormExpr___attr_type(variable[0])(variable[0]) /*AAttrFormExpr::attr_type*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___AReassignFormExpr___do_rvalue_typing(variable[0])(variable[0],  variable[1] /*v*/, variable[4]) /*AReassignFormExpr::do_rvalue_typing*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label177;
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[0])(variable[0]) /*AReassignFormExpr::n_value*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform( variable[1] /*v*/)( variable[1] /*v*/, variable[0],  variable[3] /*t*/, variable[4]) /*AbsSyntaxVisitor::check_conform*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label177: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AIssetAttrExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1005, LOCATE_typing___AIssetAttrExpr___after_typing};
    static val_t once_value_179 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_typing___AAttrFormExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/) /*AAttrFormExpr::do_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAttrFormExpr___prop(variable[0])(variable[0]) /*AAttrFormExpr::prop*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label178;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAttrFormExpr___attr_type(variable[0])(variable[0]) /*AAttrFormExpr::attr_type*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_static_type___MMType___is_nullable(variable[3])(variable[3]) /*MMType::is_nullable*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Once String constant */
    if (once_value_179 != NIT_NULL) variable[3] = once_value_179;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString("Error: isset on a nullable attribute."), TAG_Int(37)) /*new String*/;
      once_value_179 = variable[3];
    }
    /* Register variable[3]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::error*/;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label178: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AAbsAbsSendExpr___prop_signature(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1019, LOCATE_typing___AAbsAbsSendExpr___prop_signature};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAbsAbsSendExpr____prop_signature( self) /*AAbsAbsSendExpr::_prop_signature*/;
}
val_t typing___AAbsAbsSendExpr___arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1022, LOCATE_typing___AAbsAbsSendExpr___arguments};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAbsAbsSendExpr____arguments( self) /*AAbsAbsSendExpr::_arguments*/;
}
val_t typing___AAbsAbsSendExpr___process_signature(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 1025, LOCATE_typing___AAbsAbsSendExpr___process_signature};
    static val_t once_value_181 = NIT_NULL; /* Once value for string variable[10]*/
    static val_t once_value_182 = NIT_NULL; /* Once value for string variable[10]*/
  val_t variable[24];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Local variable */
  variable[4] =  param3;
  /* Register variable[5]: Method return value and escape marker */
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_vararg___MMSignature___vararg_rank( variable[2] /*psig*/)( variable[2] /*psig*/) /*MMSignature::vararg_rank*/;
  variable[6] = variable[7];
  /* Register variable[7]: Local variable */
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMSignature___arity( variable[2] /*psig*/)( variable[2] /*psig*/) /*MMSignature::arity*/;
  variable[7] = variable[8];
  /* Register variable[8]: Local variable */
  /*variable[8] is variable raw_arity*/
  /* Register variable[9]: Result */
  variable[9] = TAG_Bool(( variable[4] /*raw_args*/ ==  NIT_NULL /*null*/) || (( variable[4] /*raw_args*/ != NIT_NULL) && UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*raw_args*/)( variable[4] /*raw_args*/,  NIT_NULL /*null*/) /*AbstractArrayRead::==*/)));
  if (UNTAG_Bool(variable[9])) { /*if*/
    variable[8] =  TAG_Int(0) /*raw_arity=*/;
  } else { /*if*/
    /* Register variable[9]: Result */
    variable[9] = CALL_abstract_collection___Collection___length( variable[4] /*raw_args*/)( variable[4] /*raw_args*/) /*AbstractArrayRead::length*/;
    variable[8] = variable[9] /*raw_arity=*/;
  }
  /* Register variable[9]: Result */
  variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*par_arity*/)>UNTAG_Int( variable[8] /*raw_arity*/));
  /* Ensure var variable[9]: Left 'or' operand*/
  if (!UNTAG_Bool(variable[9])) { /* or */
    /* Register variable[9]: Result */
    variable[9] = TAG_Bool(( variable[7] /*par_arity*/)!=( variable[8] /*raw_arity*/));
    /* Ensure var variable[9]: Left 'and' operand*/
    if (UNTAG_Bool(variable[9])) { /* and */
      /* Register variable[9]: Result */
      variable[9] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
      /* Register variable[9]: Result */
      variable[9] = TAG_Bool(( variable[6] /*par_vararg*/)==(variable[9]));
    }
    /* Register variable[9]: Result */
  }
  /* Register variable[9]: Result */
  if (UNTAG_Bool(variable[9])) { /*if*/
    variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[10]: Once String constant */
    if (once_value_181 != NIT_NULL) variable[10] = once_value_181;
    else {
      variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: '"), TAG_Int(8)) /*new String*/;
      once_value_181 = variable[10];
    }
    /* Register variable[10]: Result */
    /* Ensure var variable[10]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
    variable[10] =  variable[3] /*name*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[10]: Once String constant */
    if (once_value_182 != NIT_NULL) variable[10] = once_value_182;
    else {
      variable[10] = NEW_String_string___String___with_native(BOX_NativeString("' arity missmatch."), TAG_Int(18)) /*new String*/;
      once_value_182 = variable[10];
    }
    /* Register variable[10]: Result */
    /* Ensure var variable[10]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
    /* Register variable[9]: Result */
    variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[9]) /*AbsSyntaxVisitor::error*/;
    variable[5] =  NIT_NULL /*null*/;
    goto return_label180;
  }
  /* Register variable[9]: Local variable */
  variable[9] =  TAG_Int(0);
  /* Register variable[10]: Local variable */
  /* Register variable[11]: Result */
  variable[11] = NEW_Array_array___Array___init() /*new Array[PExpr]*/;
  variable[10] = variable[11];
  /* Register variable[11]: Result */
  variable[11] = NEW_Range_range___Range___without_last( TAG_Int(0),  variable[7] /*par_arity*/) /*new Range[Int]*/;
  /* Register variable[11]: For iterator */
  variable[11] = CALL_abstract_collection___Collection___iterator(variable[11])(variable[11]) /*Range::iterator*/;
  while (true) { /*for*/
    /* Register variable[12]: For 'is_ok' result */
    variable[12] = CALL_abstract_collection___Iterator___is_ok(variable[11])(variable[11]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[12])) break; /*for*/
    variable[12] = CALL_abstract_collection___Iterator___item(variable[11])(variable[11]) /*Iterator::item*/ /* Ensure var: For item*/;
    /* Register variable[13]: Local variable */
    variable[13] = variable[12];
    /* Register variable[14]: Local variable */
    /*variable[14] is variable a*/
    /* Register variable[15]: Local variable */
    /* Register variable[16]: Result */
    variable[16] = CALL_static_type___MMSignature_____bra( variable[2] /*psig*/)( variable[2] /*psig*/,  variable[13] /*par_idx*/) /*MMSignature::[]*/;
    variable[15] = variable[16];
    /* Register variable[16]: Result */
    variable[16] = TAG_Bool(( variable[13] /*par_idx*/)==( variable[6] /*par_vararg*/));
    if (UNTAG_Bool(variable[16])) { /*if*/
      /* Register variable[16]: Local variable */
      /* Register variable[17]: Result */
      variable[17] = NEW_Array_array___Array___init() /*new Array[PExpr]*/;
      variable[16] = variable[17];
      /* Register variable[17]: Result */
      variable[17] = TAG_Int(UNTAG_Int( variable[8] /*raw_arity*/)-UNTAG_Int( variable[7] /*par_arity*/));
      /* Register variable[17]: Result */
      variable[17] = NEW_Range_range___Range___init( TAG_Int(0), variable[17]) /*new Range[Int]*/;
      /* Register variable[17]: For iterator */
      variable[17] = CALL_abstract_collection___Collection___iterator(variable[17])(variable[17]) /*Range::iterator*/;
      while (true) { /*for*/
        /* Register variable[18]: For 'is_ok' result */
        variable[18] = CALL_abstract_collection___Iterator___is_ok(variable[17])(variable[17]) /*Iterator::is_ok*/;
        if (!UNTAG_Bool(variable[18])) break; /*for*/
        variable[18] = CALL_abstract_collection___Iterator___item(variable[17])(variable[17]) /*Iterator::item*/ /* Ensure var: For item*/;
        /* Register variable[19]: Local variable */
        variable[19] = variable[18];
        /* Register variable[20]: Local variable */
        variable[20] =  variable[4] /*raw_args*/;
        /* Register variable[21]: Local variable */
        variable[21] =  variable[9] /*arg_idx*/;
        /* Register variable[22]: Method return value and escape marker */
        /* Register variable[23]: Result */
        variable[23] = TAG_Bool(UNTAG_Int( variable[21] /*index*/)>=UNTAG_Int( TAG_Int(0)));
        /* Ensure var variable[23]: Left 'and' operand*/
        if (UNTAG_Bool(variable[23])) { /* and */
          /* Register variable[23]: Result */
          variable[23] = ATTR_array___AbstractArrayRead____length(variable[20]) /*AbstractArrayRead::_length*/;
          /* Register variable[23]: Result */
          variable[23] = TAG_Bool(UNTAG_Int( variable[21] /*index*/)<UNTAG_Int(variable[23]));
        }
        /* Register variable[23]: Result */
        if (!UNTAG_Bool(variable[23])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 234); nit_exit(1);}
        /* Register variable[23]: Result */
        variable[23] = ATTR_array___Array____items(variable[20]) /*Array::_items*/;
        /* Register variable[23]: Result */
        variable[23] = UNBOX_NativeArray(variable[23])[UNTAG_Int( variable[21] /*index*/)];
        variable[22] = variable[23];
        goto return_label185;
        return_label185: while(false);
        /* Register variable[20]: Result */
        variable[20] = variable[22];
        variable[14] = variable[20] /*a=*/;
        CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/,  variable[14] /*a*/,  variable[15] /*par_type*/) /*AbsSyntaxVisitor::check_conform_expr*/;
        CALL_abstract_collection___SimpleCollection___add( variable[16] /*star*/)( variable[16] /*star*/,  variable[14] /*a*/) /*AbstractArray::add*/;
        /* Register variable[20]: Result */
        variable[20] = TAG_Int(UNTAG_Int( variable[9] /*arg_idx*/)+UNTAG_Int( TAG_Int(1)));
        variable[9] = variable[20] /*arg_idx=*/;
        continue_184: while(0);
        CALL_abstract_collection___Iterator___next(variable[17])(variable[17]) /*Iterator::next*/;
      }
      break_184: while(0);
      /* Register variable[17]: Local variable */
      /* Register variable[18]: Result */
      variable[18] = NEW_AArrayExpr_parser_prod___AArrayExpr___init_aarrayexpr( variable[16] /*star*/) /*new AArrayExpr*/;
      variable[17] = variable[18];
      CALL_typing___AArrayExpr___do_typing( variable[17] /*aa*/)( variable[17] /*aa*/,  variable[1] /*v*/,  variable[15] /*par_type*/) /*AArrayExpr::do_typing*/;
      variable[14] =  variable[17] /*aa*/ /*a=*/;
    } else { /*if*/
      /* Register variable[16]: Local variable */
      variable[16] =  variable[4] /*raw_args*/;
      /* Register variable[17]: Local variable */
      variable[17] =  variable[9] /*arg_idx*/;
      /* Register variable[18]: Method return value and escape marker */
      /* Register variable[19]: Result */
      variable[19] = TAG_Bool(UNTAG_Int( variable[17] /*index*/)>=UNTAG_Int( TAG_Int(0)));
      /* Ensure var variable[19]: Left 'and' operand*/
      if (UNTAG_Bool(variable[19])) { /* and */
        /* Register variable[19]: Result */
        variable[19] = ATTR_array___AbstractArrayRead____length(variable[16]) /*AbstractArrayRead::_length*/;
        /* Register variable[19]: Result */
        variable[19] = TAG_Bool(UNTAG_Int( variable[17] /*index*/)<UNTAG_Int(variable[19]));
      }
      /* Register variable[19]: Result */
      if (!UNTAG_Bool(variable[19])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 234); nit_exit(1);}
      /* Register variable[19]: Result */
      variable[19] = ATTR_array___Array____items(variable[16]) /*Array::_items*/;
      /* Register variable[19]: Result */
      variable[19] = UNBOX_NativeArray(variable[19])[UNTAG_Int( variable[17] /*index*/)];
      variable[18] = variable[19];
      goto return_label186;
      return_label186: while(false);
      /* Register variable[16]: Result */
      variable[16] = variable[18];
      variable[14] = variable[16] /*a=*/;
      CALL_syntax_base___AbsSyntaxVisitor___check_conform_expr( variable[1] /*v*/)( variable[1] /*v*/,  variable[14] /*a*/,  variable[15] /*par_type*/) /*AbsSyntaxVisitor::check_conform_expr*/;
      /* Register variable[16]: Result */
      variable[16] = TAG_Int(UNTAG_Int( variable[9] /*arg_idx*/)+UNTAG_Int( TAG_Int(1)));
      variable[9] = variable[16] /*arg_idx=*/;
    }
    CALL_abstract_collection___SimpleCollection___add( variable[10] /*args*/)( variable[10] /*args*/,  variable[14] /*a*/) /*AbstractArray::add*/;
    continue_183: while(0);
    CALL_abstract_collection___Iterator___next(variable[11])(variable[11]) /*Iterator::next*/;
  }
  break_183: while(0);
  variable[5] =  variable[10] /*args*/;
  goto return_label180;
  return_label180: while(false);
  tracehead = trace.prev;
  return variable[5];
}
val_t typing___AAbsAbsSendExpr___process_closures(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 1062, LOCATE_typing___AAbsAbsSendExpr___process_closures};
      static val_t once_value_189 = NIT_NULL; /* Once value for string variable[10]*/
      static val_t once_value_190 = NIT_NULL; /* Once value for string variable[10]*/
        static val_t once_value_191 = NIT_NULL; /* Once value for string variable[10]*/
        static val_t once_value_192 = NIT_NULL; /* Once value for string variable[10]*/
        static val_t once_value_193 = NIT_NULL; /* Once value for string variable[10]*/
        static val_t once_value_194 = NIT_NULL; /* Once value for string variable[10]*/
      static val_t once_value_198 = NIT_NULL; /* Once value for string variable[10]*/
      static val_t once_value_199 = NIT_NULL; /* Once value for string variable[10]*/
      static val_t once_value_200 = NIT_NULL; /* Once value for string variable[10]*/
  val_t variable[19];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Local variable */
  variable[4] =  param3;
  /* Register variable[5]: Method return value and escape marker */
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_static_type___MMSignature___return_type( variable[2] /*psig*/)( variable[2] /*psig*/) /*MMSignature::return_type*/;
  variable[6] = variable[7];
  /* Register variable[7]: Local variable */
  /* Register variable[8]: Result */
  variable[8] = CALL_static_type___MMSignature___closures( variable[2] /*psig*/)( variable[2] /*psig*/) /*MMSignature::closures*/;
  variable[7] = variable[8];
  /* Register variable[8]: Local variable */
  variable[8] =  TAG_Int(0);
  /* Register variable[9]: For iterator */
  variable[9] = CALL_abstract_collection___Collection___iterator( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArrayRead::iterator*/;
  while (true) { /*for*/
    /* Register variable[10]: For 'is_ok' result */
    variable[10] = CALL_abstract_collection___Iterator___is_ok(variable[9])(variable[9]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[10])) break; /*for*/
    variable[10] = CALL_abstract_collection___Iterator___item(variable[9])(variable[9]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
    /* Register variable[11]: Local variable */
    variable[11] = variable[10];
    /* Register variable[12]: Result */
    variable[12] = CALL_static_type___MMClosure___is_optional( variable[11] /*c*/)( variable[11] /*c*/) /*MMClosure::is_optional*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[12])))) { /*if*/
      variable[8] = TAG_Int(UNTAG_Int(variable[8])+UNTAG_Int( TAG_Int(1))) /*min_arity*/;
    }
    continue_188: while(0);
    CALL_abstract_collection___Iterator___next(variable[9])(variable[9]) /*ArrayIterator::next*/;
  }
  break_188: while(0);
  /* Register variable[9]: Result */
  variable[9] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*cd*/ ==  NIT_NULL /*null*/) || (( variable[4] /*cd*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*cd*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*cd*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*cd*/)( variable[4] /*cd*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[9])) { /*if*/
    /* Register variable[9]: Result */
    variable[9] = CALL_abstract_collection___Collection___length( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArrayRead::length*/;
    /* Register variable[9]: Result */
    variable[9] = TAG_Bool((variable[9])==( TAG_Int(0)));
    if (UNTAG_Bool(variable[9])) { /*if*/
      variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[10]: Once String constant */
      if (once_value_189 != NIT_NULL) variable[10] = once_value_189;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
        once_value_189 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      variable[10] =  variable[3] /*name*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[10]: Once String constant */
      if (once_value_190 != NIT_NULL) variable[10] = once_value_190;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" does not require blocks."), TAG_Int(25)) /*new String*/;
        once_value_190 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      /* Register variable[9]: Result */
      variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[9]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[9]: Result */
      variable[9] = CALL_abstract_collection___Collection___length( variable[4] /*cd*/)( variable[4] /*cd*/) /*AbstractArrayRead::length*/;
      /* Register variable[10]: Result */
      variable[10] = CALL_abstract_collection___Collection___length( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArrayRead::length*/;
      /* Register variable[9]: Result */
      variable[9] = TAG_Bool(UNTAG_Int(variable[9])>UNTAG_Int(variable[10]));
      /* Ensure var variable[9]: Left 'or' operand*/
      if (!UNTAG_Bool(variable[9])) { /* or */
        /* Register variable[9]: Result */
        variable[9] = CALL_abstract_collection___Collection___length( variable[4] /*cd*/)( variable[4] /*cd*/) /*AbstractArrayRead::length*/;
        /* Register variable[9]: Result */
        variable[9] = TAG_Bool(UNTAG_Int(variable[9])<UNTAG_Int( variable[8] /*min_arity*/));
      }
      /* Register variable[9]: Result */
      if (UNTAG_Bool(variable[9])) { /*if*/
        variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(7)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[10]: Once String constant */
        if (once_value_191 != NIT_NULL) variable[10] = once_value_191;
        else {
          variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
          once_value_191 = variable[10];
        }
        /* Register variable[10]: Result */
        /* Ensure var variable[10]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
        variable[10] =  variable[3] /*name*/ /* Ensure var: super-string element*/;
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[10]: Once String constant */
        if (once_value_192 != NIT_NULL) variable[10] = once_value_192;
        else {
          variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" requires "), TAG_Int(10)) /*new String*/;
          once_value_192 = variable[10];
        }
        /* Register variable[10]: Result */
        /* Ensure var variable[10]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
        /* Register variable[10]: Result */
        variable[10] = CALL_abstract_collection___Collection___length( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArrayRead::length*/;
        /* Ensure var variable[10]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[10]: Once String constant */
        if (once_value_193 != NIT_NULL) variable[10] = once_value_193;
        else {
          variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" blocks, "), TAG_Int(9)) /*new String*/;
          once_value_193 = variable[10];
        }
        /* Register variable[10]: Result */
        /* Ensure var variable[10]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
        /* Register variable[10]: Result */
        variable[10] = CALL_abstract_collection___Collection___length( variable[4] /*cd*/)( variable[4] /*cd*/) /*AbstractArrayRead::length*/;
        /* Ensure var variable[10]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[10]: Once String constant */
        if (once_value_194 != NIT_NULL) variable[10] = once_value_194;
        else {
          variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" found."), TAG_Int(7)) /*new String*/;
          once_value_194 = variable[10];
        }
        /* Register variable[10]: Result */
        /* Ensure var variable[10]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
        /* Register variable[9]: Result */
        variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[9]) /*AbsSyntaxVisitor::error*/;
      } else { /*if*/
        /* Register variable[9]: Local variable */
        variable[9] =  NIT_NULL /*null*/;
        /* Register variable[10]: Result */
        variable[10] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[6] /*t*/ ==  NIT_NULL /*null*/) || (( variable[6] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[6] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[6] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[6] /*t*/)( variable[6] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
        if (UNTAG_Bool(variable[10])) { /*if*/
          /* Register variable[10]: Result */
          variable[10] = NEW_Array_array___Array___init() /*new Array[ABreakExpr]*/;
          variable[9] = variable[10] /*break_list=*/;
        }
        /* Register variable[10]: Result */
        variable[10] = CALL_abstract_collection___Collection___length( variable[4] /*cd*/)( variable[4] /*cd*/) /*AbstractArrayRead::length*/;
        /* Register variable[10]: Result */
        variable[10] = NEW_Range_range___Range___without_last( TAG_Int(0), variable[10]) /*new Range[Int]*/;
        /* Register variable[10]: For iterator */
        variable[10] = CALL_abstract_collection___Collection___iterator(variable[10])(variable[10]) /*Range::iterator*/;
        while (true) { /*for*/
          /* Register variable[11]: For 'is_ok' result */
          variable[11] = CALL_abstract_collection___Iterator___is_ok(variable[10])(variable[10]) /*Iterator::is_ok*/;
          if (!UNTAG_Bool(variable[11])) break; /*for*/
          variable[11] = CALL_abstract_collection___Iterator___item(variable[10])(variable[10]) /*Iterator::item*/ /* Ensure var: For item*/;
          /* Register variable[12]: Local variable */
          variable[12] = variable[11];
          /* Register variable[13]: Local variable */
          /* Register variable[14]: Local variable */
          variable[14] =  variable[7] /*cs*/;
          /* Register variable[15]: Local variable */
          variable[15] =  variable[12] /*i*/;
          /* Register variable[16]: Method return value and escape marker */
          /* Register variable[17]: Result */
          variable[17] = TAG_Bool(UNTAG_Int( variable[15] /*index*/)>=UNTAG_Int( TAG_Int(0)));
          /* Ensure var variable[17]: Left 'and' operand*/
          if (UNTAG_Bool(variable[17])) { /* and */
            /* Register variable[17]: Result */
            variable[17] = ATTR_array___AbstractArrayRead____length(variable[14]) /*AbstractArrayRead::_length*/;
            /* Register variable[17]: Result */
            variable[17] = TAG_Bool(UNTAG_Int( variable[15] /*index*/)<UNTAG_Int(variable[17]));
          }
          /* Register variable[17]: Result */
          if (!UNTAG_Bool(variable[17])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 234); nit_exit(1);}
          /* Register variable[17]: Result */
          variable[17] = ATTR_array___Array____items(variable[14]) /*Array::_items*/;
          /* Register variable[17]: Result */
          variable[17] = UNBOX_NativeArray(variable[17])[UNTAG_Int( variable[15] /*index*/)];
          variable[16] = variable[17];
          goto return_label196;
          return_label196: while(false);
          /* Register variable[14]: Result */
          variable[14] = variable[16];
          variable[13] = variable[14];
          /* Register variable[14]: Local variable */
          /* Register variable[15]: Local variable */
          variable[15] =  variable[4] /*cd*/;
          /* Register variable[16]: Local variable */
          variable[16] =  variable[12] /*i*/;
          /* Register variable[17]: Method return value and escape marker */
          /* Register variable[18]: Result */
          variable[18] = TAG_Bool(UNTAG_Int( variable[16] /*index*/)>=UNTAG_Int( TAG_Int(0)));
          /* Ensure var variable[18]: Left 'and' operand*/
          if (UNTAG_Bool(variable[18])) { /* and */
            /* Register variable[18]: Result */
            variable[18] = ATTR_array___AbstractArrayRead____length(variable[15]) /*AbstractArrayRead::_length*/;
            /* Register variable[18]: Result */
            variable[18] = TAG_Bool(UNTAG_Int( variable[16] /*index*/)<UNTAG_Int(variable[18]));
          }
          /* Register variable[18]: Result */
          if (!UNTAG_Bool(variable[18])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_typing, 234); nit_exit(1);}
          /* Register variable[18]: Result */
          variable[18] = ATTR_array___Array____items(variable[15]) /*Array::_items*/;
          /* Register variable[18]: Result */
          variable[18] = UNBOX_NativeArray(variable[18])[UNTAG_Int( variable[16] /*index*/)];
          variable[17] = variable[18];
          goto return_label197;
          return_label197: while(false);
          /* Register variable[15]: Result */
          variable[15] = variable[17];
          variable[14] = variable[15];
          /* Register variable[15]: Local variable */
          /* Register variable[16]: Result */
          variable[16] = NEW_EscapableClosure_escape___EscapableClosure___init( variable[14] /*cdi*/,  variable[13] /*csi*/,  variable[9] /*break_list*/) /*new EscapableClosure*/;
          variable[15] = variable[16];
          /* Register variable[16]: Result */
          variable[16] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
          CALL_escape___EscapableContext___push(variable[16])(variable[16],  variable[15] /*esc*/) /*EscapableContext::push*/;
          CALL_typing___PClosureDef___accept_typing2( variable[14] /*cdi*/)( variable[14] /*cdi*/,  variable[1] /*v*/,  variable[15] /*esc*/) /*PClosureDef::accept_typing2*/;
          /* Register variable[16]: Result */
          variable[16] = CALL_typing___TypingVisitor___escapable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::escapable_ctx*/;
          CALL_escape___EscapableContext___pop(variable[16])(variable[16]) /*EscapableContext::pop*/;
          continue_195: while(0);
          CALL_abstract_collection___Iterator___next(variable[10])(variable[10]) /*Iterator::next*/;
        }
        break_195: while(0);
        /* Register variable[10]: Result */
        variable[10] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[9] /*break_list*/ ==  NIT_NULL /*null*/) || (( variable[9] /*break_list*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[9] /*break_list*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[9] /*break_list*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[9] /*break_list*/)( variable[9] /*break_list*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
        if (UNTAG_Bool(variable[10])) { /*if*/
          /* Register variable[10]: Result */
          variable[10] = CALL_syntax_base___AbsSyntaxVisitor___check_conform_multiexpr( variable[1] /*v*/)( variable[1] /*v*/,  variable[6] /*t*/,  variable[9] /*break_list*/) /*AbsSyntaxVisitor::check_conform_multiexpr*/;
          variable[6] = variable[10] /*t=*/;
        }
      }
    }
  } else { /*if*/
    /* Register variable[9]: Result */
    variable[9] = TAG_Bool(( variable[8] /*min_arity*/)!=( TAG_Int(0)));
    if (UNTAG_Bool(variable[9])) { /*if*/
      variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[10]: Once String constant */
      if (once_value_198 != NIT_NULL) variable[10] = once_value_198;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
        once_value_198 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      variable[10] =  variable[3] /*name*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[10]: Once String constant */
      if (once_value_199 != NIT_NULL) variable[10] = once_value_199;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" requires "), TAG_Int(10)) /*new String*/;
        once_value_199 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      /* Register variable[10]: Result */
      variable[10] = CALL_abstract_collection___Collection___length( variable[7] /*cs*/)( variable[7] /*cs*/) /*AbstractArrayRead::length*/;
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[10]: Once String constant */
      if (once_value_200 != NIT_NULL) variable[10] = once_value_200;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString(" blocks."), TAG_Int(8)) /*new String*/;
        once_value_200 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      /* Register variable[9]: Result */
      variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[9]) /*AbsSyntaxVisitor::error*/;
    }
  }
  variable[5] =  variable[6] /*t*/;
  goto return_label187;
  return_label187: while(false);
  tracehead = trace.prev;
  return variable[5];
}
void typing___AAbsSendExpr___do_typing(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3, val_t  param4, val_t  param5, val_t  param6) {
  struct trace_t trace = {NULL, NULL, 1105, LOCATE_typing___AAbsSendExpr___do_typing};
  val_t variable[14];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Local variable */
  variable[4] =  param3;
  /* Register variable[5]: Local variable */
  variable[5] =  param4;
  /* Register variable[6]: Local variable */
  variable[6] =  param5;
  /* Register variable[7]: Local variable */
  variable[7] =  param6;
  /* Register variable[8]: Method return value and escape marker */
  /* Register variable[9]: Local variable */
  /* Register variable[10]: Result */
  variable[10] = CALL_typing___AAbsSendExpr___get_property(variable[0])(variable[0],  variable[1] /*v*/,  variable[2] /*type_recv*/,  variable[3] /*is_implicit_self*/,  variable[5] /*name*/) /*AAbsSendExpr::get_property*/;
  variable[9] = variable[10];
  /* Register variable[10]: Result */
  variable[10] = TAG_Bool(( variable[9] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[9] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[9] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[9] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[9] /*prop*/)( variable[9] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[10])) { /*if*/
    goto return_label201;
  }
  /* Register variable[10]: Local variable */
  /* Register variable[11]: Result */
  variable[11] = CALL_typing___AAbsSendExpr___get_signature(variable[0])(variable[0],  variable[1] /*v*/,  variable[2] /*type_recv*/,  variable[9] /*prop*/,  variable[4] /*recv_is_self*/) /*AAbsSendExpr::get_signature*/;
  variable[10] = variable[11];
  /* Register variable[11]: Result */
  variable[11] = TAG_Bool(( variable[10] /*sig*/ ==  NIT_NULL /*null*/) || (( variable[10] /*sig*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[10] /*sig*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[10] /*sig*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[10] /*sig*/)( variable[10] /*sig*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[11])) { /*if*/
    goto return_label201;
  }
  /* Register variable[11]: Local variable */
  /* Register variable[12]: Result */
  variable[12] = CALL_abstractmetamodel___MMLocalProperty___name( variable[9] /*prop*/)( variable[9] /*prop*/) /*MMLocalProperty::name*/;
  /* Register variable[12]: Result */
  variable[12] = CALL_typing___AAbsAbsSendExpr___process_signature(variable[0])(variable[0],  variable[1] /*v*/,  variable[10] /*sig*/, variable[12],  variable[6] /*raw_args*/) /*AAbsAbsSendExpr::process_signature*/;
  variable[11] = variable[12];
  /* Register variable[12]: Result */
  variable[12] = TAG_Bool(( variable[11] /*args*/ ==  NIT_NULL /*null*/) || (( variable[11] /*args*/ != NIT_NULL) && UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[11] /*args*/)( variable[11] /*args*/,  NIT_NULL /*null*/) /*AbstractArrayRead::==*/)));
  if (UNTAG_Bool(variable[12])) { /*if*/
    goto return_label201;
  }
  /* Register variable[12]: Local variable */
  /* Register variable[13]: Result */
  variable[13] = CALL_abstractmetamodel___MMLocalProperty___name( variable[9] /*prop*/)( variable[9] /*prop*/) /*MMLocalProperty::name*/;
  /* Register variable[13]: Result */
  variable[13] = CALL_typing___AAbsAbsSendExpr___process_closures(variable[0])(variable[0],  variable[1] /*v*/,  variable[10] /*sig*/, variable[13],  variable[7] /*closure_defs*/) /*AAbsAbsSendExpr::process_closures*/;
  variable[12] = variable[13];
  /* Register variable[13]: Result */
  variable[13] = TAG_Bool(( variable[12] /*rtype*/ ==  NIT_NULL /*null*/) || (( variable[12] /*rtype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[12] /*rtype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[12] /*rtype*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[12] /*rtype*/)( variable[12] /*rtype*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  /* Ensure var variable[13]: Left 'and' operand*/
  if (UNTAG_Bool(variable[13])) { /* and */
    /* Register variable[13]: Result */
    variable[13] = CALL_static_type___MMSignature___return_type( variable[10] /*sig*/)( variable[10] /*sig*/) /*MMSignature::return_type*/;
    /* Register variable[13]: Result */
    variable[13] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[13] ==  NIT_NULL /*null*/) || ((variable[13] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[13])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[13], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[13])(variable[13],  NIT_NULL /*null*/) /*Object::==*/)))))));
  }
  /* Register variable[13]: Result */
  if (UNTAG_Bool(variable[13])) { /*if*/
    goto return_label201;
  }
  ATTR_typing___AAbsSendExpr____prop(variable[0]) /*AAbsSendExpr::_prop*/ =  variable[9] /*prop*/;
  ATTR_typing___AAbsAbsSendExpr____prop_signature(variable[0]) /*AAbsAbsSendExpr::_prop_signature*/ =  variable[10] /*sig*/;
  ATTR_typing___AAbsAbsSendExpr____arguments(variable[0]) /*AAbsAbsSendExpr::_arguments*/ =  variable[11] /*args*/;
  ATTR_typing___AAbsSendExpr____return_type(variable[0]) /*AAbsSendExpr::_return_type*/ =  variable[12] /*rtype*/;
  return_label201: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AAbsSendExpr___get_property(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 1122, LOCATE_typing___AAbsSendExpr___get_property};
      static val_t once_value_203 = NIT_NULL; /* Once value for string variable[10]*/
      static val_t once_value_204 = NIT_NULL; /* Once value for string variable[10]*/
      static val_t once_value_205 = NIT_NULL; /* Once value for string variable[10]*/
      static val_t once_value_206 = NIT_NULL; /* Once value for string variable[10]*/
      static val_t once_value_207 = NIT_NULL; /* Once value for string variable[9]*/
      static val_t once_value_208 = NIT_NULL; /* Once value for string variable[9]*/
      static val_t once_value_209 = NIT_NULL; /* Once value for string variable[9]*/
      static val_t once_value_210 = NIT_NULL; /* Once value for string variable[9]*/
      static val_t once_value_211 = NIT_NULL; /* Once value for string variable[9]*/
      static val_t once_value_212 = NIT_NULL; /* Once value for string variable[9]*/
  val_t variable[12];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Local variable */
  variable[4] =  param3;
  /* Register variable[5]: Method return value and escape marker */
  /* Register variable[6]: Result */
  variable[6] = TAG_Bool(( variable[2] /*type_recv*/ ==  NIT_NULL /*null*/) || (( variable[2] /*type_recv*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[2] /*type_recv*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[2] /*type_recv*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[2] /*type_recv*/)( variable[2] /*type_recv*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[5] =  NIT_NULL /*null*/;
    goto return_label202;
  }
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_static_type___MMType___local_class( variable[2] /*type_recv*/)( variable[2] /*type_recv*/) /*MMType::local_class*/;
  variable[6] = variable[7];
  /* Register variable[7]: Local variable */
  variable[7] =  NIT_NULL /*null*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_abstractmetamodel___MMLocalClass___has_global_property_by_name( variable[6] /*lc*/)( variable[6] /*lc*/,  variable[4] /*name*/) /*MMLocalClass::has_global_property_by_name*/;
  if (UNTAG_Bool(variable[8])) { /*if*/
    /* Register variable[8]: Result */
    variable[8] = CALL_abstractmetamodel___MMLocalClass___select_method( variable[6] /*lc*/)( variable[6] /*lc*/,  variable[4] /*name*/) /*MMLocalClass::select_method*/;
    variable[7] = variable[8] /*prop=*/;
  }
  /* Register variable[8]: Result */
  variable[8] = TAG_Bool(( variable[7] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[7] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[7] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[7] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[7] /*prop*/)( variable[7] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  /* Ensure var variable[8]: Left 'and' operand*/
  if (UNTAG_Bool(variable[8])) { /* and */
    /* Register variable[8]: Result */
    variable[8] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_abstractmetamodel___MMLocalProperty___global(variable[8])(variable[8]) /*MMLocalProperty::global*/;
    /* Register variable[8]: Result */
    variable[8] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[8])(variable[8]) /*MMGlobalProperty::is_init*/;
  }
  /* Register variable[8]: Result */
  if (UNTAG_Bool(variable[8])) { /*if*/
    /* Register variable[8]: Local variable */
    /* Register variable[9]: Result */
    variable[9] = CALL_static_type___MMType___local_class( variable[2] /*type_recv*/)( variable[2] /*type_recv*/) /*MMType::local_class*/;
    /* Register variable[9]: Result */
    variable[9] = CALL_abstractmetamodel___MMLocalClass___super_methods_named(variable[9])(variable[9],  variable[4] /*name*/) /*MMLocalClass::super_methods_named*/;
    variable[8] = variable[9];
    /* Register variable[9]: Result */
    variable[9] = CALL_abstract_collection___Collection___length( variable[8] /*props*/)( variable[8] /*props*/) /*AbstractArrayRead::length*/;
    /* Register variable[9]: Result */
    variable[9] = TAG_Bool(UNTAG_Int(variable[9])>UNTAG_Int( TAG_Int(1)));
    if (UNTAG_Bool(variable[9])) { /*if*/
      variable[9] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[10]: Once String constant */
      if (once_value_203 != NIT_NULL) variable[10] = once_value_203;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString("Error: Ambigous method name '"), TAG_Int(29)) /*new String*/;
        once_value_203 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      variable[10] =  variable[4] /*name*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[10]: Once String constant */
      if (once_value_204 != NIT_NULL) variable[10] = once_value_204;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString("' for "), TAG_Int(6)) /*new String*/;
        once_value_204 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      /* Register variable[10]: Once String constant */
      if (once_value_205 != NIT_NULL) variable[10] = once_value_205;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)) /*new String*/;
        once_value_205 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Register variable[10]: Result */
      variable[10] = CALL_string___Collection___join( variable[8] /*props*/)( variable[8] /*props*/, variable[10]) /*Collection::join*/;
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      /* Register variable[10]: Once String constant */
      if (once_value_206 != NIT_NULL) variable[10] = once_value_206;
      else {
        variable[10] = NEW_String_string___String___with_native(BOX_NativeString(". Use explicit designation."), TAG_Int(27)) /*new String*/;
        once_value_206 = variable[10];
      }
      /* Register variable[10]: Result */
      /* Ensure var variable[10]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[9])(variable[9], variable[10]) /*AbstractArray::add*/;
      /* Register variable[9]: Result */
      variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[9]) /*AbsSyntaxVisitor::error*/;
      variable[5] =  NIT_NULL /*null*/;
      goto return_label202;
    } else { /*if*/
      /* Register variable[9]: Result */
      variable[9] = CALL_abstract_collection___Collection___length( variable[8] /*props*/)( variable[8] /*props*/) /*AbstractArrayRead::length*/;
      /* Register variable[9]: Result */
      variable[9] = TAG_Bool((variable[9])==( TAG_Int(1)));
      if (UNTAG_Bool(variable[9])) { /*if*/
        /* Register variable[9]: Local variable */
        /* Register variable[10]: Result */
        variable[10] = CALL_static_type___MMType___local_class( variable[2] /*type_recv*/)( variable[2] /*type_recv*/) /*MMType::local_class*/;
        /* Register variable[11]: Result */
        variable[11] = CALL_abstract_collection___Collection___first( variable[8] /*props*/)( variable[8] /*props*/) /*IndexedCollectionRead::first*/;
        /* Register variable[11]: Result */
        variable[11] = CALL_abstractmetamodel___MMLocalProperty___global(variable[11])(variable[11]) /*MMLocalProperty::global*/;
        /* Register variable[10]: Result */
        variable[10] = CALL_abstractmetamodel___MMLocalClass_____bra(variable[10])(variable[10], variable[11]) /*MMLocalClass::[]*/;
        variable[9] = variable[10];
        /* Register variable[10]: Result */
        variable[10] = TAG_Bool(( variable[9] /*p*/==NIT_NULL) || VAL_ISA( variable[9] /*p*/, COLOR_MMMethod, ID_MMMethod)) /*cast MMMethod*/;
        if (!UNTAG_Bool(variable[10])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_typing___AAbsSendExpr___get_property, LOCATE_typing, 1135); nit_exit(1);}
        variable[7] =  variable[9] /*p*/ /*prop=*/;
      }
    }
  }
  /* Register variable[8]: Result */
  variable[8] = TAG_Bool(( variable[7] /*prop*/ ==  NIT_NULL /*null*/) || (( variable[7] /*prop*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[7] /*prop*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[7] /*prop*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[7] /*prop*/)( variable[7] /*prop*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[8])) { /*if*/
    if (UNTAG_Bool( variable[3] /*is_implicit_self*/)) { /*if*/
      variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[9]: Once String constant */
      if (once_value_207 != NIT_NULL) variable[9] = once_value_207;
      else {
        variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: Method or variable '"), TAG_Int(27)) /*new String*/;
        once_value_207 = variable[9];
      }
      /* Register variable[9]: Result */
      /* Ensure var variable[9]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
      variable[9] =  variable[4] /*name*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[9]: Once String constant */
      if (once_value_208 != NIT_NULL) variable[9] = once_value_208;
      else {
        variable[9] = NEW_String_string___String___with_native(BOX_NativeString("' unknown in "), TAG_Int(13)) /*new String*/;
        once_value_208 = variable[9];
      }
      /* Register variable[9]: Result */
      /* Ensure var variable[9]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
      variable[9] =  variable[2] /*type_recv*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[9]: Once String constant */
      if (once_value_209 != NIT_NULL) variable[9] = once_value_209;
      else {
        variable[9] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
        once_value_209 = variable[9];
      }
      /* Register variable[9]: Result */
      /* Ensure var variable[9]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
      /* Register variable[8]: Result */
      variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[8]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[9]: Once String constant */
      if (once_value_210 != NIT_NULL) variable[9] = once_value_210;
      else {
        variable[9] = NEW_String_string___String___with_native(BOX_NativeString("Error: Method '"), TAG_Int(15)) /*new String*/;
        once_value_210 = variable[9];
      }
      /* Register variable[9]: Result */
      /* Ensure var variable[9]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
      variable[9] =  variable[4] /*name*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[9]: Once String constant */
      if (once_value_211 != NIT_NULL) variable[9] = once_value_211;
      else {
        variable[9] = NEW_String_string___String___with_native(BOX_NativeString("' doesn't exists in "), TAG_Int(20)) /*new String*/;
        once_value_211 = variable[9];
      }
      /* Register variable[9]: Result */
      /* Ensure var variable[9]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
      variable[9] =  variable[2] /*type_recv*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[9]: Once String constant */
      if (once_value_212 != NIT_NULL) variable[9] = once_value_212;
      else {
        variable[9] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
        once_value_212 = variable[9];
      }
      /* Register variable[9]: Result */
      /* Ensure var variable[9]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[9]) /*AbstractArray::add*/;
      /* Register variable[8]: Result */
      variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[8]) /*AbsSyntaxVisitor::error*/;
    }
    variable[5] =  NIT_NULL /*null*/;
    goto return_label202;
  }
  variable[5] =  variable[7] /*prop*/;
  goto return_label202;
  return_label202: while(false);
  tracehead = trace.prev;
  return variable[5];
}
val_t typing___AAbsSendExpr___get_signature(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 1151, LOCATE_typing___AAbsSendExpr___get_signature};
  val_t variable[8];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Local variable */
  variable[4] =  param3;
  /* Register variable[5]: Method return value and escape marker */
  /* Register variable[6]: Result */
  variable[6] = CALL_abstractmetamodel___MMLocalProperty___global( variable[3] /*prop*/)( variable[3] /*prop*/) /*MMLocalProperty::global*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
  CALL_syntax_base___MMGlobalProperty___check_visibility(variable[6])(variable[6],  variable[1] /*v*/, variable[0], variable[7],  variable[4] /*recv_is_self*/) /*MMGlobalProperty::check_visibility*/;
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_static_type___MMLocalProperty___signature_for( variable[3] /*prop*/)( variable[3] /*prop*/,  variable[2] /*type_recv*/) /*MMLocalProperty::signature_for*/;
  variable[6] = variable[7];
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool( variable[4] /*recv_is_self*/)))) { /*if*/
    /* Register variable[7]: Result */
    variable[7] = CALL_static_type___MMSignature___not_for_self( variable[6] /*psig*/)( variable[6] /*psig*/) /*MMSignature::not_for_self*/;
    variable[6] = variable[7] /*psig=*/;
  }
  variable[5] =  variable[6] /*psig*/;
  goto return_label213;
  return_label213: while(false);
  tracehead = trace.prev;
  return variable[5];
}
val_t typing___AAbsSendExpr___prop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1160, LOCATE_typing___AAbsSendExpr___prop};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAbsSendExpr____prop( self) /*AAbsSendExpr::_prop*/;
}
val_t typing___AAbsSendExpr___return_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1163, LOCATE_typing___AAbsSendExpr___return_type};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___AAbsSendExpr____return_type( self) /*AAbsSendExpr::_return_type*/;
}
void typing___ASuperInitCall___register_super_init_call(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 1171, LOCATE_typing___ASuperInitCall___register_super_init_call};
    static val_t once_value_215 = NIT_NULL; /* Once value for string variable[5]*/
    static val_t once_value_216 = NIT_NULL; /* Once value for string variable[5]*/
      static val_t once_value_217 = NIT_NULL; /* Once value for string variable[8]*/
      static val_t once_value_218 = NIT_NULL; /* Once value for string variable[8]*/
      static val_t once_value_219 = NIT_NULL; /* Once value for string variable[8]*/
      static val_t once_value_220 = NIT_NULL; /* Once value for string variable[8]*/
        static val_t once_value_221 = NIT_NULL; /* Once value for string variable[8]*/
        static val_t once_value_222 = NIT_NULL; /* Once value for string variable[8]*/
		static val_t once_value_224 = NIT_NULL; /* Once value for string variable[12]*/
		static val_t once_value_225 = NIT_NULL; /* Once value for string variable[12]*/
		static val_t once_value_226 = NIT_NULL; /* Once value for string variable[12]*/
  val_t variable[13];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_prod___PNode___parent(variable[0])(variable[0]) /*PNode::parent*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___TypingVisitor___top_block( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::top_block*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] == variable[5]) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4],variable[5])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4], variable[5]) /*Object::==*/)))))));
  /* Ensure var variable[4]: Left 'and' operand*/
  if (UNTAG_Bool(variable[4])) { /* and */
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___TypingVisitor___top_block( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::top_block*/;
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[0] == variable[4]) || ((variable[0] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[0])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[0],variable[4])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[0])(variable[0], variable[4]) /*Object::==*/)))))));
  }
  /* Register variable[4]: Result */
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[5]: Once String constant */
    if (once_value_215 != NIT_NULL) variable[5] = once_value_215;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: Constructor invocation "), TAG_Int(30)) /*new String*/;
      once_value_215 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
    variable[5] =  variable[2] /*property*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[5]: Once String constant */
    if (once_value_216 != NIT_NULL) variable[5] = once_value_216;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString(" must not be in nested block."), TAG_Int(29)) /*new String*/;
      once_value_216 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
  }
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___module( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::module*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_abstractmetamodel___MMLocalProperty___global( variable[2] /*property*/)( variable[2] /*property*/) /*MMLocalProperty::global*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[6])(variable[6]) /*MMGlobalProperty::intro*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_abstractmetamodel___MMLocalProperty___local_class(variable[6])(variable[6]) /*MMLocalProperty::local_class*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_abstractmetamodel___MMLocalClass___global(variable[6])(variable[6]) /*MMLocalClass::global*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_abstractmetamodel___MMModule_____bra(variable[5])(variable[5], variable[6]) /*MMModule::[]*/;
  variable[4] = variable[5];
  /* Register variable[5]: Local variable */
  variable[5] =  NIT_NULL /*null*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___TypingVisitor___explicit_super_init_calls( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::explicit_super_init_calls*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_abstract_collection___Collection___is_empty(variable[6])(variable[6]) /*AbstractArrayRead::is_empty*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
    /* Register variable[6]: Result */
    variable[6] = CALL_typing___TypingVisitor___explicit_super_init_calls( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::explicit_super_init_calls*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_abstract_collection___IndexedCollectionRead___last(variable[6])(variable[6]) /*IndexedCollectionRead::last*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_abstractmetamodel___MMLocalProperty___global(variable[6])(variable[6]) /*MMLocalProperty::global*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_abstractmetamodel___MMGlobalProperty___intro(variable[6])(variable[6]) /*MMGlobalProperty::intro*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_abstractmetamodel___MMLocalProperty___local_class(variable[6])(variable[6]) /*MMLocalProperty::local_class*/;
    variable[5] = variable[6] /*prev_class=*/;
  }
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_abstractmetamodel___MMLocalClass___cshe(variable[7])(variable[7]) /*MMLocalClass::cshe*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_partial_order___PartialOrderElement___reverse_linear_extension(variable[7])(variable[7]) /*PartialOrderElement::reverse_linear_extension*/;
  variable[6] = variable[7];
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___AbsSyntaxVisitor___local_class( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_class*/;
  /* Register variable[7]: Result */
  variable[7] = TAG_Bool(( variable[4] /*cla*/ == variable[7]) || (( variable[4] /*cla*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*cla*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*cla*/,variable[7])):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*cla*/)( variable[4] /*cla*/, variable[7]) /*Object::==*/)))));
  if (UNTAG_Bool(variable[7])) { /*if*/
    CALL_typing___TypingVisitor___explicit_other_init_call__eq( variable[1] /*v*/)( variable[1] /*v*/,  TAG_Bool(true)) /*TypingVisitor::explicit_other_init_call=*/;
  } else { /*if*/
    /* Register variable[7]: Result */
    variable[7] = CALL_abstract_collection___Collection___has( variable[6] /*order*/)( variable[6] /*order*/,  variable[4] /*cla*/) /*AbstractArrayRead::has*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[7])))) { /*if*/
      variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[8]: Once String constant */
      if (once_value_217 != NIT_NULL) variable[8] = once_value_217;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: Constructor of class "), TAG_Int(28)) /*new String*/;
        once_value_217 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      variable[8] =  variable[4] /*cla*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[8]: Once String constant */
      if (once_value_218 != NIT_NULL) variable[8] = once_value_218;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString(" must be one in "), TAG_Int(16)) /*new String*/;
        once_value_218 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      /* Register variable[8]: Once String constant */
      if (once_value_219 != NIT_NULL) variable[8] = once_value_219;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)) /*new String*/;
        once_value_219 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Register variable[8]: Result */
      variable[8] = CALL_string___Collection___join( variable[6] /*order*/)( variable[6] /*order*/, variable[8]) /*Collection::join*/;
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      /* Register variable[8]: Once String constant */
      if (once_value_220 != NIT_NULL) variable[8] = once_value_220;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
        once_value_220 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[7]: Result */
      variable[7] = TAG_Bool(( variable[4] /*cla*/ ==  variable[5] /*prev_class*/) || (( variable[4] /*cla*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*cla*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*cla*/, variable[5] /*prev_class*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*cla*/)( variable[4] /*cla*/,  variable[5] /*prev_class*/) /*Object::==*/)))));
      if (UNTAG_Bool(variable[7])) { /*if*/
        variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[8]: Once String constant */
        if (once_value_221 != NIT_NULL) variable[8] = once_value_221;
        else {
          variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: Only one super constructor invocation of class "), TAG_Int(54)) /*new String*/;
          once_value_221 = variable[8];
        }
        /* Register variable[8]: Result */
        /* Ensure var variable[8]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
        variable[8] =  variable[4] /*cla*/ /* Ensure var: super-string element*/;
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[8]: Once String constant */
        if (once_value_222 != NIT_NULL) variable[8] = once_value_222;
        else {
          variable[8] = NEW_String_string___String___with_native(BOX_NativeString(" is allowed."), TAG_Int(12)) /*new String*/;
          once_value_222 = variable[8];
        }
        /* Register variable[8]: Result */
        /* Ensure var variable[8]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
        /* Register variable[7]: Result */
        variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::error*/;
      } else { /*if*/
        /* Register variable[7]: Local variable */
        /* Register variable[8]: Result */
        variable[8] = TAG_Bool(( variable[5] /*prev_class*/ ==  NIT_NULL /*null*/) || (( variable[5] /*prev_class*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*prev_class*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*prev_class*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*prev_class*/)( variable[5] /*prev_class*/,  NIT_NULL /*null*/) /*Object::==*/)))));
        variable[7] = variable[8];
        /* Register variable[8]: For iterator */
        variable[8] = CALL_abstract_collection___Collection___iterator( variable[6] /*order*/)( variable[6] /*order*/) /*AbstractArrayRead::iterator*/;
        while (true) { /*for*/
          /* Register variable[9]: For 'is_ok' result */
          variable[9] = CALL_abstract_collection___Iterator___is_ok(variable[8])(variable[8]) /*ArrayIterator::is_ok*/;
          if (!UNTAG_Bool(variable[9])) break; /*for*/
          variable[9] = CALL_abstract_collection___Iterator___item(variable[8])(variable[8]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
          /* Register variable[10]: Local variable */
          variable[10] = variable[9];
          /* Register variable[11]: Result */
          variable[11] = TAG_Bool(( variable[10] /*c*/ ==  variable[5] /*prev_class*/) || (( variable[10] /*c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[10] /*c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[10] /*c*/, variable[5] /*prev_class*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[10] /*c*/)( variable[10] /*c*/,  variable[5] /*prev_class*/) /*Object::==*/)))));
          if (UNTAG_Bool(variable[11])) { /*if*/
            variable[7] =  TAG_Bool(true) /*last_is_found=*/;
          } else { /*if*/
            /* Register variable[11]: Result */
            variable[11] = TAG_Bool(( variable[10] /*c*/ ==  variable[4] /*cla*/) || (( variable[10] /*c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[10] /*c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[10] /*c*/, variable[4] /*cla*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[10] /*c*/)( variable[10] /*c*/,  variable[4] /*cla*/) /*Object::==*/)))));
            if (UNTAG_Bool(variable[11])) { /*if*/
              if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool( variable[7] /*last_is_found*/)))) { /*if*/
		variable[11] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
		/* Register variable[12]: Once String constant */
		if (once_value_224 != NIT_NULL) variable[12] = once_value_224;
		else {
		variable[12] = NEW_String_string___String___with_native(BOX_NativeString("Error: Constructor of "), TAG_Int(22)) /*new String*/;
		once_value_224 = variable[12];
		}
		/* Register variable[12]: Result */
		/* Ensure var variable[12]: super-string element*/
		CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[12]) /*AbstractArray::add*/;
		variable[12] =  variable[10] /*c*/ /* Ensure var: super-string element*/;
		CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], CALL_string___Object___to_s(variable[12])(variable[12]) /*Object::to_s*/) /*AbstractArray::add*/;
		/* Register variable[12]: Once String constant */
		if (once_value_225 != NIT_NULL) variable[12] = once_value_225;
		else {
		variable[12] = NEW_String_string___String___with_native(BOX_NativeString(" must be invoked before constructor of "), TAG_Int(39)) /*new String*/;
		once_value_225 = variable[12];
		}
		/* Register variable[12]: Result */
		/* Ensure var variable[12]: super-string element*/
		CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[12]) /*AbstractArray::add*/;
		variable[12] =  variable[5] /*prev_class*/ /* Ensure var: super-string element*/;
		CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], CALL_string___Object___to_s(variable[12])(variable[12]) /*Object::to_s*/) /*AbstractArray::add*/;
		/* Register variable[12]: Once String constant */
		if (once_value_226 != NIT_NULL) variable[12] = once_value_226;
		else {
		variable[12] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
		once_value_226 = variable[12];
		}
		/* Register variable[12]: Result */
		/* Ensure var variable[12]: super-string element*/
		CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[12]) /*AbstractArray::add*/;
		/* Register variable[11]: Result */
		variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
		CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[11]) /*AbsSyntaxVisitor::error*/;
              }
              /* Register variable[11]: Result */
              variable[11] = CALL_typing___TypingVisitor___explicit_super_init_calls( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::explicit_super_init_calls*/;
              CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11],  variable[2] /*property*/) /*AbstractArray::add*/;
              goto break_223;
            }
          }
          continue_223: while(0);
          CALL_abstract_collection___Iterator___next(variable[8])(variable[8]) /*ArrayIterator::next*/;
        }
        break_223: while(0);
      }
    }
  }
  return_label214: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ANewExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1208, LOCATE_typing___ANewExpr___after_typing};
    static val_t once_value_228 = NIT_NULL; /* Once value for string variable[5]*/
    static val_t once_value_229 = NIT_NULL; /* Once value for string variable[5]*/
    static val_t once_value_230; static int once_bool_230; /* Once value for variable[5]*/
      static val_t once_value_231 = NIT_NULL; /* Once value for string variable[5]*/
    static val_t once_value_232 = NIT_NULL; /* Once value for string variable[6]*/
    static val_t once_value_233 = NIT_NULL; /* Once value for string variable[6]*/
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___ANewExpr___n_type(variable[0])(variable[0]) /*ANewExpr::n_type*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___PType___stype(variable[4])(variable[4]) /*PType::stype*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*t*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*t*/)( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label227;
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMType___local_class( variable[3] /*t*/)( variable[3] /*t*/) /*MMType::local_class*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstractmetamodel___MMLocalClass___global(variable[4])(variable[4]) /*MMLocalClass::global*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstractmetamodel___MMGlobalClass___is_abstract(variable[4])(variable[4]) /*MMGlobalClass::is_abstract*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[5]: Once String constant */
    if (once_value_228 != NIT_NULL) variable[5] = once_value_228;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: try to instantiate abstract class "), TAG_Int(41)) /*new String*/;
      once_value_228 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_static_type___MMType___local_class( variable[3] /*t*/)( variable[3] /*t*/) /*MMType::local_class*/;
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[5]: Once String constant */
    if (once_value_229 != NIT_NULL) variable[5] = once_value_229;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
      once_value_229 = variable[5];
    }
    /* Register variable[5]: Result */
    /* Ensure var variable[5]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
    goto return_label227;
  }
  /* Register variable[4]: Local variable */
  /*variable[4] is variable name*/
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___ANewExpr___n_id(variable[0])(variable[0]) /*ANewExpr::n_id*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Once expression result */
    if (once_bool_230) variable[5] = once_value_230;
    else {
      /* Register variable[5]: Once String constant */
      if (once_value_231 != NIT_NULL) variable[5] = once_value_231;
      else {
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString("init"), TAG_Int(4)) /*new String*/;
        once_value_231 = variable[5];
      }
      /* Register variable[5]: Result */
      /* Register variable[5]: Result */
      variable[5] = CALL_symbol___String___to_symbol(variable[5])(variable[5]) /*String::to_symbol*/;
      once_value_230 = variable[5];
      once_bool_230 = true;
    }
    /* Register variable[5]: Result */
    variable[4] = variable[5] /*name=*/;
  } else { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_parser_nodes___ANewExpr___n_id(variable[0])(variable[0]) /*ANewExpr::n_id*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_syntax_base___Token___to_symbol(variable[5])(variable[5]) /*Token::to_symbol*/;
    variable[4] = variable[5] /*name=*/;
  }
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___ANewExpr___n_args(variable[0])(variable[0]) /*ANewExpr::n_args*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_array___Collection___to_a(variable[5])(variable[5]) /*Collection::to_a*/;
  CALL_typing___AAbsSendExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/,  variable[3] /*t*/,  TAG_Bool(false),  TAG_Bool(false),  variable[4] /*name*/, variable[5],  NIT_NULL /*null*/) /*AAbsSendExpr::do_typing*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool((variable[5] ==  NIT_NULL /*null*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    goto return_label227;
  }
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_abstractmetamodel___MMLocalProperty___global(variable[5])(variable[5]) /*MMLocalProperty::global*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[5])(variable[5]) /*MMGlobalProperty::is_init*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
    variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[6]: Once String constant */
    if (once_value_232 != NIT_NULL) variable[6] = once_value_232;
    else {
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
      once_value_232 = variable[6];
    }
    /* Register variable[6]: Result */
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[6]: Once String constant */
    if (once_value_233 != NIT_NULL) variable[6] = once_value_233;
    else {
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString(" is not a constructor."), TAG_Int(22)) /*new String*/;
      once_value_233 = variable[6];
    }
    /* Register variable[6]: Result */
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
    goto return_label227;
  }
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ =  variable[3] /*t*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label227: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ASendExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1247, LOCATE_typing___ASendExpr___after_typing};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_typing___ASendExpr___do_all_typing(variable[0])(variable[0],  variable[1] /*v*/) /*ASendExpr::do_all_typing*/;
  return_label234: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASendExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1238, LOCATE_typing___ASendExpr___name};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 1238);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t typing___ASendExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1241, LOCATE_typing___ASendExpr___raw_arguments};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 1241);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t typing___ASendExpr___closure_defs(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1244, LOCATE_typing___ASendExpr___closure_defs};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  NIT_NULL /*null*/;
  goto return_label235;
  return_label235: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___ASendExpr___do_all_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1252, LOCATE_typing___ASendExpr___do_all_typing};
      static val_t once_value_237 = NIT_NULL; /* Once value for string variable[4]*/
      static val_t once_value_238 = NIT_NULL; /* Once value for string variable[4]*/
        static val_t once_value_239 = NIT_NULL; /* Once value for string variable[4]*/
        static val_t once_value_240 = NIT_NULL; /* Once value for string variable[4]*/
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label236;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___PExpr___is_implicit_self(variable[4])(variable[4]) /*PExpr::is_implicit_self*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___PExpr___is_self(variable[5])(variable[5]) /*PExpr::is_self*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___ASendExpr___name(variable[0])(variable[0]) /*ASendExpr::name*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___ASendExpr___raw_arguments(variable[0])(variable[0]) /*ASendExpr::raw_arguments*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_typing___ASendExpr___closure_defs(variable[0])(variable[0]) /*ASendExpr::closure_defs*/;
  CALL_typing___AAbsSendExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/, variable[3], variable[4], variable[5], variable[6], variable[7], variable[8]) /*AAbsSendExpr::do_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label236;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_abstractmetamodel___MMLocalProperty___global(variable[3])(variable[3]) /*MMLocalProperty::global*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[3])(variable[3]) /*MMGlobalProperty::is_init*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_abstractmetamodel___MMLocalProperty___global(variable[3])(variable[3]) /*MMLocalProperty::global*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[3])(variable[3]) /*MMGlobalProperty::is_init*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
      variable[3] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[4]: Once String constant */
      if (once_value_237 != NIT_NULL) variable[4] = once_value_237;
      else {
        variable[4] = NEW_String_string___String___with_native(BOX_NativeString("Error: try to invoke constructor "), TAG_Int(33)) /*new String*/;
        once_value_237 = variable[4];
      }
      /* Register variable[4]: Result */
      /* Ensure var variable[4]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
      /* Register variable[4]: Result */
      variable[4] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
      /* Ensure var variable[4]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[4]: Once String constant */
      if (once_value_238 != NIT_NULL) variable[4] = once_value_238;
      else {
        variable[4] = NEW_String_string___String___with_native(BOX_NativeString(" in a method."), TAG_Int(13)) /*new String*/;
        once_value_238 = variable[4];
      }
      /* Register variable[4]: Result */
      /* Ensure var variable[4]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
      /* Register variable[3]: Result */
      variable[3] = CALL_string___Object___to_s(variable[3])(variable[3]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[3]: Result */
      variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
      /* Register variable[3]: Result */
      variable[3] = CALL_typing___PExpr___is_self(variable[3])(variable[3]) /*PExpr::is_self*/;
      if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
        variable[3] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[4]: Once String constant */
        if (once_value_239 != NIT_NULL) variable[4] = once_value_239;
        else {
          variable[4] = NEW_String_string___String___with_native(BOX_NativeString("Error: constructor "), TAG_Int(19)) /*new String*/;
          once_value_239 = variable[4];
        }
        /* Register variable[4]: Result */
        /* Ensure var variable[4]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
        /* Register variable[4]: Result */
        variable[4] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
        /* Ensure var variable[4]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[4]: Once String constant */
        if (once_value_240 != NIT_NULL) variable[4] = once_value_240;
        else {
          variable[4] = NEW_String_string___String___with_native(BOX_NativeString(" is not invoken on 'self'."), TAG_Int(26)) /*new String*/;
          once_value_240 = variable[4];
        }
        /* Register variable[4]: Result */
        /* Ensure var variable[4]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3], variable[4]) /*AbstractArray::add*/;
        /* Register variable[3]: Result */
        variable[3] = CALL_string___Object___to_s(variable[3])(variable[3]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::error*/;
      } else { /*if*/
        /* Register variable[3]: Result */
        variable[3] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
        CALL_typing___ASuperInitCall___register_super_init_call(variable[0])(variable[0],  variable[1] /*v*/, variable[3]) /*ASuperInitCall::register_super_init_call*/;
      }
    }
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___AAbsSendExpr___return_type(variable[0])(variable[0]) /*AAbsSendExpr::return_type*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label236: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ASendReassignExpr___do_all_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1277, LOCATE_typing___ASendReassignExpr___do_all_typing};
      static val_t once_value_242 = NIT_NULL; /* Once value for string variable[5]*/
      static val_t once_value_243 = NIT_NULL; /* Once value for string variable[5]*/
        static val_t once_value_244 = NIT_NULL; /* Once value for string variable[5]*/
        static val_t once_value_245 = NIT_NULL; /* Once value for string variable[5]*/
  static val_t once_value_246 = NIT_NULL; /* Once value for string variable[11]*/
  static val_t once_value_247 = NIT_NULL; /* Once value for string variable[11]*/
      static val_t once_value_248 = NIT_NULL; /* Once value for string variable[8]*/
      static val_t once_value_249 = NIT_NULL; /* Once value for string variable[8]*/
        static val_t once_value_250 = NIT_NULL; /* Once value for string variable[8]*/
        static val_t once_value_251 = NIT_NULL; /* Once value for string variable[8]*/
  val_t variable[12];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label241;
  }
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___ASendExpr___raw_arguments(variable[0])(variable[0]) /*ASendExpr::raw_arguments*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___PExpr___is_implicit_self(variable[5])(variable[5]) /*PExpr::is_implicit_self*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___PExpr___is_self(variable[6])(variable[6]) /*PExpr::is_self*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___ASendExpr___name(variable[0])(variable[0]) /*ASendExpr::name*/;
  CALL_typing___AAbsSendExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/, variable[4], variable[5], variable[6], variable[7],  variable[3] /*raw_args*/,  NIT_NULL /*null*/) /*AAbsSendExpr::do_typing*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool((variable[4] ==  NIT_NULL /*null*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label241;
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstractmetamodel___MMLocalProperty___global(variable[4])(variable[4]) /*MMLocalProperty::global*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[4])(variable[4]) /*MMGlobalProperty::is_init*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_abstractmetamodel___MMLocalProperty___global(variable[4])(variable[4]) /*MMLocalProperty::global*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[4])(variable[4]) /*MMGlobalProperty::is_init*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[4])))) { /*if*/
      variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[5]: Once String constant */
      if (once_value_242 != NIT_NULL) variable[5] = once_value_242;
      else {
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: try to invoke constructor "), TAG_Int(33)) /*new String*/;
        once_value_242 = variable[5];
      }
      /* Register variable[5]: Result */
      /* Ensure var variable[5]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
      /* Register variable[5]: Result */
      variable[5] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
      /* Ensure var variable[5]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[5]: Once String constant */
      if (once_value_243 != NIT_NULL) variable[5] = once_value_243;
      else {
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString(" in a method."), TAG_Int(13)) /*new String*/;
        once_value_243 = variable[5];
      }
      /* Register variable[5]: Result */
      /* Ensure var variable[5]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
      /* Register variable[4]: Result */
      variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[4]: Result */
      variable[4] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
      /* Register variable[4]: Result */
      variable[4] = CALL_typing___PExpr___is_self(variable[4])(variable[4]) /*PExpr::is_self*/;
      if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[4])))) { /*if*/
        variable[4] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[5]: Once String constant */
        if (once_value_244 != NIT_NULL) variable[5] = once_value_244;
        else {
          variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Error: constructor "), TAG_Int(19)) /*new String*/;
          once_value_244 = variable[5];
        }
        /* Register variable[5]: Result */
        /* Ensure var variable[5]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
        /* Register variable[5]: Result */
        variable[5] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
        /* Ensure var variable[5]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[5]: Once String constant */
        if (once_value_245 != NIT_NULL) variable[5] = once_value_245;
        else {
          variable[5] = NEW_String_string___String___with_native(BOX_NativeString(" is not invoken on 'self'."), TAG_Int(26)) /*new String*/;
          once_value_245 = variable[5];
        }
        /* Register variable[5]: Result */
        /* Ensure var variable[5]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4], variable[5]) /*AbstractArray::add*/;
        /* Register variable[4]: Result */
        variable[4] = CALL_string___Object___to_s(variable[4])(variable[4]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[4]) /*AbsSyntaxVisitor::error*/;
      }
    }
  }
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___PExpr___stype(variable[6])(variable[6]) /*PExpr::stype*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_static_type___MMLocalProperty___signature_for(variable[5])(variable[5], variable[6]) /*MMLocalProperty::signature_for*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_static_type___MMSignature___return_type(variable[5])(variable[5]) /*MMSignature::return_type*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___PExpr___is_self(variable[5])(variable[5]) /*PExpr::is_self*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_static_type___MMType___not_for_self( variable[4] /*t*/)( variable[4] /*t*/) /*MMType::not_for_self*/;
    variable[4] = variable[5] /*t=*/;
  }
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___AReassignFormExpr___do_rvalue_typing(variable[0])(variable[0],  variable[1] /*v*/,  variable[4] /*t*/) /*AReassignFormExpr::do_rvalue_typing*/;
  variable[5] = variable[6];
  /* Register variable[6]: Result */
  variable[6] = TAG_Bool(( variable[5] /*t2*/ ==  NIT_NULL /*null*/) || (( variable[5] /*t2*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*t2*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*t2*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*t2*/)( variable[5] /*t2*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    goto return_label241;
  }
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[0])(variable[0]) /*AReassignFormExpr::n_value*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___PExpr___stype(variable[6])(variable[6]) /*PExpr::stype*/;
  CALL_syntax_base___AbsSyntaxVisitor___check_conform( variable[1] /*v*/)( variable[1] /*v*/, variable[0],  variable[5] /*t2*/, variable[6]) /*AbsSyntaxVisitor::check_conform*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  ATTR_typing___ASendReassignExpr____read_prop(variable[0]) /*ASendReassignExpr::_read_prop*/ = variable[6];
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___AAbsAbsSendExpr___arguments(variable[0])(variable[0]) /*AAbsAbsSendExpr::arguments*/;
  variable[6] = variable[7];
  /* Register variable[7]: Result */
  variable[7] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[0])(variable[0]) /*AReassignFormExpr::n_value*/;
  CALL_abstract_collection___SimpleCollection___add( variable[3] /*raw_args*/)( variable[3] /*raw_args*/, variable[7]) /*AbstractArray::add*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_syntax_base___PExpr___stype(variable[7])(variable[7]) /*PExpr::stype*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[8]: Result */
  variable[8] = CALL_typing___PExpr___is_implicit_self(variable[8])(variable[8]) /*PExpr::is_implicit_self*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[9]: Result */
  variable[9] = CALL_typing___PExpr___is_self(variable[9])(variable[9]) /*PExpr::is_self*/;
  variable[10] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
  /* Register variable[11]: Once String constant */
  if (once_value_246 != NIT_NULL) variable[11] = once_value_246;
  else {
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
    once_value_246 = variable[11];
  }
  /* Register variable[11]: Result */
  /* Ensure var variable[11]: super-string element*/
  CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
  /* Register variable[11]: Result */
  variable[11] = CALL_typing___ASendExpr___name(variable[0])(variable[0]) /*ASendExpr::name*/;
  /* Ensure var variable[11]: super-string element*/
  CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/) /*AbstractArray::add*/;
  /* Register variable[11]: Once String constant */
  if (once_value_247 != NIT_NULL) variable[11] = once_value_247;
  else {
    variable[11] = NEW_String_string___String___with_native(BOX_NativeString("="), TAG_Int(1)) /*new String*/;
    once_value_247 = variable[11];
  }
  /* Register variable[11]: Result */
  /* Ensure var variable[11]: super-string element*/
  CALL_abstract_collection___SimpleCollection___add(variable[10])(variable[10], variable[11]) /*AbstractArray::add*/;
  /* Register variable[10]: Result */
  variable[10] = CALL_string___Object___to_s(variable[10])(variable[10]) /*Object::to_s*/;
  /* Register variable[10]: Result */
  variable[10] = CALL_symbol___String___to_symbol(variable[10])(variable[10]) /*String::to_symbol*/;
  CALL_typing___AAbsSendExpr___do_typing(variable[0])(variable[0],  variable[1] /*v*/, variable[7], variable[8], variable[9], variable[10],  variable[3] /*raw_args*/,  NIT_NULL /*null*/) /*AAbsSendExpr::do_typing*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[7]: Result */
  variable[7] = TAG_Bool((variable[7] ==  NIT_NULL /*null*/) || ((variable[7] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[7])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[7], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[7])(variable[7],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[7])) { /*if*/
    goto return_label241;
  }
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_abstractmetamodel___MMLocalProperty___global(variable[7])(variable[7]) /*MMLocalProperty::global*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[7])(variable[7]) /*MMGlobalProperty::is_init*/;
  if (UNTAG_Bool(variable[7])) { /*if*/
    /* Register variable[7]: Result */
    variable[7] = CALL_syntax_base___AbsSyntaxVisitor___local_property( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::local_property*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_abstractmetamodel___MMLocalProperty___global(variable[7])(variable[7]) /*MMLocalProperty::global*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_abstractmetamodel___MMGlobalProperty___is_init(variable[7])(variable[7]) /*MMGlobalProperty::is_init*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[7])))) { /*if*/
      variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[8]: Once String constant */
      if (once_value_248 != NIT_NULL) variable[8] = once_value_248;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: try to invoke constructor "), TAG_Int(33)) /*new String*/;
        once_value_248 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      /* Register variable[8]: Result */
      variable[8] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[8]: Once String constant */
      if (once_value_249 != NIT_NULL) variable[8] = once_value_249;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString(" in a method."), TAG_Int(13)) /*new String*/;
        once_value_249 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[7]: Result */
      variable[7] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_typing___PExpr___is_self(variable[7])(variable[7]) /*PExpr::is_self*/;
      if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[7])))) { /*if*/
        variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
        /* Register variable[8]: Once String constant */
        if (once_value_250 != NIT_NULL) variable[8] = once_value_250;
        else {
          variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Error: constructor "), TAG_Int(19)) /*new String*/;
          once_value_250 = variable[8];
        }
        /* Register variable[8]: Result */
        /* Ensure var variable[8]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
        /* Register variable[8]: Result */
        variable[8] = CALL_typing___AAbsSendExpr___prop(variable[0])(variable[0]) /*AAbsSendExpr::prop*/;
        /* Ensure var variable[8]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
        /* Register variable[8]: Once String constant */
        if (once_value_251 != NIT_NULL) variable[8] = once_value_251;
        else {
          variable[8] = NEW_String_string___String___with_native(BOX_NativeString(" is not invoken on 'self'."), TAG_Int(26)) /*new String*/;
          once_value_251 = variable[8];
        }
        /* Register variable[8]: Result */
        /* Ensure var variable[8]: super-string element*/
        CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
        /* Register variable[7]: Result */
        variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::error*/;
      }
    }
  }
  ATTR_typing___AAbsAbsSendExpr____arguments(variable[0]) /*AAbsAbsSendExpr::_arguments*/ =  variable[6] /*old_args*/;
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label241: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ASendReassignExpr___read_prop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1276, LOCATE_typing___ASendReassignExpr___read_prop};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___ASendReassignExpr____read_prop( self) /*ASendReassignExpr::_read_prop*/;
}
val_t typing___ABinopExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1317, LOCATE_typing___ABinopExpr___raw_arguments};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[2] = NEW_Array_array___Array___with_capacity(TAG_Int(1)) /*new Array[PExpr]*/ /* Ensure var: Literal array*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
  CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[3]) /*AbstractArray::add*/;
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label252;
  return_label252: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___AEqExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1321, LOCATE_typing___AEqExpr___after_typing};
    static val_t once_value_254 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_SUPER_typing___AEqExpr___after_typing(variable[0])(variable[0], variable[1]) /*super AEqExpr::after_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___is_typed(variable[0])(variable[0]) /*PExpr::is_typed*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label253;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3]==NIT_NULL) || VAL_ISA(variable[3], COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
  /* Ensure var variable[3]: Left 'and' operand*/
  if (UNTAG_Bool(variable[3])) { /* and */
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_static_type___MMType___is_nullable(variable[3])(variable[3]) /*MMType::is_nullable*/;
    variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3]));
  }
  /* Register variable[3]: Result */
  /* Ensure var variable[3]: Left 'or' operand*/
  if (!UNTAG_Bool(variable[3])) { /* or */
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool((variable[3]==NIT_NULL) || VAL_ISA(variable[3], COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
  }
  /* Register variable[3]: Result */
  /* Ensure var variable[3]: Left 'and' operand*/
  if (UNTAG_Bool(variable[3])) { /* and */
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_static_type___MMType___is_nullable(variable[3])(variable[3]) /*MMType::is_nullable*/;
    variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3]));
  }
  /* Register variable[3]: Result */
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Once String constant */
    if (once_value_254 != NIT_NULL) variable[3] = once_value_254;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString("Warning: comparaison between null and a non nullable value."), TAG_Int(59)) /*new String*/;
      once_value_254 = variable[3];
    }
    /* Register variable[3]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::warning*/;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3]==NIT_NULL) || VAL_ISA(variable[3], COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
    CALL_typing___AEqExpr___try_to_isa(variable[0])(variable[0],  variable[1] /*v*/, variable[3]) /*AEqExpr::try_to_isa*/;
  } else { /*if*/
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool((variable[3]==NIT_NULL) || VAL_ISA(variable[3], COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
    if (UNTAG_Bool(variable[3])) { /*if*/
      /* Register variable[3]: Result */
      variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
      CALL_typing___AEqExpr___try_to_isa(variable[0])(variable[0],  variable[1] /*v*/, variable[3]) /*AEqExpr::try_to_isa*/;
    }
  }
  return_label253: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___AEqExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1320, LOCATE_typing___AEqExpr___name};
  static val_t once_value_256; static int once_bool_256; /* Once value for variable[2]*/
    static val_t once_value_257 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_256) variable[2] = once_value_256;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_257 != NIT_NULL) variable[2] = once_value_257;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("=="), TAG_Int(2)) /*new String*/;
      once_value_257 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_256 = variable[2];
    once_bool_256 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label255;
  return_label255: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___AEqExpr___try_to_isa(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 1337, LOCATE_typing___AEqExpr___try_to_isa};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___PExpr___its_variable( variable[2] /*n*/)( variable[2] /*n*/) /*PExpr::its_variable*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*variable*/ ==  NIT_NULL /*null*/) || (( variable[4] /*variable*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*variable*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*variable*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*variable*/)( variable[4] /*variable*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_syntax_base___PExpr___stype( variable[2] /*n*/)( variable[2] /*n*/) /*PExpr::stype*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_static_type___MMType___as_notnull(variable[6])(variable[6]) /*MMType::as_notnull*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_control_flow___VariableContext___sub_with(variable[5])(variable[5], variable[0],  variable[4] /*variable*/, variable[6]) /*VariableContext::sub_with*/;
    ATTR_typing___PExpr____if_false_variable_ctx(variable[0]) /*PExpr::_if_false_variable_ctx*/ = variable[5];
  }
  return_label258: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ANeExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1347, LOCATE_typing___ANeExpr___after_typing};
    static val_t once_value_260 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_SUPER_typing___ANeExpr___after_typing(variable[0])(variable[0], variable[1]) /*super ANeExpr::after_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___is_typed(variable[0])(variable[0]) /*PExpr::is_typed*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label259;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3]==NIT_NULL) || VAL_ISA(variable[3], COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
  /* Ensure var variable[3]: Left 'and' operand*/
  if (UNTAG_Bool(variable[3])) { /* and */
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_static_type___MMType___is_nullable(variable[3])(variable[3]) /*MMType::is_nullable*/;
    variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3]));
  }
  /* Register variable[3]: Result */
  /* Ensure var variable[3]: Left 'or' operand*/
  if (!UNTAG_Bool(variable[3])) { /* or */
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool((variable[3]==NIT_NULL) || VAL_ISA(variable[3], COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
  }
  /* Register variable[3]: Result */
  /* Ensure var variable[3]: Left 'and' operand*/
  if (UNTAG_Bool(variable[3])) { /* and */
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_static_type___MMType___is_nullable(variable[3])(variable[3]) /*MMType::is_nullable*/;
    variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3]));
  }
  /* Register variable[3]: Result */
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Once String constant */
    if (once_value_260 != NIT_NULL) variable[3] = once_value_260;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString("Warning: comparaison between null and a non nullable value."), TAG_Int(59)) /*new String*/;
      once_value_260 = variable[3];
    }
    /* Register variable[3]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::warning*/;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3]==NIT_NULL) || VAL_ISA(variable[3], COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
    CALL_typing___ANeExpr___try_to_isa(variable[0])(variable[0],  variable[1] /*v*/, variable[3]) /*ANeExpr::try_to_isa*/;
  } else { /*if*/
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ABinopExpr___n_expr2(variable[0])(variable[0]) /*ABinopExpr::n_expr2*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool((variable[3]==NIT_NULL) || VAL_ISA(variable[3], COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
    if (UNTAG_Bool(variable[3])) { /*if*/
      /* Register variable[3]: Result */
      variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
      CALL_typing___ANeExpr___try_to_isa(variable[0])(variable[0],  variable[1] /*v*/, variable[3]) /*ANeExpr::try_to_isa*/;
    }
  }
  return_label259: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ANeExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1346, LOCATE_typing___ANeExpr___name};
  static val_t once_value_262; static int once_bool_262; /* Once value for variable[2]*/
    static val_t once_value_263 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_262) variable[2] = once_value_262;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_263 != NIT_NULL) variable[2] = once_value_263;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("!="), TAG_Int(2)) /*new String*/;
      once_value_263 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_262 = variable[2];
    once_bool_262 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label261;
  return_label261: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___ANeExpr___try_to_isa(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 1363, LOCATE_typing___ANeExpr___try_to_isa};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_typing___PExpr___its_variable( variable[2] /*n*/)( variable[2] /*n*/) /*PExpr::its_variable*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*variable*/ ==  NIT_NULL /*null*/) || (( variable[4] /*variable*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*variable*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*variable*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*variable*/)( variable[4] /*variable*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Result */
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_syntax_base___PExpr___stype( variable[2] /*n*/)( variable[2] /*n*/) /*PExpr::stype*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_static_type___MMType___as_notnull(variable[6])(variable[6]) /*MMType::as_notnull*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_control_flow___VariableContext___sub_with(variable[5])(variable[5], variable[0],  variable[4] /*variable*/, variable[6]) /*VariableContext::sub_with*/;
    ATTR_typing___PExpr____if_true_variable_ctx(variable[0]) /*PExpr::_if_true_variable_ctx*/ = variable[5];
  }
  return_label264: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ALtExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1372, LOCATE_typing___ALtExpr___name};
  static val_t once_value_266; static int once_bool_266; /* Once value for variable[2]*/
    static val_t once_value_267 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_266) variable[2] = once_value_266;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_267 != NIT_NULL) variable[2] = once_value_267;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("<"), TAG_Int(1)) /*new String*/;
      once_value_267 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_266 = variable[2];
    once_bool_266 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label265;
  return_label265: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ALeExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1375, LOCATE_typing___ALeExpr___name};
  static val_t once_value_269; static int once_bool_269; /* Once value for variable[2]*/
    static val_t once_value_270 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_269) variable[2] = once_value_269;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_270 != NIT_NULL) variable[2] = once_value_270;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("<="), TAG_Int(2)) /*new String*/;
      once_value_270 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_269 = variable[2];
    once_bool_269 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label268;
  return_label268: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AGtExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1378, LOCATE_typing___AGtExpr___name};
  static val_t once_value_272; static int once_bool_272; /* Once value for variable[2]*/
    static val_t once_value_273 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_272) variable[2] = once_value_272;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_273 != NIT_NULL) variable[2] = once_value_273;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString(">"), TAG_Int(1)) /*new String*/;
      once_value_273 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_272 = variable[2];
    once_bool_272 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label271;
  return_label271: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AGeExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1381, LOCATE_typing___AGeExpr___name};
  static val_t once_value_275; static int once_bool_275; /* Once value for variable[2]*/
    static val_t once_value_276 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_275) variable[2] = once_value_275;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_276 != NIT_NULL) variable[2] = once_value_276;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString(">="), TAG_Int(2)) /*new String*/;
      once_value_276 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_275 = variable[2];
    once_bool_275 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label274;
  return_label274: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___APlusExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1384, LOCATE_typing___APlusExpr___name};
  static val_t once_value_278; static int once_bool_278; /* Once value for variable[2]*/
    static val_t once_value_279 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_278) variable[2] = once_value_278;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_279 != NIT_NULL) variable[2] = once_value_279;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("+"), TAG_Int(1)) /*new String*/;
      once_value_279 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_278 = variable[2];
    once_bool_278 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label277;
  return_label277: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AMinusExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1387, LOCATE_typing___AMinusExpr___name};
  static val_t once_value_281; static int once_bool_281; /* Once value for variable[2]*/
    static val_t once_value_282 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_281) variable[2] = once_value_281;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_282 != NIT_NULL) variable[2] = once_value_282;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("-"), TAG_Int(1)) /*new String*/;
      once_value_282 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_281 = variable[2];
    once_bool_281 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label280;
  return_label280: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AStarshipExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1390, LOCATE_typing___AStarshipExpr___name};
  static val_t once_value_284; static int once_bool_284; /* Once value for variable[2]*/
    static val_t once_value_285 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_284) variable[2] = once_value_284;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_285 != NIT_NULL) variable[2] = once_value_285;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("<=>"), TAG_Int(3)) /*new String*/;
      once_value_285 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_284 = variable[2];
    once_bool_284 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label283;
  return_label283: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AStarExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1393, LOCATE_typing___AStarExpr___name};
  static val_t once_value_287; static int once_bool_287; /* Once value for variable[2]*/
    static val_t once_value_288 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_287) variable[2] = once_value_287;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_288 != NIT_NULL) variable[2] = once_value_288;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("*"), TAG_Int(1)) /*new String*/;
      once_value_288 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_287 = variable[2];
    once_bool_287 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label286;
  return_label286: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ASlashExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1396, LOCATE_typing___ASlashExpr___name};
  static val_t once_value_290; static int once_bool_290; /* Once value for variable[2]*/
    static val_t once_value_291 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_290) variable[2] = once_value_290;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_291 != NIT_NULL) variable[2] = once_value_291;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("/"), TAG_Int(1)) /*new String*/;
      once_value_291 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_290 = variable[2];
    once_bool_290 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label289;
  return_label289: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___APercentExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1399, LOCATE_typing___APercentExpr___name};
  static val_t once_value_293; static int once_bool_293; /* Once value for variable[2]*/
    static val_t once_value_294 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_293) variable[2] = once_value_293;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_294 != NIT_NULL) variable[2] = once_value_294;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("%"), TAG_Int(1)) /*new String*/;
      once_value_294 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_293 = variable[2];
    once_bool_293 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label292;
  return_label292: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AUminusExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1403, LOCATE_typing___AUminusExpr___name};
  static val_t once_value_296; static int once_bool_296; /* Once value for variable[2]*/
    static val_t once_value_297 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_296) variable[2] = once_value_296;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_297 != NIT_NULL) variable[2] = once_value_297;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("unary -"), TAG_Int(7)) /*new String*/;
      once_value_297 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_296 = variable[2];
    once_bool_296 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label295;
  return_label295: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AUminusExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1404, LOCATE_typing___AUminusExpr___raw_arguments};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  NIT_NULL /*null*/;
  goto return_label298;
  return_label298: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___ACallFormExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1408, LOCATE_typing___ACallFormExpr___after_typing};
          static val_t once_value_300 = NIT_NULL; /* Once value for string variable[6]*/
          static val_t once_value_301 = NIT_NULL; /* Once value for string variable[6]*/
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  /* Ensure var variable[3]: Left 'and' operand*/
  if (UNTAG_Bool(variable[3])) { /* and */
    /* Register variable[3]: Result */
    variable[3] = CALL_parser_nodes___ASendExpr___n_expr(variable[0])(variable[0]) /*ASendExpr::n_expr*/;
    /* Register variable[3]: Result */
    variable[3] = CALL_typing___PExpr___is_implicit_self(variable[3])(variable[3]) /*PExpr::is_implicit_self*/;
  }
  /* Register variable[3]: Result */
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Local variable */
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___ACallFormExpr___n_id(variable[0])(variable[0]) /*ACallFormExpr::n_id*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_syntax_base___Token___to_symbol(variable[4])(variable[4]) /*Token::to_symbol*/;
    variable[3] = variable[4];
    /* Register variable[4]: Local variable */
    /* Register variable[5]: Result */
    variable[5] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_control_flow___VariableContext_____bra(variable[5])(variable[5],  variable[3] /*name*/) /*VariableContext::[]*/;
    variable[4] = variable[5];
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*variable*/ ==  NIT_NULL /*null*/) || (( variable[4] /*variable*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*variable*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*variable*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*variable*/)( variable[4] /*variable*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      /* Register variable[5]: Result */
      variable[5] = TAG_Bool(( variable[4] /*variable*/==NIT_NULL) || VAL_ISA( variable[4] /*variable*/, COLOR_ClosureVariable, ID_ClosureVariable)) /*cast ClosureVariable*/;
      if (UNTAG_Bool(variable[5])) { /*if*/
        /* Register variable[5]: Local variable */
        /* Register variable[6]: Result */
        variable[6] = CALL_parser_nodes___ACallFormExpr___n_id(variable[0])(variable[0]) /*ACallFormExpr::n_id*/;
        /* Register variable[7]: Result */
        variable[7] = CALL_parser_nodes___ACallFormExpr___n_args(variable[0])(variable[0]) /*ACallFormExpr::n_args*/;
        /* Register variable[8]: Result */
        variable[8] = CALL_parser_nodes___ASendExpr___n_closure_defs(variable[0])(variable[0]) /*ASendExpr::n_closure_defs*/;
        /* Register variable[6]: Result */
        variable[6] = NEW_AClosureCallExpr_parser_prod___AClosureCallExpr___init_aclosurecallexpr(variable[6], variable[7], variable[8]) /*new AClosureCallExpr*/;
        variable[5] = variable[6];
        CALL_parser_prod___PNode___replace_with(variable[0])(variable[0],  variable[5] /*n*/) /*Prod::replace_with*/;
        CALL_syntax_base___AClosureCallExpr___variable__eq( variable[5] /*n*/)( variable[5] /*n*/,  variable[4] /*variable*/) /*AClosureCallExpr::variable=*/;
        CALL_typing___PNode___after_typing( variable[5] /*n*/)( variable[5] /*n*/,  variable[1] /*v*/) /*AClosureCallExpr::after_typing*/;
        goto return_label299;
      } else { /*if*/
        /* Register variable[5]: Result */
        variable[5] = CALL_parser_nodes___ACallFormExpr___n_args(variable[0])(variable[0]) /*ACallFormExpr::n_args*/;
        /* Register variable[5]: Result */
        variable[5] = CALL_abstract_collection___Collection___is_empty(variable[5])(variable[5]) /*List::is_empty*/;
        if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
          variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
          /* Register variable[6]: Once String constant */
          if (once_value_300 != NIT_NULL) variable[6] = once_value_300;
          else {
            variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
            once_value_300 = variable[6];
          }
          /* Register variable[6]: Result */
          /* Ensure var variable[6]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
          variable[6] =  variable[3] /*name*/ /* Ensure var: super-string element*/;
          CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/) /*AbstractArray::add*/;
          /* Register variable[6]: Once String constant */
          if (once_value_301 != NIT_NULL) variable[6] = once_value_301;
          else {
            variable[6] = NEW_String_string___String___with_native(BOX_NativeString(" is variable, not a function."), TAG_Int(29)) /*new String*/;
            once_value_301 = variable[6];
          }
          /* Register variable[6]: Result */
          /* Ensure var variable[6]: super-string element*/
          CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
          /* Register variable[5]: Result */
          variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
          CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
          goto return_label299;
        }
        /* Register variable[5]: Local variable */
        /* Register variable[6]: Result */
        variable[6] = CALL_typing___ACallFormExpr___variable_create(variable[0])(variable[0],  variable[4] /*variable*/) /*ACallFormExpr::variable_create*/;
        variable[5] = variable[6];
        CALL_syntax_base___AVarFormExpr___variable__eq( variable[5] /*vform*/)( variable[5] /*vform*/,  variable[4] /*variable*/) /*AVarFormExpr::variable=*/;
        CALL_parser_prod___PNode___replace_with(variable[0])(variable[0],  variable[5] /*vform*/) /*Prod::replace_with*/;
        CALL_typing___PNode___after_typing( variable[5] /*vform*/)( variable[5] /*vform*/,  variable[1] /*v*/) /*PNode::after_typing*/;
        goto return_label299;
      }
    }
  }
  CALL_SUPER_typing___ACallFormExpr___after_typing(variable[0])(variable[0], variable[1]) /*super ACallFormExpr::after_typing*/;
  return_label299: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___ACallFormExpr___closure_defs(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1437, LOCATE_typing___ACallFormExpr___closure_defs};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___ASendExpr___n_closure_defs(variable[0])(variable[0]) /*ASendExpr::n_closure_defs*/;
  /* Register variable[2]: Result */
  variable[2] = TAG_Bool((variable[2] ==  NIT_NULL /*null*/) || ((variable[2] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[2])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[2], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[2])(variable[2],  NIT_NULL /*null*/) /*Object::==*/)))));
  /* Ensure var variable[2]: Left 'or' operand*/
  if (!UNTAG_Bool(variable[2])) { /* or */
    /* Register variable[2]: Result */
    variable[2] = CALL_parser_nodes___ASendExpr___n_closure_defs(variable[0])(variable[0]) /*ASendExpr::n_closure_defs*/;
    /* Register variable[2]: Result */
    variable[2] = CALL_abstract_collection___Collection___is_empty(variable[2])(variable[2]) /*List::is_empty*/;
  }
  /* Register variable[2]: Result */
  if (UNTAG_Bool(variable[2])) { /*if*/
    variable[1] =  NIT_NULL /*null*/;
    goto return_label302;
  } else { /*if*/
    /* Register variable[2]: Result */
    variable[2] = CALL_parser_nodes___ASendExpr___n_closure_defs(variable[0])(variable[0]) /*ASendExpr::n_closure_defs*/;
    /* Register variable[2]: Result */
    variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
    variable[1] = variable[2];
    goto return_label302;
  }
  return_label302: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallFormExpr___variable_create(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1446, LOCATE_typing___ACallFormExpr___variable_create};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 1446);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t typing___ACallExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1456, LOCATE_typing___ACallExpr___name};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_id(variable[0])(variable[0]) /*ACallFormExpr::n_id*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_syntax_base___Token___to_symbol(variable[2])(variable[2]) /*Token::to_symbol*/;
  variable[1] = variable[2];
  goto return_label303;
  return_label303: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1457, LOCATE_typing___ACallExpr___raw_arguments};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_args(variable[0])(variable[0]) /*ACallFormExpr::n_args*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label304;
  return_label304: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallExpr___variable_create(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1451, LOCATE_typing___ACallExpr___variable_create};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ACallFormExpr___n_id(variable[0])(variable[0]) /*ACallFormExpr::n_id*/;
  /* Register variable[3]: Result */
  variable[3] = NEW_AVarExpr_parser_prod___AVarExpr___init_avarexpr(variable[3]) /*new AVarExpr*/;
  variable[2] = variable[3];
  goto return_label305;
  return_label305: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___ACallAssignExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1466, LOCATE_typing___ACallAssignExpr___name};
  static val_t once_value_307 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_id(variable[0])(variable[0]) /*ACallFormExpr::n_id*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_lexer___Token___text(variable[2])(variable[2]) /*Token::text*/;
  /* Register variable[3]: Once String constant */
  if (once_value_307 != NIT_NULL) variable[3] = once_value_307;
  else {
    variable[3] = NEW_String_string___String___with_native(BOX_NativeString("="), TAG_Int(1)) /*new String*/;
    once_value_307 = variable[3];
  }
  /* Register variable[3]: Result */
  /* Register variable[2]: Result */
  variable[2] = CALL_string___String_____plus(variable[2])(variable[2], variable[3]) /*String::+*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
  variable[1] = variable[2];
  goto return_label306;
  return_label306: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallAssignExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1467, LOCATE_typing___ACallAssignExpr___raw_arguments};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Local variable */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ACallFormExpr___n_args(variable[0])(variable[0]) /*ACallFormExpr::n_args*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_array___Collection___to_a(variable[3])(variable[3]) /*Collection::to_a*/;
  variable[2] = variable[3];
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[0])(variable[0]) /*AAssignFormExpr::n_value*/;
  CALL_abstract_collection___SimpleCollection___add( variable[2] /*res*/)( variable[2] /*res*/, variable[3]) /*AbstractArray::add*/;
  variable[1] =  variable[2] /*res*/;
  goto return_label308;
  return_label308: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallAssignExpr___variable_create(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1461, LOCATE_typing___ACallAssignExpr___variable_create};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ACallFormExpr___n_id(variable[0])(variable[0]) /*ACallFormExpr::n_id*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAssignFormExpr___n_assign(variable[0])(variable[0]) /*AAssignFormExpr::n_assign*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[0])(variable[0]) /*AAssignFormExpr::n_value*/;
  /* Register variable[3]: Result */
  variable[3] = NEW_AVarAssignExpr_parser_prod___AVarAssignExpr___init_avarassignexpr(variable[3], variable[4], variable[5]) /*new AVarAssignExpr*/;
  variable[2] = variable[3];
  goto return_label309;
  return_label309: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___ACallReassignExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1481, LOCATE_typing___ACallReassignExpr___name};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_id(variable[0])(variable[0]) /*ACallFormExpr::n_id*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_syntax_base___Token___to_symbol(variable[2])(variable[2]) /*Token::to_symbol*/;
  variable[1] = variable[2];
  goto return_label310;
  return_label310: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallReassignExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1482, LOCATE_typing___ACallReassignExpr___raw_arguments};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___ACallFormExpr___n_args(variable[0])(variable[0]) /*ACallFormExpr::n_args*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label311;
  return_label311: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ACallReassignExpr___variable_create(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1476, LOCATE_typing___ACallReassignExpr___variable_create};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ACallFormExpr___n_id(variable[0])(variable[0]) /*ACallFormExpr::n_id*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AReassignFormExpr___n_assign_op(variable[0])(variable[0]) /*AReassignFormExpr::n_assign_op*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_parser_nodes___AReassignFormExpr___n_value(variable[0])(variable[0]) /*AReassignFormExpr::n_value*/;
  /* Register variable[3]: Result */
  variable[3] = NEW_AVarReassignExpr_parser_prod___AVarReassignExpr___init_avarreassignexpr(variable[3], variable[4], variable[5]) /*new AVarReassignExpr*/;
  variable[2] = variable[3];
  goto return_label312;
  return_label312: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t typing___ABraExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1486, LOCATE_typing___ABraExpr___name};
  static val_t once_value_314; static int once_bool_314; /* Once value for variable[2]*/
    static val_t once_value_315 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_314) variable[2] = once_value_314;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_315 != NIT_NULL) variable[2] = once_value_315;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("[]"), TAG_Int(2)) /*new String*/;
      once_value_315 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_314 = variable[2];
    once_bool_314 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label313;
  return_label313: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1487, LOCATE_typing___ABraExpr___raw_arguments};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___ABraFormExpr___n_args(variable[0])(variable[0]) /*ABraFormExpr::n_args*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label316;
  return_label316: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraAssignExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1491, LOCATE_typing___ABraAssignExpr___name};
  static val_t once_value_318; static int once_bool_318; /* Once value for variable[2]*/
    static val_t once_value_319 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_318) variable[2] = once_value_318;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_319 != NIT_NULL) variable[2] = once_value_319;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("[]="), TAG_Int(3)) /*new String*/;
      once_value_319 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_318 = variable[2];
    once_bool_318 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label317;
  return_label317: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraAssignExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1492, LOCATE_typing___ABraAssignExpr___raw_arguments};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Local variable */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___ABraFormExpr___n_args(variable[0])(variable[0]) /*ABraFormExpr::n_args*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_array___Collection___to_a(variable[3])(variable[3]) /*Collection::to_a*/;
  variable[2] = variable[3];
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAssignFormExpr___n_value(variable[0])(variable[0]) /*AAssignFormExpr::n_value*/;
  CALL_abstract_collection___SimpleCollection___add( variable[2] /*res*/)( variable[2] /*res*/, variable[3]) /*AbstractArray::add*/;
  variable[1] =  variable[2] /*res*/;
  goto return_label320;
  return_label320: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraReassignExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1501, LOCATE_typing___ABraReassignExpr___name};
  static val_t once_value_322; static int once_bool_322; /* Once value for variable[2]*/
    static val_t once_value_323 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_322) variable[2] = once_value_322;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_323 != NIT_NULL) variable[2] = once_value_323;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("[]"), TAG_Int(2)) /*new String*/;
      once_value_323 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_322 = variable[2];
    once_bool_322 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label321;
  return_label321: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___ABraReassignExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1502, LOCATE_typing___ABraReassignExpr___raw_arguments};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___ABraFormExpr___n_args(variable[0])(variable[0]) /*ABraFormExpr::n_args*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label324;
  return_label324: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AInitExpr___name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1506, LOCATE_typing___AInitExpr___name};
  static val_t once_value_326; static int once_bool_326; /* Once value for variable[2]*/
    static val_t once_value_327 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once expression result */
  if (once_bool_326) variable[2] = once_value_326;
  else {
    /* Register variable[2]: Once String constant */
    if (once_value_327 != NIT_NULL) variable[2] = once_value_327;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("init"), TAG_Int(4)) /*new String*/;
      once_value_327 = variable[2];
    }
    /* Register variable[2]: Result */
    /* Register variable[2]: Result */
    variable[2] = CALL_symbol___String___to_symbol(variable[2])(variable[2]) /*String::to_symbol*/;
    once_value_326 = variable[2];
    once_bool_326 = true;
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label325;
  return_label325: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t typing___AInitExpr___raw_arguments(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1507, LOCATE_typing___AInitExpr___raw_arguments};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_parser_nodes___AInitExpr___n_args(variable[0])(variable[0]) /*AInitExpr::n_args*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_array___Collection___to_a(variable[2])(variable[2]) /*Collection::to_a*/;
  variable[1] = variable[2];
  goto return_label328;
  return_label328: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void typing___AClosureCallExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1512, LOCATE_typing___AClosureCallExpr___after_typing};
  val_t variable[8];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AClosureCallExpr___variable(variable[0])(variable[0]) /*AClosureCallExpr::variable*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___ClosureVariable___closure( variable[3] /*va*/)( variable[3] /*va*/) /*ClosureVariable::closure*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMClosure___is_break(variable[4])(variable[4]) /*MMClosure::is_break*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    CALL_control_flow___VariableContext___unreash__eq(variable[4])(variable[4],  TAG_Bool(true)) /*VariableContext::unreash=*/;
  }
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___ClosureVariable___closure( variable[3] /*va*/)( variable[3] /*va*/) /*ClosureVariable::closure*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_static_type___MMClosure___signature(variable[5])(variable[5]) /*MMClosure::signature*/;
  variable[4] = variable[5];
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AClosureCallExpr___n_id(variable[0])(variable[0]) /*AClosureCallExpr::n_id*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___Token___to_symbol(variable[6])(variable[6]) /*Token::to_symbol*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_parser_nodes___AClosureCallExpr___n_args(variable[0])(variable[0]) /*AClosureCallExpr::n_args*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_array___Collection___to_a(variable[7])(variable[7]) /*Collection::to_a*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___AAbsAbsSendExpr___process_signature(variable[0])(variable[0],  variable[1] /*v*/,  variable[4] /*sig*/, variable[6], variable[7]) /*AAbsAbsSendExpr::process_signature*/;
  variable[5] = variable[6];
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AClosureCallExpr___n_closure_defs(variable[0])(variable[0]) /*AClosureCallExpr::n_closure_defs*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_abstract_collection___Collection___is_empty(variable[6])(variable[6]) /*List::is_empty*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
    /* Register variable[6]: Result */
    variable[6] = CALL_parser_nodes___AClosureCallExpr___n_id(variable[0])(variable[0]) /*AClosureCallExpr::n_id*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_syntax_base___Token___to_symbol(variable[6])(variable[6]) /*Token::to_symbol*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_parser_nodes___AClosureCallExpr___n_closure_defs(variable[0])(variable[0]) /*AClosureCallExpr::n_closure_defs*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_array___Collection___to_a(variable[7])(variable[7]) /*Collection::to_a*/;
    CALL_typing___AAbsAbsSendExpr___process_closures(variable[0])(variable[0],  variable[1] /*v*/,  variable[4] /*sig*/, variable[6], variable[7]) /*AAbsAbsSendExpr::process_closures*/;
  }
  /* Register variable[6]: Result */
  variable[6] = TAG_Bool(( variable[5] /*args*/ ==  NIT_NULL /*null*/) || (( variable[5] /*args*/ != NIT_NULL) && UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*args*/)( variable[5] /*args*/,  NIT_NULL /*null*/) /*AbstractArrayRead::==*/)));
  if (UNTAG_Bool(variable[6])) { /*if*/
    goto return_label329;
  }
  ATTR_typing___AAbsAbsSendExpr____prop_signature(variable[0]) /*AAbsAbsSendExpr::_prop_signature*/ =  variable[4] /*sig*/;
  ATTR_typing___AAbsAbsSendExpr____arguments(variable[0]) /*AAbsAbsSendExpr::_arguments*/ =  variable[5] /*args*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_static_type___MMSignature___return_type( variable[4] /*sig*/)( variable[4] /*sig*/) /*MMSignature::return_type*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[6];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label329: while(false);
  tracehead = trace.prev;
  return;
}
void typing___PClosureDef___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1534, LOCATE_typing___PClosureDef___accept_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___PClosureDef____accept_typing2(variable[0]) /*PClosureDef::_accept_typing2*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    CALL_SUPER_typing___PClosureDef___accept_typing(variable[0])(variable[0], variable[1]) /*super PClosureDef::accept_typing*/;
  }
  return_label330: while(false);
  tracehead = trace.prev;
  return;
}
val_t typing___PClosureDef___escapable(val_t  self) {
  struct trace_t trace = {NULL, NULL, 1530, LOCATE_typing___PClosureDef___escapable};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  tracehead = trace.prev;
  return ATTR_typing___PClosureDef____escapable( self) /*PClosureDef::_escapable*/;
}
void typing___PClosureDef___accept_typing2(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 1540, LOCATE_typing___PClosureDef___accept_typing2};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_typing, 1540);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void typing___AClosureDef___accept_typing2(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 1544, LOCATE_typing___AClosureDef___accept_typing2};
    static val_t once_value_332 = NIT_NULL; /* Once value for string variable[6]*/
    static val_t once_value_333 = NIT_NULL; /* Once value for string variable[6]*/
    static val_t once_value_334 = NIT_NULL; /* Once value for string variable[6]*/
      static val_t once_value_336 = NIT_NULL; /* Once value for string variable[7]*/
        static val_t once_value_337 = NIT_NULL; /* Once value for string variable[7]*/
  val_t variable[12];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  ATTR_typing___PClosureDef____escapable(variable[0]) /*PClosureDef::_escapable*/ =  variable[2] /*esc*/;
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_escape___EscapableClosure___closure( variable[2] /*esc*/)( variable[2] /*esc*/) /*EscapableClosure::closure*/;
  /* Register variable[5]: Result */
  variable[5] = CALL_static_type___MMClosure___signature(variable[5])(variable[5]) /*MMClosure::signature*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = CALL_static_type___MMSignature___arity( variable[4] /*sig*/)( variable[4] /*sig*/) /*MMSignature::arity*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_parser_nodes___AClosureDef___n_id(variable[0])(variable[0]) /*AClosureDef::n_id*/;
  /* Register variable[6]: Result */
  variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*List::length*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool((variable[5])!=(variable[6]));
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[6]: Once String constant */
    if (once_value_332 != NIT_NULL) variable[6] = once_value_332;
    else {
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Error: "), TAG_Int(7)) /*new String*/;
      once_value_332 = variable[6];
    }
    /* Register variable[6]: Result */
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_static_type___MMSignature___arity( variable[4] /*sig*/)( variable[4] /*sig*/) /*MMSignature::arity*/;
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[6]: Once String constant */
    if (once_value_333 != NIT_NULL) variable[6] = once_value_333;
    else {
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString(" automatic variable names expected, "), TAG_Int(36)) /*new String*/;
      once_value_333 = variable[6];
    }
    /* Register variable[6]: Result */
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_parser_nodes___AClosureDef___n_id(variable[0])(variable[0]) /*AClosureDef::n_id*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*List::length*/;
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[6]: Once String constant */
    if (once_value_334 != NIT_NULL) variable[6] = once_value_334;
    else {
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString(" found."), TAG_Int(7)) /*new String*/;
      once_value_334 = variable[6];
    }
    /* Register variable[6]: Result */
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
    goto return_label331;
  }
  /* Register variable[5]: Result */
  variable[5] = CALL_escape___EscapableClosure___closure( variable[2] /*esc*/)( variable[2] /*esc*/) /*EscapableClosure::closure*/;
  CALL_syntax_base___PClosureDef___closure__eq(variable[0])(variable[0], variable[5]) /*PClosureDef::closure=*/;
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  variable[5] = variable[6];
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___TypingVisitor___base_variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::base_variable_ctx*/;
  variable[6] = variable[7];
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[7]) /*TypingVisitor::base_variable_ctx=*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_control_flow___VariableContext___sub(variable[7])(variable[7], variable[0]) /*VariableContext::sub*/;
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[7]) /*TypingVisitor::variable_ctx=*/;
  /* Register variable[7]: Result */
  variable[7] = NEW_Array_array___Array___init() /*new Array[AutoVariable]*/;
  CALL_syntax_base___PClosureDef___variables__eq(variable[0])(variable[0], variable[7]) /*PClosureDef::variables=*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_parser_nodes___AClosureDef___n_id(variable[0])(variable[0]) /*AClosureDef::n_id*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_abstract_collection___Collection___length(variable[7])(variable[7]) /*List::length*/;
  /* Register variable[7]: Result */
  variable[7] = NEW_Range_range___Range___without_last( TAG_Int(0), variable[7]) /*new Range[Int]*/;
  /* Register variable[7]: For iterator */
  variable[7] = CALL_abstract_collection___Collection___iterator(variable[7])(variable[7]) /*Range::iterator*/;
  while (true) { /*for*/
    /* Register variable[8]: For 'is_ok' result */
    variable[8] = CALL_abstract_collection___Iterator___is_ok(variable[7])(variable[7]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[8])) break; /*for*/
    variable[8] = CALL_abstract_collection___Iterator___item(variable[7])(variable[7]) /*Iterator::item*/ /* Ensure var: For item*/;
    /* Register variable[9]: Local variable */
    variable[9] = variable[8];
    /* Register variable[10]: Local variable */
    /* Register variable[11]: Result */
    variable[11] = CALL_parser_nodes___AClosureDef___n_id(variable[0])(variable[0]) /*AClosureDef::n_id*/;
    /* Register variable[11]: Result */
    variable[11] = CALL_abstract_collection___MapRead_____bra(variable[11])(variable[11],  variable[9] /*i*/) /*List::[]*/;
    /* Register variable[11]: Result */
    variable[11] = CALL_syntax_base___Token___to_symbol(variable[11])(variable[11]) /*Token::to_symbol*/;
    /* Register variable[11]: Result */
    variable[11] = NEW_AutoVariable_syntax_base___AutoVariable___init(variable[11], variable[0]) /*new AutoVariable*/;
    variable[10] = variable[11];
    /* Register variable[11]: Result */
    variable[11] = CALL_syntax_base___PClosureDef___variables(variable[0])(variable[0]) /*PClosureDef::variables*/;
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11],  variable[10] /*va*/) /*AbstractArray::add*/;
    /* Register variable[11]: Result */
    variable[11] = CALL_static_type___MMSignature_____bra( variable[4] /*sig*/)( variable[4] /*sig*/,  variable[9] /*i*/) /*MMSignature::[]*/;
    CALL_syntax_base___Variable___stype__eq( variable[10] /*va*/)( variable[10] /*va*/, variable[11]) /*Variable::stype=*/;
    /* Register variable[11]: Result */
    variable[11] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    CALL_control_flow___VariableContext___add(variable[11])(variable[11],  variable[10] /*va*/) /*VariableContext::add*/;
    continue_335: while(0);
    CALL_abstract_collection___Iterator___next(variable[7])(variable[7]) /*Iterator::next*/;
  }
  break_335: while(0);
  ATTR_typing___PClosureDef____accept_typing2(variable[0]) /*PClosureDef::_accept_typing2*/ =  TAG_Bool(true);
  CALL_typing___PNode___accept_typing(variable[0])(variable[0],  variable[1] /*v*/) /*PClosureDef::accept_typing*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
  /* Register variable[7]: Result */
  variable[7] = CALL_control_flow___VariableContext___unreash(variable[7])(variable[7]) /*VariableContext::unreash*/;
  /* Register variable[7]: Result */
  variable[7] = TAG_Bool((variable[7])==( TAG_Bool(false)));
  if (UNTAG_Bool(variable[7])) { /*if*/
    /* Register variable[7]: Result */
    variable[7] = CALL_syntax_base___PClosureDef___closure(variable[0])(variable[0]) /*PClosureDef::closure*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_static_type___MMClosure___signature(variable[7])(variable[7]) /*MMClosure::signature*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_static_type___MMSignature___return_type(variable[7])(variable[7]) /*MMSignature::return_type*/;
    /* Register variable[7]: Result */
    variable[7] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[7] ==  NIT_NULL /*null*/) || ((variable[7] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[7])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[7], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[7])(variable[7],  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[7])) { /*if*/
      /* Register variable[7]: Once String constant */
      if (once_value_336 != NIT_NULL) variable[7] = once_value_336;
      else {
        variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Control error: Reached end of block (a 'continue' with a value was expected)."), TAG_Int(77)) /*new String*/;
        once_value_336 = variable[7];
      }
      /* Register variable[7]: Result */
      CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::error*/;
    } else { /*if*/
      /* Register variable[7]: Result */
      variable[7] = CALL_syntax_base___PClosureDef___closure(variable[0])(variable[0]) /*PClosureDef::closure*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_static_type___MMClosure___is_break(variable[7])(variable[7]) /*MMClosure::is_break*/;
      if (UNTAG_Bool(variable[7])) { /*if*/
        /* Register variable[7]: Once String constant */
        if (once_value_337 != NIT_NULL) variable[7] = once_value_337;
        else {
          variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Control error: Reached end of break block (a 'break' was expected)."), TAG_Int(67)) /*new String*/;
          once_value_337 = variable[7];
        }
        /* Register variable[7]: Result */
        CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::error*/;
      }
    }
  }
  CALL_typing___TypingVisitor___variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[5] /*old_var_ctx*/) /*TypingVisitor::variable_ctx=*/;
  CALL_typing___TypingVisitor___base_variable_ctx__eq( variable[1] /*v*/)( variable[1] /*v*/,  variable[6] /*old_base_var_ctx*/) /*TypingVisitor::base_variable_ctx=*/;
  return_label331: while(false);
  tracehead = trace.prev;
  return;
}
void typing___ATypeCheckExpr___check_expr_cast(val_t  self, val_t  param0, val_t  param1, val_t  param2) {
  struct trace_t trace = {NULL, NULL, 1585, LOCATE_typing___ATypeCheckExpr___check_expr_cast};
    static val_t once_value_339 = NIT_NULL; /* Once value for string variable[8]*/
    static val_t once_value_340 = NIT_NULL; /* Once value for string variable[8]*/
      static val_t once_value_341 = NIT_NULL; /* Once value for string variable[8]*/
      static val_t once_value_342 = NIT_NULL; /* Once value for string variable[8]*/
      static val_t once_value_343 = NIT_NULL; /* Once value for string variable[8]*/
            static val_t once_value_344 = NIT_NULL; /* Once value for string variable[7]*/
            static val_t once_value_345 = NIT_NULL; /* Once value for string variable[7]*/
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Method return value and escape marker */
  /* Register variable[5]: Result */
  variable[5] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/,  variable[2] /*n_expr*/) /*AbsSyntaxVisitor::check_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[5])))) { /*if*/
    goto return_label338;
  }
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_syntax_base___PExpr___stype( variable[2] /*n_expr*/)( variable[2] /*n_expr*/) /*PExpr::stype*/;
  variable[5] = variable[6];
  /* Register variable[6]: Local variable */
  /* Register variable[7]: Result */
  variable[7] = CALL_typing___PType___stype( variable[3] /*n_type*/)( variable[3] /*n_type*/) /*PType::stype*/;
  variable[6] = variable[7];
  /* Register variable[7]: Result */
  variable[7] = TAG_Bool(( variable[5] /*etype*/ ==  variable[6] /*ttype*/) || (( variable[5] /*etype*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*etype*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*etype*/, variable[6] /*ttype*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*etype*/)( variable[5] /*etype*/,  variable[6] /*ttype*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[7])) { /*if*/
    variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[8]: Once String constant */
    if (once_value_339 != NIT_NULL) variable[8] = once_value_339;
    else {
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Warning: Expression is already a "), TAG_Int(33)) /*new String*/;
      once_value_339 = variable[8];
    }
    /* Register variable[8]: Result */
    /* Ensure var variable[8]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
    variable[8] =  variable[6] /*ttype*/ /* Ensure var: super-string element*/;
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
    /* Register variable[8]: Once String constant */
    if (once_value_340 != NIT_NULL) variable[8] = once_value_340;
    else {
      variable[8] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
      once_value_340 = variable[8];
    }
    /* Register variable[8]: Result */
    /* Ensure var variable[8]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
    /* Register variable[7]: Result */
    variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::warning*/;
  } else { /*if*/
    /* Register variable[7]: Result */
    variable[7] = CALL_static_type___MMType_____l( variable[5] /*etype*/)( variable[5] /*etype*/,  variable[6] /*ttype*/) /*MMType::<*/;
    if (UNTAG_Bool(variable[7])) { /*if*/
      variable[7] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
      /* Register variable[8]: Once String constant */
      if (once_value_341 != NIT_NULL) variable[8] = once_value_341;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString("Warning: Expression is already a "), TAG_Int(33)) /*new String*/;
        once_value_341 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      variable[8] =  variable[6] /*ttype*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[8]: Once String constant */
      if (once_value_342 != NIT_NULL) variable[8] = once_value_342;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString(" since it is a "), TAG_Int(15)) /*new String*/;
        once_value_342 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      variable[8] =  variable[5] /*etype*/ /* Ensure var: super-string element*/;
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/) /*AbstractArray::add*/;
      /* Register variable[8]: Once String constant */
      if (once_value_343 != NIT_NULL) variable[8] = once_value_343;
      else {
        variable[8] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)) /*new String*/;
        once_value_343 = variable[8];
      }
      /* Register variable[8]: Result */
      /* Ensure var variable[8]: super-string element*/
      CALL_abstract_collection___SimpleCollection___add(variable[7])(variable[7], variable[8]) /*AbstractArray::add*/;
      /* Register variable[7]: Result */
      variable[7] = CALL_string___Object___to_s(variable[7])(variable[7]) /*Object::to_s*/;
      CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::warning*/;
    } else { /*if*/
      /* Register variable[7]: Result */
      variable[7] = CALL_static_type___MMType___is_nullable( variable[5] /*etype*/)( variable[5] /*etype*/) /*MMType::is_nullable*/;
      /* Ensure var variable[7]: Left 'and' operand*/
      if (UNTAG_Bool(variable[7])) { /* and */
        /* Register variable[7]: Result */
        variable[7] = CALL_static_type___MMType___as_notnull( variable[5] /*etype*/)( variable[5] /*etype*/) /*MMType::as_notnull*/;
        /* Register variable[7]: Result */
        variable[7] = TAG_Bool((variable[7] ==  variable[6] /*ttype*/) || ((variable[7] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[7])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[7], variable[6] /*ttype*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[7])(variable[7],  variable[6] /*ttype*/) /*Object::==*/)))));
      }
      /* Register variable[7]: Result */
      if (UNTAG_Bool(variable[7])) { /*if*/
        /* Register variable[7]: Result */
        variable[7] = TAG_Bool(( variable[6] /*ttype*/==NIT_NULL) || VAL_ISA( variable[6] /*ttype*/, COLOR_MMTypeFormal, ID_MMTypeFormal)) /*cast MMTypeFormal*/;
        /* Ensure var variable[7]: Left 'and' operand*/
        if (UNTAG_Bool(variable[7])) { /* and */
          /* Register variable[7]: Result */
          variable[7] = CALL_type_formal___MMTypeFormal___bound( variable[6] /*ttype*/)( variable[6] /*ttype*/) /*MMTypeFormal::bound*/;
          /* Register variable[7]: Result */
          variable[7] = CALL_static_type___MMType___is_nullable(variable[7])(variable[7]) /*MMType::is_nullable*/;
        }
        /* Register variable[7]: Result */
        if (UNTAG_Bool(variable[7])) { /*if*/
        } else { /*if*/
          /* Register variable[7]: Result */
          variable[7] = TAG_Bool((variable[0]==NIT_NULL) || VAL_ISA(variable[0], COLOR_AIsaExpr, ID_AIsaExpr)) /*cast AIsaExpr*/;
          if (UNTAG_Bool(variable[7])) { /*if*/
            /* Register variable[7]: Once String constant */
            if (once_value_344 != NIT_NULL) variable[7] = once_value_344;
            else {
              variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Warning: Prefer '!= null'."), TAG_Int(26)) /*new String*/;
              once_value_344 = variable[7];
            }
            /* Register variable[7]: Result */
            CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::warning*/;
          } else { /*if*/
            /* Register variable[7]: Once String constant */
            if (once_value_345 != NIT_NULL) variable[7] = once_value_345;
            else {
              variable[7] = NEW_String_string___String___with_native(BOX_NativeString("Warning: Prefer '.as(not null)'."), TAG_Int(32)) /*new String*/;
              once_value_345 = variable[7];
            }
            /* Register variable[7]: Result */
            CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[7]) /*AbsSyntaxVisitor::warning*/;
          }
        }
      }
    }
  }
  return_label338: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AIsaExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1612, LOCATE_typing___AIsaExpr___after_typing};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AIsaExpr___n_expr(variable[0])(variable[0]) /*AIsaExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIsaExpr___n_type(variable[0])(variable[0]) /*AIsaExpr::n_type*/;
  CALL_typing___ATypeCheckExpr___check_expr_cast(variable[0])(variable[0],  variable[1] /*v*/, variable[3], variable[4]) /*ATypeCheckExpr::check_expr_cast*/;
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AIsaExpr___n_expr(variable[0])(variable[0]) /*AIsaExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_typing___PExpr___its_variable(variable[4])(variable[4]) /*PExpr::its_variable*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*variable*/ ==  NIT_NULL /*null*/) || (( variable[3] /*variable*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*variable*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*variable*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*variable*/)( variable[3] /*variable*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_typing___TypingVisitor___variable_ctx( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::variable_ctx*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_parser_nodes___AIsaExpr___n_type(variable[0])(variable[0]) /*AIsaExpr::n_type*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_typing___PType___stype(variable[5])(variable[5]) /*PType::stype*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_control_flow___VariableContext___sub_with(variable[4])(variable[4], variable[0],  variable[3] /*variable*/, variable[5]) /*VariableContext::sub_with*/;
    ATTR_typing___PExpr____if_true_variable_ctx(variable[0]) /*PExpr::_if_true_variable_ctx*/ = variable[4];
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___AbsSyntaxVisitor___type_bool( variable[1] /*v*/)( variable[1] /*v*/) /*AbsSyntaxVisitor::type_bool*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[4];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label346: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAsCastExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1626, LOCATE_typing___AAsCastExpr___after_typing};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAsCastExpr___n_expr(variable[0])(variable[0]) /*AAsCastExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAsCastExpr___n_type(variable[0])(variable[0]) /*AAsCastExpr::n_type*/;
  CALL_typing___ATypeCheckExpr___check_expr_cast(variable[0])(variable[0],  variable[1] /*v*/, variable[3], variable[4]) /*ATypeCheckExpr::check_expr_cast*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAsCastExpr___n_type(variable[0])(variable[0]) /*AAsCastExpr::n_type*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___PType___stype(variable[3])(variable[3]) /*PType::stype*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ = variable[3];
  return_label347: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AAsNotnullExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1635, LOCATE_typing___AAsNotnullExpr___after_typing};
    static val_t once_value_349 = NIT_NULL; /* Once value for string variable[5]*/
      static val_t once_value_350 = NIT_NULL; /* Once value for string variable[5]*/
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AAsNotnullExpr___n_expr(variable[0])(variable[0]) /*AAsNotnullExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___AbsSyntaxVisitor___check_expr( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*AbsSyntaxVisitor::check_expr*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label348;
  }
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAsNotnullExpr___n_expr(variable[0])(variable[0]) /*AAsNotnullExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[3] /*t*/==NIT_NULL) || VAL_ISA( variable[3] /*t*/, COLOR_MMTypeNone, ID_MMTypeNone)) /*cast MMTypeNone*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_parser_nodes___AAsNotnullExpr___n_expr(variable[0])(variable[0]) /*AAsNotnullExpr::n_expr*/;
    /* Register variable[5]: Once String constant */
    if (once_value_349 != NIT_NULL) variable[5] = once_value_349;
    else {
      variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Type error: 'as(not null)' on 'null' value."), TAG_Int(43)) /*new String*/;
      once_value_349 = variable[5];
    }
    /* Register variable[5]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___error( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::error*/;
    goto return_label348;
  } else { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_static_type___MMType___is_nullable( variable[3] /*t*/)( variable[3] /*t*/) /*MMType::is_nullable*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[4])))) { /*if*/
      /* Register variable[4]: Result */
      variable[4] = CALL_parser_nodes___AAsNotnullExpr___n_expr(variable[0])(variable[0]) /*AAsNotnullExpr::n_expr*/;
      /* Register variable[5]: Once String constant */
      if (once_value_350 != NIT_NULL) variable[5] = once_value_350;
      else {
        variable[5] = NEW_String_string___String___with_native(BOX_NativeString("Warning: 'as(not null)' on non nullable type."), TAG_Int(45)) /*new String*/;
        once_value_350 = variable[5];
      }
      /* Register variable[5]: Result */
      CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/, variable[4], variable[5]) /*AbsSyntaxVisitor::warning*/;
    }
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_parser_nodes___AAsNotnullExpr___n_expr(variable[0])(variable[0]) /*AAsNotnullExpr::n_expr*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_syntax_base___PExpr___stype(variable[4])(variable[4]) /*PExpr::stype*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_static_type___MMType___as_notnull(variable[4])(variable[4]) /*MMType::as_notnull*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[4];
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  return_label348: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AProxyExpr___after_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1651, LOCATE_typing___AProxyExpr___after_typing};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AProxyExpr___n_expr(variable[0])(variable[0]) /*AProxyExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___is_typed(variable[3])(variable[3]) /*PExpr::is_typed*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    goto return_label351;
  }
  ATTR_typing___PExpr____is_typed(variable[0]) /*PExpr::_is_typed*/ =  TAG_Bool(true);
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AProxyExpr___n_expr(variable[0])(variable[0]) /*AProxyExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___is_statement(variable[3])(variable[3]) /*PExpr::is_statement*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    goto return_label351;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_parser_nodes___AProxyExpr___n_expr(variable[0])(variable[0]) /*AProxyExpr::n_expr*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___PExpr___stype(variable[3])(variable[3]) /*PExpr::stype*/;
  ATTR_typing___PExpr____stype(variable[0]) /*PExpr::_stype*/ = variable[3];
  return_label351: while(false);
  tracehead = trace.prev;
  return;
}
void typing___AOnceExpr___accept_typing(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 1661, LOCATE_typing___AOnceExpr___accept_typing};
    static val_t once_value_353 = NIT_NULL; /* Once value for string variable[3]*/
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_typing;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___once_count( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::once_count*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: Once String constant */
    if (once_value_353 != NIT_NULL) variable[3] = once_value_353;
    else {
      variable[3] = NEW_String_string___String___with_native(BOX_NativeString("Useless once in a once expression."), TAG_Int(34)) /*new String*/;
      once_value_353 = variable[3];
    }
    /* Register variable[3]: Result */
    CALL_syntax_base___AbsSyntaxVisitor___warning( variable[1] /*v*/)( variable[1] /*v*/, variable[0], variable[3]) /*AbsSyntaxVisitor::warning*/;
  }
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___once_count( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::once_count*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1)));
  CALL_typing___TypingVisitor___once_count__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::once_count=*/;
  CALL_SUPER_typing___AOnceExpr___accept_typing(variable[0])(variable[0], variable[1]) /*super AOnceExpr::accept_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_typing___TypingVisitor___once_count( variable[1] /*v*/)( variable[1] /*v*/) /*TypingVisitor::once_count*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Int(UNTAG_Int(variable[3])-UNTAG_Int( TAG_Int(1)));
  CALL_typing___TypingVisitor___once_count__eq( variable[1] /*v*/)( variable[1] /*v*/, variable[3]) /*TypingVisitor::once_count=*/;
  return_label352: while(false);
  tracehead = trace.prev;
  return;
}
