/* This C file is generated by NIT to compile module escape. */
#include "escape._sep.h"
void escape___EscapableContext___push(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 27, LOCATE_escape___EscapableContext___push};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_escape___EscapableContext____stack(variable[0]) /*EscapableContext::_stack*/;
  CALL_abstract_collection___IndexedCollection___push(variable[3])(variable[3],  variable[1] /*block*/) /*AbstractArray::push*/;
  return_label0: while(false);
  tracehead = trace.prev;
  return;
}
val_t escape___EscapableContext___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 33, LOCATE_escape___EscapableContext___is_empty};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_escape___EscapableContext____stack(variable[0]) /*EscapableContext::_stack*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[2])(variable[2]) /*AbstractArrayRead::is_empty*/;
  variable[1] = variable[2];
  goto return_label1;
  return_label1: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t escape___EscapableContext___head(val_t  self) {
  struct trace_t trace = {NULL, NULL, 36, LOCATE_escape___EscapableContext___head};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_escape___EscapableContext____stack(variable[0]) /*EscapableContext::_stack*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___IndexedCollectionRead___last(variable[2])(variable[2]) /*IndexedCollectionRead::last*/;
  variable[1] = variable[2];
  goto return_label2;
  return_label2: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void escape___EscapableContext___pop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 42, LOCATE_escape___EscapableContext___pop};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Local variable */
  /* Register variable[3]: Result */
  variable[3] = ATTR_escape___EscapableContext____stack(variable[0]) /*EscapableContext::_stack*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___IndexedCollection___pop(variable[3])(variable[3]) /*AbstractArray::pop*/;
  variable[2] = variable[3];
  return_label3: while(false);
  tracehead = trace.prev;
  return;
}
val_t escape___EscapableContext___visitor(val_t  self) {
  struct trace_t trace = {NULL, NULL, 48, LOCATE_escape___EscapableContext___visitor};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  tracehead = trace.prev;
  return ATTR_escape___EscapableContext____visitor( self) /*EscapableContext::_visitor*/;
}
void escape___EscapableContext___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 49, LOCATE_escape___EscapableContext___init};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_EscapableContext].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  ATTR_escape___EscapableContext____visitor(variable[0]) /*EscapableContext::_visitor*/ =  variable[1] /*v*/;
  return_label4: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_EscapableContext].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t escape___EscapableBlock___node(val_t  self) {
  struct trace_t trace = {NULL, NULL, 60, LOCATE_escape___EscapableBlock___node};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  tracehead = trace.prev;
  return ATTR_escape___EscapableBlock____node( self) /*EscapableBlock::_node*/;
}
val_t escape___EscapableBlock___is_break_block(val_t  self) {
  struct trace_t trace = {NULL, NULL, 63, LOCATE_escape___EscapableBlock___is_break_block};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  TAG_Bool(false);
  goto return_label5;
  return_label5: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t escape___EscapableBlock___break_list(val_t  self) {
  struct trace_t trace = {NULL, NULL, 66, LOCATE_escape___EscapableBlock___break_list};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  NIT_NULL /*null*/;
  goto return_label6;
  return_label6: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t escape___EscapableBlock___continue_stype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 71, LOCATE_escape___EscapableBlock___continue_stype};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  NIT_NULL /*null*/;
  goto return_label7;
  return_label7: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void escape___EscapableBlock___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 74, LOCATE_escape___EscapableBlock___init};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_EscapableBlock].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  ATTR_escape___EscapableBlock____node(variable[0]) /*EscapableBlock::_node*/ =  variable[1] /*node*/;
  return_label8: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_EscapableBlock].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t escape___EscapableClosure___is_break_block(val_t  self) {
  struct trace_t trace = {NULL, NULL, 86, LOCATE_escape___EscapableClosure___is_break_block};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_escape___EscapableClosure____closure(variable[0]) /*EscapableClosure::_closure*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_static_type___MMClosure___is_break(variable[2])(variable[2]) /*MMClosure::is_break*/;
  variable[1] = variable[2];
  goto return_label9;
  return_label9: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t escape___EscapableClosure___break_list(val_t  self) {
  struct trace_t trace = {NULL, NULL, 88, LOCATE_escape___EscapableClosure___break_list};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  tracehead = trace.prev;
  return ATTR_escape___EscapableClosure____break_list( self) /*EscapableClosure::_break_list*/;
}
val_t escape___EscapableClosure___continue_stype(val_t  self) {
  struct trace_t trace = {NULL, NULL, 90, LOCATE_escape___EscapableClosure___continue_stype};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_escape___EscapableClosure____closure(variable[0]) /*EscapableClosure::_closure*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_static_type___MMClosure___signature(variable[2])(variable[2]) /*MMClosure::signature*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_static_type___MMSignature___return_type(variable[2])(variable[2]) /*MMSignature::return_type*/;
  variable[1] = variable[2];
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t escape___EscapableClosure___closure(val_t  self) {
  struct trace_t trace = {NULL, NULL, 83, LOCATE_escape___EscapableClosure___closure};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  tracehead = trace.prev;
  return ATTR_escape___EscapableClosure____closure( self) /*EscapableClosure::_closure*/;
}
void escape___EscapableClosure___init(val_t  self, val_t  param0, val_t  param1, val_t  param2, int* init_table) {
  struct trace_t trace = {NULL, NULL, 92, LOCATE_escape___EscapableClosure___init};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_EscapableClosure].i]) return;
  /* Register variable[4]: Method return value and escape marker */
  CALL_escape___EscapableBlock___init(variable[0])(variable[0],  variable[1] /*node*/, init_table /*YYY*/) /*EscapableBlock::init*/;
  ATTR_escape___EscapableClosure____closure(variable[0]) /*EscapableClosure::_closure*/ =  variable[2] /*closure*/;
  ATTR_escape___EscapableClosure____break_list(variable[0]) /*EscapableClosure::_break_list*/ =  variable[3] /*break_list*/;
  return_label11: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_EscapableClosure].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t escape___AEscapeExpr___escapable_block(val_t  self) {
  struct trace_t trace = {NULL, NULL, 104, LOCATE_escape___AEscapeExpr___escapable_block};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  tracehead = trace.prev;
  return ATTR_escape___AEscapeExpr____escapable_block( self) /*AEscapeExpr::_escapable_block*/;
}
val_t escape___AEscapeExpr___kwname(val_t  self) {
  struct trace_t trace = {NULL, NULL, 107, LOCATE_escape___AEscapeExpr___kwname};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_escape, 107);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t escape___AEscapeExpr___compute_escapable_block(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 110, LOCATE_escape___AEscapeExpr___compute_escapable_block};
    static val_t once_value_13 = NIT_NULL; /* Once value for string variable[6]*/
    static val_t once_value_14 = NIT_NULL; /* Once value for string variable[6]*/
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /*variable[3] is variable block*/
  /* Register variable[4]: Result */
  variable[4] = CALL_escape___EscapableContext___is_empty( variable[1] /*lctx*/)( variable[1] /*lctx*/) /*EscapableContext::is_empty*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_escape___EscapableContext___visitor( variable[1] /*lctx*/)( variable[1] /*lctx*/) /*EscapableContext::visitor*/;
    variable[5] = NEW_Array_array___Array___with_capacity(TAG_Int(3)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[6]: Once String constant */
    if (once_value_13 != NIT_NULL) variable[6] = once_value_13;
    else {
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString("Syntax Error: '"), TAG_Int(15)) /*new String*/;
      once_value_13 = variable[6];
    }
    /* Register variable[6]: Result */
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_escape___AEscapeExpr___kwname(variable[0])(variable[0]) /*AEscapeExpr::kwname*/;
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
    /* Register variable[6]: Once String constant */
    if (once_value_14 != NIT_NULL) variable[6] = once_value_14;
    else {
      variable[6] = NEW_String_string___String___with_native(BOX_NativeString("' statment outside block."), TAG_Int(25)) /*new String*/;
      once_value_14 = variable[6];
    }
    /* Register variable[6]: Result */
    /* Ensure var variable[6]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[5])(variable[5], variable[6]) /*AbstractArray::add*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_string___Object___to_s(variable[5])(variable[5]) /*Object::to_s*/;
    CALL_syntax_base___AbsSyntaxVisitor___error(variable[4])(variable[4], variable[0], variable[5]) /*AbsSyntaxVisitor::error*/;
    variable[2] =  NIT_NULL /*null*/;
    goto return_label12;
  }
  /* Register variable[4]: Result */
  variable[4] = CALL_escape___EscapableContext___head( variable[1] /*lctx*/)( variable[1] /*lctx*/) /*EscapableContext::head*/;
  variable[3] = variable[4] /*block=*/;
  ATTR_escape___AEscapeExpr____escapable_block(variable[0]) /*AEscapeExpr::_escapable_block*/ =  variable[3] /*block*/;
  variable[2] =  variable[3] /*block*/;
  goto return_label12;
  return_label12: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t escape___AContinueExpr___kwname(val_t  self) {
  struct trace_t trace = {NULL, NULL, 126, LOCATE_escape___AContinueExpr___kwname};
  static val_t once_value_16 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once String constant */
  if (once_value_16 != NIT_NULL) variable[2] = once_value_16;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("continue"), TAG_Int(8)) /*new String*/;
    once_value_16 = variable[2];
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label15;
  return_label15: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t escape___ABreakExpr___kwname(val_t  self) {
  struct trace_t trace = {NULL, NULL, 131, LOCATE_escape___ABreakExpr___kwname};
  static val_t once_value_18 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_escape;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once String constant */
  if (once_value_18 != NIT_NULL) variable[2] = once_value_18;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("break"), TAG_Int(5)) /*new String*/;
    once_value_18 = variable[2];
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label17;
  return_label17: while(false);
  tracehead = trace.prev;
  return variable[1];
}
