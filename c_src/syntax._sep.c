/* This C file is generated by NIT to compile module syntax. */
#include "syntax._sep.h"
val_t syntax___SrcModuleLoader___file_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 30, LOCATE_syntax___SrcModuleLoader___file_type};
  static val_t once_value_1 = NIT_NULL; /* Once value for string variable[2]*/
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Once String constant */
  if (once_value_1 != NIT_NULL) variable[2] = once_value_1;
  else {
    variable[2] = NEW_String_string___String___with_native(BOX_NativeString("nit"), TAG_Int(3)) /*new String*/;
    once_value_1 = variable[2];
  }
  /* Register variable[2]: Result */
  variable[1] = variable[2];
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t syntax___SrcModuleLoader___parse_file(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3, val_t  param4) {
  struct trace_t trace = {NULL, NULL, 32, LOCATE_syntax___SrcModuleLoader___parse_file};
    static val_t once_value_3 = NIT_NULL; /* Once value for string variable[12]*/
    static val_t once_value_4 = NIT_NULL; /* Once value for string variable[12]*/
    static val_t once_value_5 = NIT_NULL; /* Once value for string variable[12]*/
  val_t variable[13];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Local variable */
  variable[4] =  param3;
  /* Register variable[5]: Local variable */
  variable[5] =  param4;
  /* Register variable[6]: Method return value and escape marker */
  /* Register variable[7]: Local variable */
  /* Register variable[8]: Result */
  variable[8] = NEW_Lexer_lexer___Lexer___init( variable[2] /*file*/,  variable[3] /*filename*/) /*new Lexer*/;
  variable[7] = variable[8];
  /* Register variable[8]: Local variable */
  /* Register variable[9]: Result */
  variable[9] = NEW_Parser_parser___Parser___init( variable[7] /*lexer*/) /*new Parser*/;
  variable[8] = variable[9];
  /* Register variable[9]: Local variable */
  /* Register variable[10]: Result */
  variable[10] = CALL_parser___Parser___parse( variable[8] /*parser*/)( variable[8] /*parser*/) /*Parser::parse*/;
  variable[9] = variable[10];
  /* Register variable[10]: Result */
  variable[10] = CALL_parser_nodes___Start___n_base( variable[9] /*node_tree*/)( variable[9] /*node_tree*/) /*Start::n_base*/;
  /* Register variable[10]: Result */
  variable[10] = TAG_Bool((variable[10] ==  NIT_NULL /*null*/) || ((variable[10] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[10])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[10], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[10])(variable[10],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[10])) { /*if*/
    /* Register variable[10]: Local variable */
    /* Register variable[11]: Result */
    variable[11] = CALL_parser_nodes___Start___n_eof( variable[9] /*node_tree*/)( variable[9] /*node_tree*/) /*Start::n_eof*/;
    variable[10] = variable[11];
    /* Register variable[11]: Result */
    variable[11] = TAG_Bool(( variable[10] /*err*/==NIT_NULL) || VAL_ISA( variable[10] /*err*/, COLOR_PError, ID_PError)) /*cast PError*/;
    if (!UNTAG_Bool(variable[11])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_syntax___SrcModuleLoader___parse_file, LOCATE_syntax, 39); nit_exit(1);}
    variable[11] = NEW_Array_array___Array___with_capacity(TAG_Int(5)) /*new Array[String]*/ /* Ensure var: Array (for super-string)*/;
    /* Register variable[12]: Once String constant */
    if (once_value_3 != NIT_NULL) variable[12] = once_value_3;
    else {
      variable[12] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_3 = variable[12];
    }
    /* Register variable[12]: Result */
    /* Ensure var variable[12]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[12]) /*AbstractArray::add*/;
    /* Register variable[12]: Result */
    variable[12] = CALL_parser_prod___PNode___locate( variable[10] /*err*/)( variable[10] /*err*/) /*Token::locate*/;
    /* Ensure var variable[12]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[12]) /*AbstractArray::add*/;
    /* Register variable[12]: Once String constant */
    if (once_value_4 != NIT_NULL) variable[12] = once_value_4;
    else {
      variable[12] = NEW_String_string___String___with_native(BOX_NativeString(": "), TAG_Int(2)) /*new String*/;
      once_value_4 = variable[12];
    }
    /* Register variable[12]: Result */
    /* Ensure var variable[12]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[12]) /*AbstractArray::add*/;
    /* Register variable[12]: Result */
    variable[12] = CALL_lexer___PError___message( variable[10] /*err*/)( variable[10] /*err*/) /*PError::message*/;
    /* Ensure var variable[12]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[12]) /*AbstractArray::add*/;
    /* Register variable[12]: Once String constant */
    if (once_value_5 != NIT_NULL) variable[12] = once_value_5;
    else {
      variable[12] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)) /*new String*/;
      once_value_5 = variable[12];
    }
    /* Register variable[12]: Result */
    /* Ensure var variable[12]: super-string element*/
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[12]) /*AbstractArray::add*/;
    /* Register variable[11]: Result */
    variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
    CALL_mmloader___ToolContext___error( variable[1] /*context*/)( variable[1] /*context*/, variable[11]) /*ToolContext::error*/;
    exit(UNTAG_Int( TAG_Int(1)));
  }
  /* Register variable[10]: Local variable */
  /* Register variable[11]: Result */
  variable[11] = CALL_parser_nodes___Start___n_base( variable[9] /*node_tree*/)( variable[9] /*node_tree*/) /*Start::n_base*/;
  variable[10] = variable[11];
  /* Register variable[11]: Result */
  variable[11] = TAG_Bool(( variable[10] /*node_module*/==NIT_NULL) || VAL_ISA( variable[10] /*node_module*/, COLOR_AModule, ID_AModule)) /*cast AModule*/;
  if (!UNTAG_Bool(variable[11])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_syntax___SrcModuleLoader___parse_file, LOCATE_syntax, 44); nit_exit(1);}
  /* Register variable[11]: Local variable */
  /* Register variable[12]: Result */
  variable[12] = NEW_MMSrcModule_syntax_base___MMSrcModule___init( variable[1] /*context*/,  variable[10] /*node_module*/,  variable[5] /*dir*/,  variable[4] /*name*/,  variable[3] /*filename*/) /*new MMSrcModule*/;
  variable[11] = variable[12];
  variable[6] =  variable[11] /*module*/;
  goto return_label2;
  return_label2: while(false);
  tracehead = trace.prev;
  return variable[6];
}
void syntax___SrcModuleLoader___process_metamodel(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 49, LOCATE_syntax___SrcModuleLoader___process_metamodel};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  CALL_syntax___MMSrcModule___process_supermodules( variable[2] /*module*/)( variable[2] /*module*/,  variable[1] /*context*/) /*MMSrcModule::process_supermodules*/;
  CALL_syntax___MMSrcModule___process_syntax( variable[2] /*module*/)( variable[2] /*module*/,  variable[1] /*context*/) /*MMSrcModule::process_syntax*/;
  return_label6: while(false);
  tracehead = trace.prev;
  return;
}
void syntax___SrcModuleLoader___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 55, LOCATE_syntax___SrcModuleLoader___init};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_SrcModuleLoader].i]) return;
  /* Register variable[1]: Method return value and escape marker */
  return_label7: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_SrcModuleLoader].i] = 1;
  tracehead = trace.prev;
  return;
}
void syntax___MMSrcModule___process_supermodules(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 59, LOCATE_syntax___MMSrcModule___process_supermodules};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_syntax_base___MMSrcModule___node(variable[0])(variable[0]) /*MMSrcModule::node*/;
  CALL_mmbuilder___AModule___import_super_modules(variable[3])(variable[3],  variable[1] /*tc*/, variable[0]) /*AModule::import_super_modules*/;
  return_label8: while(false);
  tracehead = trace.prev;
  return;
}
void syntax___MMSrcModule___process_syntax(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 65, LOCATE_syntax___MMSrcModule___process_syntax};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_mmbuilder___MMSrcModule___do_mmbuilder(variable[0])(variable[0],  variable[1] /*tc*/) /*MMSrcModule::do_mmbuilder*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_mmloader___ToolContext___error_count( variable[1] /*tc*/)( variable[1] /*tc*/) /*ToolContext::error_count*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[3])) { /*if*/
    exit(UNTAG_Int( TAG_Int(1)));
  }
  CALL_typing___MMSrcModule___do_typing(variable[0])(variable[0],  variable[1] /*tc*/) /*MMSrcModule::do_typing*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_mmloader___ToolContext___error_count( variable[1] /*tc*/)( variable[1] /*tc*/) /*ToolContext::error_count*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[3])) { /*if*/
    exit(UNTAG_Int( TAG_Int(1)));
  }
  return_label9: while(false);
  tracehead = trace.prev;
  return;
}
