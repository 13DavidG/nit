/* This C file is generated by NIT to compile module syntax. */
#include "syntax._sep.h"
val_t syntax___SrcModuleLoader___file_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 31, LOCATE_syntax___SrcModuleLoader___file_type};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  variable[0] =  self;
  variable[2] = NEW_String_string___String___with_native(BOX_NativeString("nit"), TAG_Int(3)); /*new String*/
  variable[1] = variable[2];
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t syntax___SrcModuleLoader___parse_file(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3, val_t  param4) {
  struct trace_t trace = {NULL, NULL, 33, LOCATE_syntax___SrcModuleLoader___parse_file};
  val_t variable[22];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[4] =  param3;
  variable[5] =  param4;
  variable[8] = NEW_Lexer_lexer___Lexer___init( variable[2] /*file*/,  variable[3] /*filename*/); /*new Lexer*/
  variable[7] = variable[8];
  variable[9] = NEW_Parser_parser___Parser___init( variable[7] /*lexer*/); /*new Parser*/
  variable[8] = variable[9];
  variable[10] = CALL_parser___Parser___parse( variable[8] /*parser*/)( variable[8] /*parser*/) /*Parser::parse*/;
  variable[9] = variable[10];
  variable[10] = CALL_parser_nodes___Start___n_base( variable[9] /*node_tree*/)( variable[9] /*node_tree*/) /*Start::n_base*/;
  variable[10] = TAG_Bool((variable[10] ==  NIT_NULL /*null*/) || ((variable[10] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[10])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[10], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[10])(variable[10],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[10])) { /*if*/
    variable[11] = CALL_parser_nodes___Start___n_eof( variable[9] /*node_tree*/)( variable[9] /*node_tree*/) /*Start::n_eof*/;
    variable[10] = variable[11];
    variable[11] = TAG_Bool(( variable[10] /*err*/==NIT_NULL) || VAL_ISA( variable[10] /*err*/, COLOR_PError, ID_PError)) /*cast PError*/;
    if (!UNTAG_Bool(variable[11])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_syntax___SrcModuleLoader___parse_file, LOCATE_syntax, 40); nit_exit(1);}
    variable[11] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
    variable[12] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[13] = variable[12];
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[13]) /*AbstractArray::add*/;
    variable[14] = CALL_parser_prod___PNode___locate( variable[10] /*err*/)( variable[10] /*err*/) /*Token::locate*/;
    variable[15] = variable[14];
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[15]) /*AbstractArray::add*/;
    variable[16] = NEW_String_string___String___with_native(BOX_NativeString(": "), TAG_Int(2)); /*new String*/
    variable[17] = variable[16];
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[17]) /*AbstractArray::add*/;
    variable[18] = CALL_lexer___PError___message( variable[10] /*err*/)( variable[10] /*err*/) /*PError::message*/;
    variable[19] = variable[18];
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[19]) /*AbstractArray::add*/;
    variable[20] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[21] = variable[20];
    CALL_abstract_collection___SimpleCollection___add(variable[11])(variable[11], variable[21]) /*AbstractArray::add*/;
    variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
    CALL_mmloader___ToolContext___error( variable[1] /*context*/)( variable[1] /*context*/, variable[11]) /*ToolContext::error*/;
    variable[11] = variable[0];
    exit(UNTAG_Int( TAG_Int(1)));
  }
  variable[11] = CALL_parser_nodes___Start___n_base( variable[9] /*node_tree*/)( variable[9] /*node_tree*/) /*Start::n_base*/;
  variable[10] = variable[11];
  variable[11] = TAG_Bool(( variable[10] /*node_module*/==NIT_NULL) || VAL_ISA( variable[10] /*node_module*/, COLOR_AModule, ID_AModule)) /*cast AModule*/;
  if (!UNTAG_Bool(variable[11])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_syntax___SrcModuleLoader___parse_file, LOCATE_syntax, 45); nit_exit(1);}
  variable[12] = NEW_MMSrcModule_syntax_base___MMSrcModule___init( variable[1] /*context*/,  variable[10] /*node_module*/,  variable[5] /*dir*/,  variable[4] /*name*/); /*new MMSrcModule*/
  variable[11] = variable[12];
  variable[6] =  variable[11] /*module*/;
  goto return_label1;
  return_label1: while(false);
  tracehead = trace.prev;
  return variable[6];
}
void syntax___SrcModuleLoader___process_metamodel(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 52, LOCATE_syntax___SrcModuleLoader___process_metamodel};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  CALL_syntax___MMSrcModule___process_supermodules( variable[2] /*module*/)( variable[2] /*module*/,  variable[1] /*context*/) /*MMSrcModule::process_supermodules*/;
  CALL_syntax___MMSrcModule___process_syntax( variable[2] /*module*/)( variable[2] /*module*/,  variable[1] /*context*/) /*MMSrcModule::process_syntax*/;
  return_label2: while(false);
  tracehead = trace.prev;
  return;
}
void syntax___SrcModuleLoader___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 58, LOCATE_syntax___SrcModuleLoader___init};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_SrcModuleLoader].i]) return;
  return_label3: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_SrcModuleLoader].i] = 1;
  tracehead = trace.prev;
  return;
}
void syntax___MMSrcModule___process_supermodules(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 62, LOCATE_syntax___MMSrcModule___process_supermodules};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_syntax_base___MMSrcModule___node(variable[3])(variable[3]) /*MMSrcModule::node*/;
  variable[4] = variable[0];
  CALL_mmbuilder___AModule___import_super_modules(variable[3])(variable[3],  variable[1] /*tc*/, variable[4]) /*AModule::import_super_modules*/;
  return_label4: while(false);
  tracehead = trace.prev;
  return;
}
void syntax___MMSrcModule___process_syntax(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 69, LOCATE_syntax___MMSrcModule___process_syntax};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_syntax;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  CALL_mmbuilder___MMSrcModule___do_mmbuilder(variable[3])(variable[3],  variable[1] /*tc*/) /*MMSrcModule::do_mmbuilder*/;
  variable[3] = CALL_mmloader___ToolContext___error_count( variable[1] /*tc*/)( variable[1] /*tc*/) /*ToolContext::error_count*/;
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    exit(UNTAG_Int( TAG_Int(1)));
  }
  variable[3] = variable[0];
  CALL_typing___MMSrcModule___do_typing(variable[3])(variable[3],  variable[1] /*tc*/) /*MMSrcModule::do_typing*/;
  variable[3] = CALL_mmloader___ToolContext___error_count( variable[1] /*tc*/)( variable[1] /*tc*/) /*ToolContext::error_count*/;
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    exit(UNTAG_Int( TAG_Int(1)));
  }
  variable[3] = variable[0];
  CALL_control_flow___MMSrcModule___do_control_flow(variable[3])(variable[3],  variable[1] /*tc*/) /*MMSrcModule::do_control_flow*/;
  variable[3] = CALL_mmloader___ToolContext___error_count( variable[1] /*tc*/)( variable[1] /*tc*/) /*ToolContext::error_count*/;
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    exit(UNTAG_Int( TAG_Int(1)));
  }
  return_label5: while(false);
  tracehead = trace.prev;
  return;
}
