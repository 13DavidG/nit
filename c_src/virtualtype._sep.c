/* This C file is generated by NIT to compile module virtualtype. */
#include "virtualtype._sep.h"
val_t virtualtype___MMGlobalProperty___is_virtual_type(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 24, LOCATE_virtualtype___MMGlobalProperty___is_virtual_type};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstractmetamodel___MMGlobalProperty___intro_t)CALL( self,COLOR_abstractmetamodel___MMGlobalProperty___intro))( self) /*MMGlobalProperty::intro*/;
  variable0 = TAG_Bool((variable0==NIT_NULL) || VAL_ISA(variable0, COLOR_MMTypeProperty, ID_MMTypeProperty)) /*cast MMTypeProperty*/;
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t virtualtype___MMTypeProperty___stype_for(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 31, LOCATE_virtualtype___MMTypeProperty___stype_for};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((static_type___MMType___local_class_t)CALL( variable0 /*recv*/,COLOR_static_type___MMType___local_class))( variable0 /*recv*/) /*MMType::local_class*/;
  variable3 = ((abstractmetamodel___MMLocalProperty___global_t)CALL( self,COLOR_abstractmetamodel___MMLocalProperty___global))( self) /*MMLocalProperty::global*/;
  variable2 = ((inheritance___MMLocalClass_____bra_t)CALL(variable2,COLOR_abstractmetamodel___MMLocalClass_____bra))(variable2, variable3) /*MMLocalClass::[]*/;
  variable1 = variable2;
  variable2 = TAG_Bool(( variable1 /*prop*/==NIT_NULL) || VAL_ISA( variable1 /*prop*/, COLOR_MMTypeProperty, ID_MMTypeProperty)) /*cast MMTypeProperty*/;
  if (!UNTAG_Bool(variable2)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_virtualtype___MMTypeProperty___stype_for, LOCATE_virtualtype, 35); nit_exit(1);}
  variable2 = ((virtualtype___MMTypeProperty___real_stype_for_t)CALL( variable1 /*prop*/,COLOR_virtualtype___MMTypeProperty___real_stype_for))( variable1 /*prop*/,  variable0 /*recv*/) /*MMTypeProperty::real_stype_for*/;
  variable1 = variable2;
  goto return_label1;
  return_label1: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t virtualtype___MMTypeProperty___real_stype_for(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 42, LOCATE_virtualtype___MMTypeProperty___real_stype_for};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((static_type___MMLocalProperty___signature_t)CALL( self,COLOR_static_type___MMLocalProperty___signature))( self) /*MMLocalProperty::signature*/;
  variable1 = TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  NIT_NULL /*null*/;
    goto return_label2;
  }
  variable1 = ATTR_virtualtype___MMTypeProperty____stypes_cache( self) /*MMTypeProperty::_stypes_cache*/;
  variable1 = ((abstract_collection___CoupleMap___has_key_t)CALL(variable1,COLOR_abstract_collection___Map___has_key))(variable1,  variable0 /*recv*/) /*CoupleMap::has_key*/;
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = ATTR_virtualtype___MMTypeProperty____stypes_cache( self) /*MMTypeProperty::_stypes_cache*/;
    variable1 = ((abstract_collection___CoupleMap_____bra_t)CALL(variable1,COLOR_abstract_collection___Map_____bra))(variable1,  variable0 /*recv*/) /*CoupleMap::[]*/;
    goto return_label2;
  }
  variable2 = NEW_virtualtype___MMVirtualType___init( self,  variable0 /*recv*/); /*new MMVirtualType*/
  variable1 = variable2;
  variable2 = ATTR_virtualtype___MMTypeProperty____stypes_cache( self) /*MMTypeProperty::_stypes_cache*/;
  ((hash___HashMap_____braeq_t)CALL(variable2,COLOR_abstract_collection___Map_____braeq))(variable2,  variable0 /*recv*/,  variable1 /*res*/) /*HashMap::[]=*/;
  variable1 =  variable1 /*res*/;
  goto return_label2;
  return_label2: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t virtualtype___MMVirtualType___property(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 58, LOCATE_virtualtype___MMVirtualType___property};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_virtualtype___MMVirtualType____property( self) /*MMVirtualType::_property*/;
}
val_t virtualtype___MMVirtualType___recv(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 61, LOCATE_virtualtype___MMVirtualType___recv};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_virtualtype___MMVirtualType____recv( self) /*MMVirtualType::_recv*/;
}
void virtualtype___MMVirtualType___init(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 64, LOCATE_virtualtype___MMVirtualType___init};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 =  param1;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMVirtualType].i]) return;
  variable2 = ((abstractmetamodel___MMLocalProperty___name_t)CALL( variable0 /*p*/,COLOR_abstractmetamodel___MMLocalProperty___name))( variable0 /*p*/) /*MMLocalProperty::name*/;
  variable3 = ((static_type___MMLocalProperty___signature_for_t)CALL( variable0 /*p*/,COLOR_static_type___MMLocalProperty___signature_for))( variable0 /*p*/,  variable1 /*recv*/) /*MMLocalProperty::signature_for*/;
  variable3 = ((static_type___MMSignature___return_type_t)CALL(variable3,COLOR_static_type___MMSignature___return_type))(variable3) /*MMSignature::return_type*/;
  ((type_formal___MMTypeFormal___init_t)CALL( self,COLOR_type_formal___MMTypeFormal___init))( self, variable2, variable3, init_table /*YYY*/) /*MMTypeFormal::init*/;
  ATTR_virtualtype___MMVirtualType____property( self) /*MMVirtualType::_property*/ =  variable0 /*p*/;
  ATTR_virtualtype___MMVirtualType____recv( self) /*MMVirtualType::_recv*/ =  variable1 /*recv*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_MMVirtualType].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t virtualtype___MMVirtualType___module(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 71, LOCATE_virtualtype___MMVirtualType___module};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_virtualtype___MMVirtualType____recv( self) /*MMVirtualType::_recv*/;
  variable0 = ((static_type___MMType___module_t)CALL(variable0,COLOR_static_type___MMType___module))(variable0) /*MMType::module*/;
  goto return_label4;
  return_label4: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t virtualtype___MMVirtualType___for_module(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 73, LOCATE_virtualtype___MMVirtualType___for_module};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((virtualtype___MMVirtualType___module_t)CALL( self,COLOR_static_type___MMType___module))( self) /*MMVirtualType::module*/;
  variable1 = TAG_Bool(( variable0 /*mod*/ == variable1) || (( variable0 /*mod*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*mod*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*mod*/,variable1)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*mod*/,COLOR_kernel___Object_____eqeq))( variable0 /*mod*/, variable1) /*Object::==*/)))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  self;
    goto return_label5;
  }
  variable1 = ((virtualtype___MMVirtualType___recv_t)CALL( self,COLOR_virtualtype___MMVirtualType___recv))( self) /*MMVirtualType::recv*/;
  variable1 = ((static_type___MMType___for_module_t)CALL(variable1,COLOR_static_type___MMType___for_module))(variable1,  variable0 /*mod*/) /*MMType::for_module*/;
  variable1 = ((virtualtype___MMVirtualType___adapt_to_t)CALL( self,COLOR_static_type___MMType___adapt_to))( self, variable1) /*MMVirtualType::adapt_to*/;
  goto return_label5;
  return_label5: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t virtualtype___MMVirtualType___not_for_self(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 79, LOCATE_virtualtype___MMVirtualType___not_for_self};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((type_formal___MMTypeFormal___bound_t)CALL( self,COLOR_type_formal___MMTypeFormal___bound))( self) /*MMTypeFormal::bound*/;
  variable0 = ((static_type___MMType___not_for_self_t)CALL(variable0,COLOR_static_type___MMType___not_for_self))(variable0) /*MMType::not_for_self*/;
  goto return_label6;
  return_label6: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t virtualtype___MMVirtualType___adapt_to(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 84, LOCATE_virtualtype___MMVirtualType___adapt_to};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((virtualtype___MMVirtualType___property_t)CALL( self,COLOR_virtualtype___MMVirtualType___property))( self) /*MMVirtualType::property*/;
  variable1 = ((virtualtype___MMTypeProperty___stype_for_t)CALL(variable1,COLOR_virtualtype___MMTypeProperty___stype_for))(variable1,  variable0 /*recv*/) /*MMTypeProperty::stype_for*/;
  goto return_label7;
  return_label7: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t virtualtype___MMLocalClass___virtual_type(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 91, LOCATE_virtualtype___MMLocalClass___virtual_type};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstractmetamodel___MMLocalClass___get_property_by_name_t)CALL( self,COLOR_abstractmetamodel___MMLocalClass___get_property_by_name))( self,  variable0 /*s*/) /*MMLocalClass::get_property_by_name*/;
  variable1 = variable2;
  variable2 = ((virtualtype___MMGlobalProperty___is_virtual_type_t)CALL( variable1 /*prop*/,COLOR_virtualtype___MMGlobalProperty___is_virtual_type))( variable1 /*prop*/) /*MMGlobalProperty::is_virtual_type*/;
  if (UNTAG_Bool(variable2)) { /*if*/
    variable1 =  variable1 /*prop*/;
    goto return_label8;
  }
  variable1 =  NIT_NULL /*null*/;
  goto return_label8;
  return_label8: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t virtualtype___MMLocalClass___select_virtual_type(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_virtualtype, 100, LOCATE_virtualtype___MMLocalClass___select_virtual_type};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*name*/ ==  NIT_NULL /*null*/) || (( variable0 /*name*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*name*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*name*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*name*/,COLOR_kernel___Object_____eqeq))( variable0 /*name*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable1)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_virtualtype___MMLocalClass___select_virtual_type, LOCATE_virtualtype, 103); nit_exit(1);}
  variable2 = ((virtualtype___MMLocalClass___virtual_type_t)CALL( self,COLOR_virtualtype___MMLocalClass___virtual_type))( self,  variable0 /*name*/) /*MMLocalClass::virtual_type*/;
  variable1 = variable2;
  variable2 = TAG_Bool(( variable1 /*gp*/ ==  NIT_NULL /*null*/) || (( variable1 /*gp*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable1 /*gp*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable1 /*gp*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable1 /*gp*/,COLOR_kernel___Object_____eqeq))( variable1 /*gp*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable1 =  NIT_NULL /*null*/;
    goto return_label9;
  }
  variable3 = ((inheritance___MMLocalClass_____bra_t)CALL( self,COLOR_abstractmetamodel___MMLocalClass_____bra))( self,  variable1 /*gp*/) /*MMLocalClass::[]*/;
  variable2 = variable3;
  variable3 = TAG_Bool(( variable2 /*res*/==NIT_NULL) || VAL_ISA( variable2 /*res*/, COLOR_MMTypeProperty, ID_MMTypeProperty)) /*cast MMTypeProperty*/;
  if (!UNTAG_Bool(variable3)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_virtualtype___MMLocalClass___select_virtual_type, LOCATE_virtualtype, 107); nit_exit(1);}
  variable1 =  variable2 /*res*/;
  goto return_label9;
  return_label9: while(false);
  tracehead = trace.prev;
  return variable1;
}
