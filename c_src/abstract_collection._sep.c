/* This C file is generated by NIT to compile module abstract_collection. */
#include "abstract_collection._sep.h"
val_t abstract_collection___Collection___iterator(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Collection___iterator, 42};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "iterator", LOCATE_abstract_collection, 42);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___is_empty(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Collection___is_empty, 45};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "is_empty", LOCATE_abstract_collection, 45);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___length(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Collection___length, 48};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "length", LOCATE_abstract_collection, 48);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Collection___has, 51};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "has", LOCATE_abstract_collection, 51);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Collection___has_only, 55};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "has_only", LOCATE_abstract_collection, 55);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Collection___count, 60};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "count", LOCATE_abstract_collection, 60);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Collection___first, 64};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "first", LOCATE_abstract_collection, 64);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___NaiveCollection___is_empty(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___NaiveCollection___is_empty, 72};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___NaiveCollection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*NaiveCollection::length*/;
  variable0 = TAG_Bool((variable0)==( TAG_Int(0)));
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___NaiveCollection___length(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___NaiveCollection___length, 74};
  val_t variable0;
  val_t variable1;
    val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  TAG_Int(0);
  variable1 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*NaiveCollection::iterator*/;
  while (true) { /*for*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /*for*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
    variable0 = TAG_Int(UNTAG_Int(variable0)+UNTAG_Int( variable0 /*nb*/)) /*nb*/;
    continue_2: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
  }
  break_2: while(0);
  variable0 =  variable0 /*nb*/;
  goto return_label1;
  return_label1: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___NaiveCollection___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___NaiveCollection___has, 81};
  val_t variable0;
  val_t variable1;
    val_t variable2;
    val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*NaiveCollection::iterator*/;
  while (true) { /*for*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /*for*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
    variable3 = TAG_Bool(( variable2 /*i*/ ==  variable0 /*item*/) || (( variable2 /*i*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable2 /*i*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable2 /*i*/, variable0 /*item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable2 /*i*/,COLOR_kernel___Object_____eqeq))( variable2 /*i*/,  variable0 /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable3)) { /*if*/
      variable1 =  TAG_Bool(true);
      goto return_label3;
    }
    continue_4: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
  }
  break_4: while(0);
  variable1 =  TAG_Bool(false);
  goto return_label3;
  return_label3: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___NaiveCollection___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___NaiveCollection___has_only, 87};
  val_t variable0;
  val_t variable1;
    val_t variable2;
    val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*NaiveCollection::iterator*/;
  while (true) { /*for*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /*for*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
    variable3 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable2 /*i*/ ==  variable0 /*item*/) || (( variable2 /*i*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable2 /*i*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable2 /*i*/, variable0 /*item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable2 /*i*/,COLOR_kernel___Object_____eqeq))( variable2 /*i*/,  variable0 /*item*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable3)) { /*if*/
      variable1 =  TAG_Bool(false);
      goto return_label5;
    }
    continue_6: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
  }
  break_6: while(0);
  variable1 =  TAG_Bool(true);
  goto return_label5;
  return_label5: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___NaiveCollection___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___NaiveCollection___count, 93};
  val_t variable0;
  val_t variable1;
  val_t variable2;
    val_t variable3;
    val_t variable4;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 =  TAG_Int(0);
  variable2 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*NaiveCollection::iterator*/;
  while (true) { /*for*/
    variable3 = ((abstract_collection___Iterator___is_ok_t)CALL(variable2,COLOR_abstract_collection___Iterator___is_ok))(variable2) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable3)) break; /*for*/
    variable3 = ((abstract_collection___Iterator___item_t)CALL(variable2,COLOR_abstract_collection___Iterator___item))(variable2) /*Iterator::item*/;
    variable4 = TAG_Bool(( variable3 /*i*/ ==  variable0 /*item*/) || (( variable3 /*i*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable3 /*i*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable3 /*i*/, variable0 /*item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable3 /*i*/,COLOR_kernel___Object_____eqeq))( variable3 /*i*/,  variable0 /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable4)) { /*if*/
      variable1 = TAG_Int(UNTAG_Int(variable1)+UNTAG_Int( TAG_Int(1))) /*nb*/;
    }
    continue_8: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable2,COLOR_abstract_collection___Iterator___next))(variable2) /*Iterator::next*/;
  }
  break_8: while(0);
  variable1 =  variable1 /*nb*/;
  goto return_label7;
  return_label7: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___NaiveCollection___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___NaiveCollection___first, 100};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___NaiveCollection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*NaiveCollection::length*/;
  variable0 = TAG_Bool(UNTAG_Int(variable0)>UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable0)) { fprintf(stderr, "Assert%s failed (%s: %d)\n", "", LOCATE_abstract_collection___NaiveCollection___first, 102); nit_exit(1);}
  variable0 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*NaiveCollection::iterator*/;
  variable0 = ((abstract_collection___Iterator___item_t)CALL(variable0,COLOR_abstract_collection___Iterator___item))(variable0) /*Iterator::item*/;
  goto return_label9;
  return_label9: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___Iterator___item(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Iterator___item, 110};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "item", LOCATE_abstract_collection___NaiveCollection___first, 110);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___Iterator___next(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Iterator___next, 114};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "next", LOCATE_abstract_collection___NaiveCollection___first, 114);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Iterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Iterator___is_ok, 118};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "is_ok", LOCATE_abstract_collection___NaiveCollection___first, 118);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Container___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___first, 126};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___Container___is_empty(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___is_empty, 128};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  TAG_Bool(false);
  goto return_label11;
  return_label11: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___Container___length(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___length, 130};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  TAG_Int(1);
  goto return_label12;
  return_label12: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___Container___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___has, 132};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
  variable1 = TAG_Bool((variable1 ==  variable0 /*an_item*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, variable0 /*an_item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  variable0 /*an_item*/) /*Object::==*/)))));
  goto return_label13;
  return_label13: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___Container___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___has_only, 134};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
  variable1 = TAG_Bool((variable1 ==  variable0 /*an_item*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, variable0 /*an_item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  variable0 /*an_item*/) /*Object::==*/)))));
  goto return_label14;
  return_label14: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___Container___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___count, 136};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
  variable1 = TAG_Bool((variable1 ==  variable0 /*an_item*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, variable0 /*an_item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  variable0 /*an_item*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  TAG_Int(1);
    goto return_label15;
  } else { /*if*/
    variable1 =  TAG_Int(0);
    goto return_label15;
  }
  return_label15: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___Container___iterator(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___iterator, 145};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = NEW_abstract_collection___ContainerIterator___init( self); /*new ContainerIterator[E]*/
  goto return_label16;
  return_label16: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___Container___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___init, 147};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_Container].i]) return;
  ATTR_abstract_collection___Container____item( self) /*Container::_item*/ =  variable0 /*e*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_Container].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Container___item(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___item, 150};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
}
void abstract_collection___Container___item__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Container___item__eq, 150};
  trace.prev = tracehead; tracehead = &trace;
  ATTR_abstract_collection___Container____item( self) /*Container::_item*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___ContainerIterator___item(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___ContainerIterator___item, 157};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___ContainerIterator____container( self) /*ContainerIterator::_container*/;
  variable0 = ((abstract_collection___Container___item_t)CALL(variable0,COLOR_abstract_collection___Container___item))(variable0) /*Container::item*/;
  goto return_label18;
  return_label18: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___ContainerIterator___next(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___ContainerIterator___next, 159};
  trace.prev = tracehead; tracehead = &trace;
  ATTR_abstract_collection___ContainerIterator____is_ok( self) /*ContainerIterator::_is_ok*/ =  TAG_Bool(false);
  tracehead = trace.prev;
  return;
}
void abstract_collection___ContainerIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___ContainerIterator___init, 161};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_ContainerIterator].i]) return;
  ATTR_abstract_collection___ContainerIterator____container( self) /*ContainerIterator::_container*/ =  variable0 /*c*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_ContainerIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___ContainerIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___ContainerIterator___is_ok, 163};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_abstract_collection___ContainerIterator____is_ok( self) /*ContainerIterator::_is_ok*/;
}
void abstract_collection___RemovableCollection___clear(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___RemovableCollection___clear, 171};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "clear", LOCATE_abstract_collection___ContainerIterator___init, 171);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___RemovableCollection___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___RemovableCollection___remove, 174};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "remove", LOCATE_abstract_collection___ContainerIterator___init, 174);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___RemovableCollection___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___RemovableCollection___remove_all, 177};
  val_t variable0;
    val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  while (true) { /*while*/
    variable1 = ((abstract_collection___Collection___has_t)CALL( self,COLOR_abstract_collection___Collection___has))( self,  variable0 /*item*/) /*RemovableCollection::has*/;
    if (!UNTAG_Bool(variable1)) break; /* while*/
    ((abstract_collection___RemovableCollection___remove_t)CALL( self,COLOR_abstract_collection___RemovableCollection___remove))( self,  variable0 /*item*/) /*RemovableCollection::remove*/;
    continue_22: while(0);
  }
  break_22: while(0);
  tracehead = trace.prev;
  return;
}
void abstract_collection___SimpleCollection___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___SimpleCollection___add, 184};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "add", LOCATE_abstract_collection___RemovableCollection___remove_all, 184);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___SimpleCollection___add_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___SimpleCollection___add_all, 188};
  val_t variable0;
  val_t variable1;
      val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*coll*/ ==  NIT_NULL /*null*/) || (( variable0 /*coll*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*coll*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*coll*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*coll*/,COLOR_kernel___Object_____eqeq))( variable0 /*coll*/,  NIT_NULL /*null*/) /*Collection::==*/)))))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = ((abstract_collection___Collection___iterator_t)CALL( variable0 /*coll*/,COLOR_abstract_collection___Collection___iterator))( variable0 /*coll*/) /*Collection::iterator*/;
    while (true) { /*for*/
      variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable2)) break; /*for*/
      variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
      ((abstract_collection___SimpleCollection___add_t)CALL( self,COLOR_abstract_collection___SimpleCollection___add))( self,  variable2 /*i*/) /*SimpleCollection::add*/;
      continue_24: while(0);
      ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
    }
    break_24: while(0);
  }
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Set___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Set___has_only, 204};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___Collection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*Set::length*/;
  variable1 = variable2;
  variable2 = TAG_Bool(( variable1 /*l*/)==( TAG_Int(1)));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable2 = ((abstract_collection___Collection___has_t)CALL( self,COLOR_abstract_collection___Collection___has))( self,  variable0 /*item*/) /*Set::has*/;
    variable1 = variable2;
    goto return_label25;
  } else { /*if*/
    variable2 = TAG_Bool(( variable1 /*l*/)==( TAG_Int(0)));
    if (UNTAG_Bool(variable2)) { /*if*/
      variable1 =  TAG_Bool(true);
      goto return_label25;
    } else { /*if*/
      variable1 =  TAG_Bool(false);
      goto return_label25;
    }
  }
  return_label25: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___Set___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Set___count, 216};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((abstract_collection___Collection___has_t)CALL( self,COLOR_abstract_collection___Collection___has))( self,  variable0 /*item*/) /*Set::has*/;
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  TAG_Int(1);
    goto return_label26;
  } else { /*if*/
    variable1 =  TAG_Int(0);
    goto return_label26;
  }
  return_label26: while(false);
  tracehead = trace.prev;
  return variable1;
}
void abstract_collection___Set___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Set___remove_all, 226};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  ((abstract_collection___RemovableCollection___remove_t)CALL( self,COLOR_abstract_collection___RemovableCollection___remove))( self,  variable0 /*item*/) /*Set::remove*/;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Map_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Map_____bra, 244};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "[]", LOCATE_abstract_collection___Set___remove_all, 244);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___Map_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Map_____braeq, 247};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "[]=", LOCATE_abstract_collection___Set___remove_all, 247);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Map___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Map___has_key, 250};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "has_key", LOCATE_abstract_collection___Set___remove_all, 250);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___Map___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Map___remove_at, 253};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "remove_at", LOCATE_abstract_collection___Set___remove_all, 253);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___Map___recover_with(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Map___recover_with, 256};
  val_t variable0;
  val_t variable1;
  val_t variable2;
    val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___Map___iterator_t)CALL( variable0 /*map*/,COLOR_abstract_collection___Collection___iterator))( variable0 /*map*/) /*Map::iterator*/;
  variable1 = variable2;
  while (true) { /*while*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___is_ok))( variable1 /*i*/) /*MapIterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /* while*/
    variable2 = ((abstract_collection___MapIterator___key_t)CALL( variable1 /*i*/,COLOR_abstract_collection___MapIterator___key))( variable1 /*i*/) /*MapIterator::key*/;
    variable3 = ((abstract_collection___Iterator___item_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___item))( variable1 /*i*/) /*MapIterator::item*/;
    ((abstract_collection___Map_____braeq_t)CALL( self,COLOR_abstract_collection___Map_____braeq))( self, variable2, variable3) /*Map::[]=*/;
    ((abstract_collection___Iterator___next_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___next))( variable1 /*i*/) /*MapIterator::next*/;
    continue_29: while(0);
  }
  break_29: while(0);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Map___iterator(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Map___iterator, 267};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "iterator", LOCATE_abstract_collection___Map___recover_with, 267);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___MapIterator___key(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___MapIterator___key, 273};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "key", LOCATE_abstract_collection___Map___recover_with, 273);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___MapIterator___item__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___MapIterator___item__eq, 276};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "item=", LOCATE_abstract_collection___Map___recover_with, 276);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___first, 285};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___Collection___is_empty_t)CALL( self,COLOR_abstract_collection___Collection___is_empty))( self) /*IndexedCollection::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable0)))) { fprintf(stderr, "Assert%s failed (%s: %d)\n", " 'not_empty' ", LOCATE_abstract_collection___IndexedCollection___first, 289); nit_exit(1);}
  variable0 = ((abstract_collection___Map_____bra_t)CALL( self,COLOR_abstract_collection___Map_____bra))( self,  TAG_Int(0)) /*IndexedCollection::[]*/;
  goto return_label30;
  return_label30: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___IndexedCollection___first__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___first__eq, 293};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  ((abstract_collection___Map_____braeq_t)CALL( self,COLOR_abstract_collection___Map_____braeq))( self,  TAG_Int(0),  variable0 /*item*/) /*IndexedCollection::[]=*/;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___last(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___last, 298};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___Collection___is_empty_t)CALL( self,COLOR_abstract_collection___Collection___is_empty))( self) /*IndexedCollection::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable0)))) { fprintf(stderr, "Assert%s failed (%s: %d)\n", " 'not_empty' ", LOCATE_abstract_collection___IndexedCollection___last, 302); nit_exit(1);}
  variable0 = ((abstract_collection___Collection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*IndexedCollection::length*/;
  variable0 = TAG_Int(UNTAG_Int(variable0)-UNTAG_Int( TAG_Int(1)));
  variable0 = ((abstract_collection___Map_____bra_t)CALL( self,COLOR_abstract_collection___Map_____bra))( self, variable0) /*IndexedCollection::[]*/;
  goto return_label32;
  return_label32: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___IndexedCollection___last__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___last__eq, 306};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___Collection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*IndexedCollection::length*/;
  variable1 = variable2;
  variable2 = TAG_Bool(UNTAG_Int( variable1 /*l*/)>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable2 = TAG_Int(UNTAG_Int( variable1 /*l*/)-UNTAG_Int( TAG_Int(1)));
    ((abstract_collection___Map_____braeq_t)CALL( self,COLOR_abstract_collection___Map_____braeq))( self, variable2,  variable0 /*item*/) /*IndexedCollection::[]=*/;
  } else { /*if*/
    ((abstract_collection___Map_____braeq_t)CALL( self,COLOR_abstract_collection___Map_____braeq))( self,  TAG_Int(0),  variable0 /*item*/) /*IndexedCollection::[]=*/;
  }
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___add, 318};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  ((abstract_collection___IndexedCollection___push_t)CALL( self,COLOR_abstract_collection___IndexedCollection___push))( self,  variable0 /*e*/) /*IndexedCollection::push*/;
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___push(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___push, 321};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "push", LOCATE_abstract_collection___IndexedCollection___add, 321);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___append(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___append, 324};
  val_t variable0;
  val_t variable1;
      val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*coll*/ ==  NIT_NULL /*null*/) || (( variable0 /*coll*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*coll*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*coll*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*coll*/,COLOR_kernel___Object_____eqeq))( variable0 /*coll*/,  NIT_NULL /*null*/) /*Collection::==*/)))))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = ((abstract_collection___Collection___iterator_t)CALL( variable0 /*coll*/,COLOR_abstract_collection___Collection___iterator))( variable0 /*coll*/) /*Collection::iterator*/;
    while (true) { /*for*/
      variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable2)) break; /*for*/
      variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
      ((abstract_collection___IndexedCollection___push_t)CALL( self,COLOR_abstract_collection___IndexedCollection___push))( self,  variable2 /*i*/) /*IndexedCollection::push*/;
      continue_36: while(0);
      ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
    }
    break_36: while(0);
  }
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___pop(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___pop, 327};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "pop", LOCATE_abstract_collection___IndexedCollection___append, 327);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___IndexedCollection___unshift(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___unshift, 330};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "unshift", LOCATE_abstract_collection___IndexedCollection___append, 330);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___shift(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___shift, 333};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "shift", LOCATE_abstract_collection___IndexedCollection___append, 333);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedCollection___index_of(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___index_of, 337};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___IndexedCollection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*IndexedCollection::iterator*/;
  variable1 = variable2;
  while (true) { /*while*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___is_ok))( variable1 /*i*/) /*IndexedIterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /* while*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___item))( variable1 /*i*/) /*IndexedIterator::item*/;
    variable2 = TAG_Bool((variable2 ==  variable0 /*item*/) || ((variable2 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable2, variable0 /*item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))(variable2,  variable0 /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable2)) { /*if*/
      variable2 = ((abstract_collection___IndexedIterator___index_t)CALL( variable1 /*i*/,COLOR_abstract_collection___IndexedIterator___index))( variable1 /*i*/) /*IndexedIterator::index*/;
      variable1 = variable2;
      goto return_label37;
    }
    ((abstract_collection___Iterator___next_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___next))( variable1 /*i*/) /*IndexedIterator::next*/;
    continue_38: while(0);
  }
  break_38: while(0);
  variable2 = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable1 = variable2;
  goto return_label37;
  return_label37: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___IndexedCollection___iterator(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedCollection___iterator, 349};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "iterator", LOCATE_abstract_collection___IndexedCollection___index_of, 349);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedIterator___index(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedIterator___index, 355};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "index", LOCATE_abstract_collection___IndexedCollection___index_of, 355);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedIterator___key(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___IndexedIterator___key, 358};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___IndexedIterator___index_t)CALL( self,COLOR_abstract_collection___IndexedIterator___index))( self) /*IndexedIterator::index*/;
  goto return_label39;
  return_label39: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___CoupleMap___couple_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMap___couple_at, 365};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called (%s: %d)\n", "couple_at", LOCATE_abstract_collection___IndexedIterator___key, 365);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___CoupleMap_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMap_____bra, 369};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___CoupleMap___couple_at_t)CALL( self,COLOR_abstract_collection___CoupleMap___couple_at))( self,  variable0 /*key*/) /*CoupleMap::couple_at*/;
  variable1 = variable2;
  variable2 = TAG_Bool(( variable1 /*c*/ ==  NIT_NULL /*null*/) || (( variable1 /*c*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable1 /*c*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable1 /*c*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable1 /*c*/,COLOR_kernel___Object_____eqeq))( variable1 /*c*/,  NIT_NULL /*null*/) /*Couple::==*/)))));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable1 =  NIT_NULL /*null*/;
    goto return_label40;
  } else { /*if*/
    variable2 = ((abstract_collection___Couple___second_t)CALL( variable1 /*c*/,COLOR_abstract_collection___Couple___second))( variable1 /*c*/) /*Couple::second*/;
    variable1 = variable2;
    goto return_label40;
  }
  return_label40: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___CoupleMap___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMap___has_key, 379};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((abstract_collection___CoupleMap___couple_at_t)CALL( self,COLOR_abstract_collection___CoupleMap___couple_at))( self,  variable0 /*key*/) /*CoupleMap::couple_at*/;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Couple::==*/)))))));
  goto return_label41;
  return_label41: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___CoupleMapIterator___item(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMapIterator___item, 387};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  variable0 = ((abstract_collection___Iterator___item_t)CALL(variable0,COLOR_abstract_collection___Iterator___item))(variable0) /*Iterator::item*/;
  variable0 = ((abstract_collection___Couple___second_t)CALL(variable0,COLOR_abstract_collection___Couple___second))(variable0) /*Couple::second*/;
  goto return_label42;
  return_label42: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___CoupleMapIterator___item__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMapIterator___item__eq, 389};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  variable1 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
  ((abstract_collection___Couple___second__eq_t)CALL(variable1,COLOR_abstract_collection___Couple___second__eq))(variable1,  variable0 /*e*/) /*Couple::second=*/;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___CoupleMapIterator___key(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMapIterator___key, 391};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  variable0 = ((abstract_collection___Iterator___item_t)CALL(variable0,COLOR_abstract_collection___Iterator___item))(variable0) /*Iterator::item*/;
  variable0 = ((abstract_collection___Couple___first_t)CALL(variable0,COLOR_abstract_collection___Couple___first))(variable0) /*Couple::first*/;
  goto return_label44;
  return_label44: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___CoupleMapIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMapIterator___is_ok, 393};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  variable0 = ((abstract_collection___Iterator___is_ok_t)CALL(variable0,COLOR_abstract_collection___Iterator___is_ok))(variable0) /*Iterator::is_ok*/;
  goto return_label45;
  return_label45: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___CoupleMapIterator___next(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMapIterator___next, 395};
  val_t variable0;
    val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  ((abstract_collection___Iterator___next_t)CALL(variable0,COLOR_abstract_collection___Iterator___next))(variable0) /*Iterator::next*/;
  while (true) { /*while*/
    variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
    variable0 = ((abstract_collection___Iterator___is_ok_t)CALL(variable0,COLOR_abstract_collection___Iterator___is_ok))(variable0) /*Iterator::is_ok*/;
    variable1 = variable0;
    if (UNTAG_Bool(variable1)) { /* and */
      variable1 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
      variable1 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
      variable1 = TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Couple::==*/)))));
    }
    variable0 = variable1;
    if (!UNTAG_Bool(variable0)) break; /* while*/
    variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
    ((abstract_collection___Iterator___next_t)CALL(variable0,COLOR_abstract_collection___Iterator___next))(variable0) /*Iterator::next*/;
    continue_47: while(0);
  }
  break_47: while(0);
  tracehead = trace.prev;
  return;
}
void abstract_collection___CoupleMapIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___CoupleMapIterator___init, 403};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_CoupleMapIterator].i]) return;
  ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/ =  variable0 /*i*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_CoupleMapIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Couple___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Couple___first, 411};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Couple____first( self) /*Couple::_first*/;
}
void abstract_collection___Couple___first__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Couple___first__eq, 411};
  trace.prev = tracehead; tracehead = &trace;
  ATTR_abstract_collection___Couple____first( self) /*Couple::_first*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Couple___second(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Couple___second, 414};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Couple____second( self) /*Couple::_second*/;
}
void abstract_collection___Couple___second__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Couple___second__eq, 414};
  trace.prev = tracehead; tracehead = &trace;
  ATTR_abstract_collection___Couple____second( self) /*Couple::_second*/ =  param0;
  tracehead = trace.prev;
  return;
}
void abstract_collection___Couple___init(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection___Couple___init, 417};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 =  param1;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_Couple].i]) return;
  ATTR_abstract_collection___Couple____first( self) /*Couple::_first*/ =  variable0 /*f*/;
  ATTR_abstract_collection___Couple____second( self) /*Couple::_second*/ =  variable1 /*s*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_Couple].i] = 1;
  tracehead = trace.prev;
  return;
}
