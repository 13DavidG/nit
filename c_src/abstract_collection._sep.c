/* This C file is generated by NIT to compile module abstract_collection. */
#include "abstract_collection._sep.h"
val_t abstract_collection___Collection___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 42, LOCATE_abstract_collection___Collection___iterator};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 42);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 45, LOCATE_abstract_collection___Collection___is_empty};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 45);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 48, LOCATE_abstract_collection___Collection___length};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 48);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 51, LOCATE_abstract_collection___Collection___has};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 51);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 55, LOCATE_abstract_collection___Collection___has_only};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 55);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 60, LOCATE_abstract_collection___Collection___count};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 60);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 64, LOCATE_abstract_collection___Collection___first};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 64);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___NaiveCollection___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 72, LOCATE_abstract_collection___NaiveCollection___is_empty};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*NaiveCollection::length*/;
  /* Register variable[2]: Result */
  variable[2] = TAG_Bool((variable[2])==( TAG_Int(0)));
  variable[1] = variable[2];
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___NaiveCollection___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 74, LOCATE_abstract_collection___NaiveCollection___length};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Local variable */
  variable[2] =  TAG_Int(0);
  /* Register variable[3]: For iterator */
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[0])(variable[0]) /*Collection::iterator*/;
  while (true) { /*for*/
    /* Register variable[4]: For 'is_ok' result */
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*Iterator::item*/ /* Ensure var: For item*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    variable[2] = TAG_Int(UNTAG_Int(variable[2])+UNTAG_Int( variable[2] /*nb*/)) /*nb*/;
    continue_2: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*Iterator::next*/;
  }
  break_2: while(0);
  variable[1] =  variable[2] /*nb*/;
  goto return_label1;
  return_label1: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___NaiveCollection___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 81, LOCATE_abstract_collection___NaiveCollection___has};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: For iterator */
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[0])(variable[0]) /*Collection::iterator*/;
  while (true) { /*for*/
    /* Register variable[4]: For 'is_ok' result */
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*Iterator::item*/ /* Ensure var: For item*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Result */
    variable[6] = TAG_Bool(( variable[5] /*i*/ ==  variable[1] /*item*/) || (( variable[5] /*i*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*i*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*i*/, variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*i*/)( variable[5] /*i*/,  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[2] =  TAG_Bool(true);
      goto return_label3;
    }
    continue_4: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*Iterator::next*/;
  }
  break_4: while(0);
  variable[2] =  TAG_Bool(false);
  goto return_label3;
  return_label3: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___NaiveCollection___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 87, LOCATE_abstract_collection___NaiveCollection___has_only};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: For iterator */
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[0])(variable[0]) /*Collection::iterator*/;
  while (true) { /*for*/
    /* Register variable[4]: For 'is_ok' result */
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*Iterator::item*/ /* Ensure var: For item*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Result */
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[5] /*i*/ ==  variable[1] /*item*/) || (( variable[5] /*i*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*i*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*i*/, variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*i*/)( variable[5] /*i*/,  variable[1] /*item*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label5;
    }
    continue_6: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*Iterator::next*/;
  }
  break_6: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label5;
  return_label5: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___NaiveCollection___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 93, LOCATE_abstract_collection___NaiveCollection___count};
  val_t variable[8];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  variable[3] =  TAG_Int(0);
  /* Register variable[4]: For iterator */
  variable[4] = CALL_abstract_collection___Collection___iterator(variable[0])(variable[0]) /*Collection::iterator*/;
  while (true) { /*for*/
    /* Register variable[5]: For 'is_ok' result */
    variable[5] = CALL_abstract_collection___Iterator___is_ok(variable[4])(variable[4]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[5])) break; /*for*/
    variable[5] = CALL_abstract_collection___Iterator___item(variable[4])(variable[4]) /*Iterator::item*/ /* Ensure var: For item*/;
    /* Register variable[6]: Local variable */
    variable[6] = variable[5];
    /* Register variable[7]: Result */
    variable[7] = TAG_Bool(( variable[6] /*i*/ ==  variable[1] /*item*/) || (( variable[6] /*i*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[6] /*i*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[6] /*i*/, variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[6] /*i*/)( variable[6] /*i*/,  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[7])) { /*if*/
      variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*nb*/;
    }
    continue_8: while(0);
    CALL_abstract_collection___Iterator___next(variable[4])(variable[4]) /*Iterator::next*/;
  }
  break_8: while(0);
  variable[2] =  variable[3] /*nb*/;
  goto return_label7;
  return_label7: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___NaiveCollection___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 100, LOCATE_abstract_collection___NaiveCollection___first};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*NaiveCollection::length*/;
  /* Register variable[2]: Result */
  variable[2] = TAG_Bool(UNTAG_Int(variable[2])>UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[2])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___NaiveCollection___first, LOCATE_abstract_collection, 102); nit_exit(1);}
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___iterator(variable[0])(variable[0]) /*Collection::iterator*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Iterator___item(variable[2])(variable[2]) /*Iterator::item*/;
  variable[1] = variable[2];
  goto return_label9;
  return_label9: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___Iterator___item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 110, LOCATE_abstract_collection___Iterator___item};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 110);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___Iterator___next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 114, LOCATE_abstract_collection___Iterator___next};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 114);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Iterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 118, LOCATE_abstract_collection___Iterator___is_ok};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 118);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Container___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 145, LOCATE_abstract_collection___Container___iterator};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = NEW_ContainerIterator_abstract_collection___ContainerIterator___init(variable[0]) /*new ContainerIterator[E]*/;
  variable[1] = variable[2];
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___Container___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 128, LOCATE_abstract_collection___Container___is_empty};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  TAG_Bool(false);
  goto return_label11;
  return_label11: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___Container___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 130, LOCATE_abstract_collection___Container___length};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  variable[1] =  TAG_Int(1);
  goto return_label12;
  return_label12: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___Container___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 132, LOCATE_abstract_collection___Container___has};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_abstract_collection___Container____item(variable[0]) /*Container::_item*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  variable[1] /*an_item*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], variable[1] /*an_item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  variable[1] /*an_item*/) /*Object::==*/)))));
  variable[2] = variable[3];
  goto return_label13;
  return_label13: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___Container___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 134, LOCATE_abstract_collection___Container___has_only};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_abstract_collection___Container____item(variable[0]) /*Container::_item*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  variable[1] /*an_item*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], variable[1] /*an_item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  variable[1] /*an_item*/) /*Object::==*/)))));
  variable[2] = variable[3];
  goto return_label14;
  return_label14: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___Container___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 136, LOCATE_abstract_collection___Container___count};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_abstract_collection___Container____item(variable[0]) /*Container::_item*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool((variable[3] ==  variable[1] /*an_item*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], variable[1] /*an_item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  variable[1] /*an_item*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[2] =  TAG_Int(1);
    goto return_label15;
  } else { /*if*/
    variable[2] =  TAG_Int(0);
    goto return_label15;
  }
  return_label15: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___Container___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 126, LOCATE_abstract_collection___Container___first};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_abstract_collection___Container____item(variable[0]) /*Container::_item*/;
  variable[1] = variable[2];
  goto return_label16;
  return_label16: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void abstract_collection___Container___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 147, LOCATE_abstract_collection___Container___init};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Container].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  ATTR_abstract_collection___Container____item(variable[0]) /*Container::_item*/ =  variable[1] /*e*/;
  return_label17: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Container].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Container___item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 150, LOCATE_abstract_collection___Container___item};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
}
void abstract_collection___Container___item__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 150, LOCATE_abstract_collection___Container___item__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  ATTR_abstract_collection___Container____item( self) /*Container::_item*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___ContainerIterator___item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 157, LOCATE_abstract_collection___ContainerIterator___item};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_abstract_collection___ContainerIterator____container(variable[0]) /*ContainerIterator::_container*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Container___item(variable[2])(variable[2]) /*Container::item*/;
  variable[1] = variable[2];
  goto return_label18;
  return_label18: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void abstract_collection___ContainerIterator___next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 159, LOCATE_abstract_collection___ContainerIterator___next};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  ATTR_abstract_collection___ContainerIterator____is_ok(variable[0]) /*ContainerIterator::_is_ok*/ =  TAG_Bool(false);
  return_label19: while(false);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___ContainerIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 163, LOCATE_abstract_collection___ContainerIterator___is_ok};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  tracehead = trace.prev;
  return ATTR_abstract_collection___ContainerIterator____is_ok( self) /*ContainerIterator::_is_ok*/;
}
void abstract_collection___ContainerIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 161, LOCATE_abstract_collection___ContainerIterator___init};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ContainerIterator].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  ATTR_abstract_collection___ContainerIterator____container(variable[0]) /*ContainerIterator::_container*/ =  variable[1] /*c*/;
  return_label20: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ContainerIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
void abstract_collection___RemovableCollection___clear(val_t  self) {
  struct trace_t trace = {NULL, NULL, 171, LOCATE_abstract_collection___RemovableCollection___clear};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 171);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___RemovableCollection___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 174, LOCATE_abstract_collection___RemovableCollection___remove};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 174);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___RemovableCollection___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 177, LOCATE_abstract_collection___RemovableCollection___remove_all};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  while (true) { /*while*/
    /* Register variable[3]: Result */
    variable[3] = CALL_abstract_collection___Collection___has(variable[0])(variable[0],  variable[1] /*item*/) /*Collection::has*/;
    if (!UNTAG_Bool(variable[3])) break; /* while*/
    CALL_abstract_collection___RemovableCollection___remove(variable[0])(variable[0],  variable[1] /*item*/) /*RemovableCollection::remove*/;
    continue_22: while(0);
  }
  break_22: while(0);
  return_label21: while(false);
  tracehead = trace.prev;
  return;
}
void abstract_collection___SimpleCollection___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 184, LOCATE_abstract_collection___SimpleCollection___add};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 184);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___SimpleCollection___add_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 188, LOCATE_abstract_collection___SimpleCollection___add_all};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[1] /*coll*/ ==  NIT_NULL /*null*/) || (( variable[1] /*coll*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[1] /*coll*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[1] /*coll*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[1] /*coll*/)( variable[1] /*coll*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: For iterator */
    variable[3] = CALL_abstract_collection___Collection___iterator( variable[1] /*coll*/)( variable[1] /*coll*/) /*Collection::iterator*/;
    while (true) { /*for*/
      /* Register variable[4]: For 'is_ok' result */
      variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable[4])) break; /*for*/
      variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*Iterator::item*/ /* Ensure var: For item*/;
      /* Register variable[5]: Local variable */
      variable[5] = variable[4];
      CALL_abstract_collection___SimpleCollection___add(variable[0])(variable[0],  variable[5] /*i*/) /*SimpleCollection::add*/;
      continue_24: while(0);
      CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*Iterator::next*/;
    }
    break_24: while(0);
  }
  return_label23: while(false);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Set___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 204, LOCATE_abstract_collection___Set___has_only};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*Collection::length*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[3] /*l*/)==( TAG_Int(1)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Collection___has(variable[0])(variable[0],  variable[1] /*item*/) /*Collection::has*/;
    variable[2] = variable[4];
    goto return_label25;
  } else { /*if*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(( variable[3] /*l*/)==( TAG_Int(0)));
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[2] =  TAG_Bool(true);
      goto return_label25;
    } else { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label25;
    }
  }
  return_label25: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___Set___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 216, LOCATE_abstract_collection___Set___count};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___Collection___has(variable[0])(variable[0],  variable[1] /*item*/) /*Collection::has*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[2] =  TAG_Int(1);
    goto return_label26;
  } else { /*if*/
    variable[2] =  TAG_Int(0);
    goto return_label26;
  }
  return_label26: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void abstract_collection___Set___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 226, LOCATE_abstract_collection___Set___remove_all};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_abstract_collection___RemovableCollection___remove(variable[0])(variable[0],  variable[1] /*item*/) /*RemovableCollection::remove*/;
  return_label27: while(false);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___MapRead___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 238, LOCATE_abstract_collection___MapRead___iterator};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 238);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___MapRead_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 232, LOCATE_abstract_collection___MapRead_____bra};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 232);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___MapRead___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 235, LOCATE_abstract_collection___MapRead___has_key};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 235);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___Map_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 256, LOCATE_abstract_collection___Map_____braeq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 256);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___Map___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 259, LOCATE_abstract_collection___Map___remove_at};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 259);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___Map___recover_with(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 262, LOCATE_abstract_collection___Map___recover_with};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___iterator( variable[1] /*map*/)( variable[1] /*map*/) /*MapRead::iterator*/;
  variable[3] = variable[4];
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Iterator___is_ok( variable[3] /*i*/)( variable[3] /*i*/) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___MapIterator___key( variable[3] /*i*/)( variable[3] /*i*/) /*MapIterator::key*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___Iterator___item( variable[3] /*i*/)( variable[3] /*i*/) /*Iterator::item*/;
    CALL_abstract_collection___Map_____braeq(variable[0])(variable[0], variable[4], variable[5]) /*Map::[]=*/;
    CALL_abstract_collection___Iterator___next( variable[3] /*i*/)( variable[3] /*i*/) /*Iterator::next*/;
    continue_29: while(0);
  }
  break_29: while(0);
  return_label28: while(false);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___MapIterator___key(val_t  self) {
  struct trace_t trace = {NULL, NULL, 277, LOCATE_abstract_collection___MapIterator___key};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 277);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedCollectionRead___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 316, LOCATE_abstract_collection___IndexedCollectionRead___iterator};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 316);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedCollectionRead___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 288, LOCATE_abstract_collection___IndexedCollectionRead___first};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[0])(variable[0]) /*Collection::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[2])))) { fprintf(stderr, "Assert%s failed", " 'not_empty' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollectionRead___first, LOCATE_abstract_collection, 292); nit_exit(1);}
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  TAG_Int(0)) /*MapRead::[]*/;
  variable[1] = variable[2];
  goto return_label30;
  return_label30: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___IndexedCollectionRead___last(val_t  self) {
  struct trace_t trace = {NULL, NULL, 296, LOCATE_abstract_collection___IndexedCollectionRead___last};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[0])(variable[0]) /*Collection::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[2])))) { fprintf(stderr, "Assert%s failed", " 'not_empty' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollectionRead___last, LOCATE_abstract_collection, 300); nit_exit(1);}
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*Collection::length*/;
  /* Register variable[2]: Result */
  variable[2] = TAG_Int(UNTAG_Int(variable[2])-UNTAG_Int( TAG_Int(1)));
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0], variable[2]) /*MapRead::[]*/;
  variable[1] = variable[2];
  goto return_label31;
  return_label31: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___IndexedCollectionRead___index_of(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 304, LOCATE_abstract_collection___IndexedCollectionRead___index_of};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___iterator(variable[0])(variable[0]) /*IndexedCollectionRead::iterator*/;
  variable[3] = variable[4];
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Iterator___is_ok( variable[3] /*i*/)( variable[3] /*i*/) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Iterator___item( variable[3] /*i*/)( variable[3] /*i*/) /*Iterator::item*/;
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool((variable[4] ==  variable[1] /*item*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[4])) { /*if*/
      /* Register variable[4]: Result */
      variable[4] = CALL_abstract_collection___IndexedIterator___index( variable[3] /*i*/)( variable[3] /*i*/) /*IndexedIterator::index*/;
      variable[2] = variable[4];
      goto return_label32;
    }
    CALL_abstract_collection___Iterator___next( variable[3] /*i*/)( variable[3] /*i*/) /*Iterator::next*/;
    continue_33: while(0);
  }
  break_33: while(0);
  /* Register variable[4]: Result */
  variable[4] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable[2] = variable[4];
  goto return_label32;
  return_label32: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void abstract_collection___IndexedCollection___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 342, LOCATE_abstract_collection___IndexedCollection___add};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_abstract_collection___IndexedCollection___push(variable[0])(variable[0],  variable[1] /*e*/) /*IndexedCollection::push*/;
  return_label34: while(false);
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___first__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 325, LOCATE_abstract_collection___IndexedCollection___first__eq};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_abstract_collection___Map_____braeq(variable[0])(variable[0],  TAG_Int(0),  variable[1] /*item*/) /*Map::[]=*/;
  return_label35: while(false);
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___last__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 330, LOCATE_abstract_collection___IndexedCollection___last__eq};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*Collection::length*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*l*/)>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Int(UNTAG_Int( variable[3] /*l*/)-UNTAG_Int( TAG_Int(1)));
    CALL_abstract_collection___Map_____braeq(variable[0])(variable[0], variable[4],  variable[1] /*item*/) /*Map::[]=*/;
  } else { /*if*/
    CALL_abstract_collection___Map_____braeq(variable[0])(variable[0],  TAG_Int(0),  variable[1] /*item*/) /*Map::[]=*/;
  }
  return_label36: while(false);
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___push(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 345, LOCATE_abstract_collection___IndexedCollection___push};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 345);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___append(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 348, LOCATE_abstract_collection___IndexedCollection___append};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[1] /*coll*/ ==  NIT_NULL /*null*/) || (( variable[1] /*coll*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[1] /*coll*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[1] /*coll*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[1] /*coll*/)( variable[1] /*coll*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[3])) { /*if*/
    /* Register variable[3]: For iterator */
    variable[3] = CALL_abstract_collection___Collection___iterator( variable[1] /*coll*/)( variable[1] /*coll*/) /*Collection::iterator*/;
    while (true) { /*for*/
      /* Register variable[4]: For 'is_ok' result */
      variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable[4])) break; /*for*/
      variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*Iterator::item*/ /* Ensure var: For item*/;
      /* Register variable[5]: Local variable */
      variable[5] = variable[4];
      CALL_abstract_collection___IndexedCollection___push(variable[0])(variable[0],  variable[5] /*i*/) /*IndexedCollection::push*/;
      continue_38: while(0);
      CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*Iterator::next*/;
    }
    break_38: while(0);
  }
  return_label37: while(false);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___pop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 351, LOCATE_abstract_collection___IndexedCollection___pop};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 351);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___IndexedCollection___unshift(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 354, LOCATE_abstract_collection___IndexedCollection___unshift};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 354);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___shift(val_t  self) {
  struct trace_t trace = {NULL, NULL, 357, LOCATE_abstract_collection___IndexedCollection___shift};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 357);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedIterator___key(val_t  self) {
  struct trace_t trace = {NULL, NULL, 369, LOCATE_abstract_collection___IndexedIterator___key};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___IndexedIterator___index(variable[0])(variable[0]) /*IndexedIterator::index*/;
  variable[1] = variable[2];
  goto return_label39;
  return_label39: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___IndexedIterator___index(val_t  self) {
  struct trace_t trace = {NULL, NULL, 366, LOCATE_abstract_collection___IndexedIterator___index};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 366);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___CoupleMap_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 380, LOCATE_abstract_collection___CoupleMap_____bra};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___CoupleMap___couple_at(variable[0])(variable[0],  variable[1] /*key*/) /*CoupleMap::couple_at*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(( variable[3] /*c*/ ==  NIT_NULL /*null*/) || (( variable[3] /*c*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[3] /*c*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*c*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[3] /*c*/)( variable[3] /*c*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    fprintf(stderr, "Aborted"); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___CoupleMap_____bra, LOCATE_abstract_collection, 384); nit_exit(1);
  } else { /*if*/
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Couple___second( variable[3] /*c*/)( variable[3] /*c*/) /*Couple::second*/;
    variable[2] = variable[4];
    goto return_label40;
  }
  return_label40: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___CoupleMap___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 390, LOCATE_abstract_collection___CoupleMap___has_key};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___CoupleMap___couple_at(variable[0])(variable[0],  variable[1] /*key*/) /*CoupleMap::couple_at*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[3])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[3])(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))))));
  variable[2] = variable[3];
  goto return_label41;
  return_label41: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t abstract_collection___CoupleMap___couple_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 376, LOCATE_abstract_collection___CoupleMap___couple_at};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 376);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___CoupleMapIterator___item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 398, LOCATE_abstract_collection___CoupleMapIterator___item};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_abstract_collection___CoupleMapIterator____iter(variable[0]) /*CoupleMapIterator::_iter*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Iterator___item(variable[2])(variable[2]) /*Iterator::item*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Couple___second(variable[2])(variable[2]) /*Couple::second*/;
  variable[1] = variable[2];
  goto return_label42;
  return_label42: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void abstract_collection___CoupleMapIterator___next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 406, LOCATE_abstract_collection___CoupleMapIterator___next};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_abstract_collection___CoupleMapIterator____iter(variable[0]) /*CoupleMapIterator::_iter*/;
  CALL_abstract_collection___Iterator___next(variable[2])(variable[2]) /*Iterator::next*/;
  while (true) { /*while*/
    /* Register variable[2]: Result */
    variable[2] = ATTR_abstract_collection___CoupleMapIterator____iter(variable[0]) /*CoupleMapIterator::_iter*/;
    /* Register variable[2]: Result */
    variable[2] = CALL_abstract_collection___Iterator___is_ok(variable[2])(variable[2]) /*Iterator::is_ok*/;
    /* Ensure var variable[2]: Left 'and' operand*/
    if (UNTAG_Bool(variable[2])) { /* and */
      /* Register variable[2]: Result */
      variable[2] = ATTR_abstract_collection___CoupleMapIterator____iter(variable[0]) /*CoupleMapIterator::_iter*/;
      /* Register variable[2]: Result */
      variable[2] = CALL_abstract_collection___Iterator___item(variable[2])(variable[2]) /*Iterator::item*/;
      /* Register variable[2]: Result */
      variable[2] = TAG_Bool((variable[2] ==  NIT_NULL /*null*/) || ((variable[2] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[2])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[2], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[2])(variable[2],  NIT_NULL /*null*/) /*Object::==*/)))));
    }
    /* Register variable[2]: Result */
    if (!UNTAG_Bool(variable[2])) break; /* while*/
    /* Register variable[2]: Result */
    variable[2] = ATTR_abstract_collection___CoupleMapIterator____iter(variable[0]) /*CoupleMapIterator::_iter*/;
    CALL_abstract_collection___Iterator___next(variable[2])(variable[2]) /*Iterator::next*/;
    continue_44: while(0);
  }
  break_44: while(0);
  return_label43: while(false);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___CoupleMapIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 404, LOCATE_abstract_collection___CoupleMapIterator___is_ok};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_abstract_collection___CoupleMapIterator____iter(variable[0]) /*CoupleMapIterator::_iter*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Iterator___is_ok(variable[2])(variable[2]) /*Iterator::is_ok*/;
  variable[1] = variable[2];
  goto return_label45;
  return_label45: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t abstract_collection___CoupleMapIterator___key(val_t  self) {
  struct trace_t trace = {NULL, NULL, 402, LOCATE_abstract_collection___CoupleMapIterator___key};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_abstract_collection___CoupleMapIterator____iter(variable[0]) /*CoupleMapIterator::_iter*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Iterator___item(variable[2])(variable[2]) /*Iterator::item*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Couple___first(variable[2])(variable[2]) /*Couple::first*/;
  variable[1] = variable[2];
  goto return_label46;
  return_label46: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void abstract_collection___CoupleMapIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 414, LOCATE_abstract_collection___CoupleMapIterator___init};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_CoupleMapIterator].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  ATTR_abstract_collection___CoupleMapIterator____iter(variable[0]) /*CoupleMapIterator::_iter*/ =  variable[1] /*i*/;
  return_label47: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_CoupleMapIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Couple___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 422, LOCATE_abstract_collection___Couple___first};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Couple____first( self) /*Couple::_first*/;
}
void abstract_collection___Couple___first__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 422, LOCATE_abstract_collection___Couple___first__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  ATTR_abstract_collection___Couple____first( self) /*Couple::_first*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Couple___second(val_t  self) {
  struct trace_t trace = {NULL, NULL, 425, LOCATE_abstract_collection___Couple___second};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Couple____second( self) /*Couple::_second*/;
}
void abstract_collection___Couple___second__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 425, LOCATE_abstract_collection___Couple___second__eq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  ATTR_abstract_collection___Couple____second( self) /*Couple::_second*/ =  param0;
  tracehead = trace.prev;
  return;
}
void abstract_collection___Couple___init(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 428, LOCATE_abstract_collection___Couple___init};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_abstract_collection;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Couple].i]) return;
  /* Register variable[3]: Method return value and escape marker */
  ATTR_abstract_collection___Couple____first(variable[0]) /*Couple::_first*/ =  variable[1] /*f*/;
  ATTR_abstract_collection___Couple____second(variable[0]) /*Couple::_second*/ =  variable[2] /*s*/;
  return_label48: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Couple].i] = 1;
  tracehead = trace.prev;
  return;
}
