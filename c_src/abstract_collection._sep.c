/* This C file is generated by NIT to compile module abstract_collection. */
#include "abstract_collection._sep.h"
val_t abstract_collection___Collection___iterator(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 42, LOCATE_abstract_collection___Collection___iterator};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 42);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___is_empty(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 45, LOCATE_abstract_collection___Collection___is_empty};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 45);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___length(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 48, LOCATE_abstract_collection___Collection___length};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 48);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 51, LOCATE_abstract_collection___Collection___has};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 51);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 55, LOCATE_abstract_collection___Collection___has_only};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 55);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 60, LOCATE_abstract_collection___Collection___count};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 60);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Collection___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 64, LOCATE_abstract_collection___Collection___first};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_abstract_collection, 64);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___NaiveCollection___is_empty(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 72, LOCATE_abstract_collection___NaiveCollection___is_empty};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___NaiveCollection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*NaiveCollection::length*/;
  variable0 = TAG_Bool((variable0)==( TAG_Int(0)));
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___NaiveCollection___length(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 74, LOCATE_abstract_collection___NaiveCollection___length};
  val_t variable0;
  val_t variable1;
    val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  TAG_Int(0);
  variable1 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*Collection::iterator*/;
  while (true) { /*for*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /*for*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
    variable0 = TAG_Int(UNTAG_Int(variable0)+UNTAG_Int( variable0 /*nb*/)) /*nb*/;
    continue_2: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
  }
  break_2: while(0);
  variable0 =  variable0 /*nb*/;
  goto return_label1;
  return_label1: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___NaiveCollection___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 81, LOCATE_abstract_collection___NaiveCollection___has};
  val_t variable0;
  val_t variable1;
    val_t variable2;
    val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*Collection::iterator*/;
  while (true) { /*for*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /*for*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
    variable3 = TAG_Bool(( variable2 /*i*/ ==  variable0 /*item*/) || (( variable2 /*i*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable2 /*i*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable2 /*i*/, variable0 /*item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable2 /*i*/,COLOR_kernel___Object_____eqeq))( variable2 /*i*/,  variable0 /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable3)) { /*if*/
      variable1 =  TAG_Bool(true);
      goto return_label3;
    }
    continue_4: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
  }
  break_4: while(0);
  variable1 =  TAG_Bool(false);
  goto return_label3;
  return_label3: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___NaiveCollection___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 87, LOCATE_abstract_collection___NaiveCollection___has_only};
  val_t variable0;
  val_t variable1;
    val_t variable2;
    val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*Collection::iterator*/;
  while (true) { /*for*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /*for*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
    variable3 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable2 /*i*/ ==  variable0 /*item*/) || (( variable2 /*i*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable2 /*i*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable2 /*i*/, variable0 /*item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable2 /*i*/,COLOR_kernel___Object_____eqeq))( variable2 /*i*/,  variable0 /*item*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable3)) { /*if*/
      variable1 =  TAG_Bool(false);
      goto return_label5;
    }
    continue_6: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
  }
  break_6: while(0);
  variable1 =  TAG_Bool(true);
  goto return_label5;
  return_label5: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___NaiveCollection___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 93, LOCATE_abstract_collection___NaiveCollection___count};
  val_t variable0;
  val_t variable1;
  val_t variable2;
    val_t variable3;
    val_t variable4;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 =  TAG_Int(0);
  variable2 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*Collection::iterator*/;
  while (true) { /*for*/
    variable3 = ((abstract_collection___Iterator___is_ok_t)CALL(variable2,COLOR_abstract_collection___Iterator___is_ok))(variable2) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable3)) break; /*for*/
    variable3 = ((abstract_collection___Iterator___item_t)CALL(variable2,COLOR_abstract_collection___Iterator___item))(variable2) /*Iterator::item*/;
    variable4 = TAG_Bool(( variable3 /*i*/ ==  variable0 /*item*/) || (( variable3 /*i*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable3 /*i*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable3 /*i*/, variable0 /*item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable3 /*i*/,COLOR_kernel___Object_____eqeq))( variable3 /*i*/,  variable0 /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable4)) { /*if*/
      variable1 = TAG_Int(UNTAG_Int(variable1)+UNTAG_Int( TAG_Int(1))) /*nb*/;
    }
    continue_8: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable2,COLOR_abstract_collection___Iterator___next))(variable2) /*Iterator::next*/;
  }
  break_8: while(0);
  variable1 =  variable1 /*nb*/;
  goto return_label7;
  return_label7: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___NaiveCollection___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 100, LOCATE_abstract_collection___NaiveCollection___first};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___NaiveCollection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*NaiveCollection::length*/;
  variable0 = TAG_Bool(UNTAG_Int(variable0)>UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable0)) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___NaiveCollection___first, LOCATE_abstract_collection, 102); nit_exit(1);}
  variable0 = ((abstract_collection___Collection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*Collection::iterator*/;
  variable0 = ((abstract_collection___Iterator___item_t)CALL(variable0,COLOR_abstract_collection___Iterator___item))(variable0) /*Iterator::item*/;
  goto return_label9;
  return_label9: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___Iterator___item(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 110, LOCATE_abstract_collection___Iterator___item};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___NaiveCollection___first, LOCATE_abstract_collection, 110);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___Iterator___next(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 114, LOCATE_abstract_collection___Iterator___next};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___NaiveCollection___first, LOCATE_abstract_collection, 114);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Iterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 118, LOCATE_abstract_collection___Iterator___is_ok};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___NaiveCollection___first, LOCATE_abstract_collection, 118);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___Container___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 126, LOCATE_abstract_collection___Container___first};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___Container___is_empty(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 128, LOCATE_abstract_collection___Container___is_empty};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  TAG_Bool(false);
  goto return_label11;
  return_label11: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___Container___length(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 130, LOCATE_abstract_collection___Container___length};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  TAG_Int(1);
  goto return_label12;
  return_label12: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___Container___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 132, LOCATE_abstract_collection___Container___has};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
  variable1 = TAG_Bool((variable1 ==  variable0 /*an_item*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, variable0 /*an_item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  variable0 /*an_item*/) /*Object::==*/)))));
  goto return_label13;
  return_label13: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___Container___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 134, LOCATE_abstract_collection___Container___has_only};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
  variable1 = TAG_Bool((variable1 ==  variable0 /*an_item*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, variable0 /*an_item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  variable0 /*an_item*/) /*Object::==*/)))));
  goto return_label14;
  return_label14: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___Container___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 136, LOCATE_abstract_collection___Container___count};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
  variable1 = TAG_Bool((variable1 ==  variable0 /*an_item*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, variable0 /*an_item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  variable0 /*an_item*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  TAG_Int(1);
    goto return_label15;
  } else { /*if*/
    variable1 =  TAG_Int(0);
    goto return_label15;
  }
  return_label15: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___Container___iterator(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 145, LOCATE_abstract_collection___Container___iterator};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = NEW_abstract_collection___ContainerIterator___init( self); /*new ContainerIterator[E]*/
  goto return_label16;
  return_label16: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___Container___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 147, LOCATE_abstract_collection___Container___init};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_Container].i]) return;
  ATTR_abstract_collection___Container____item( self) /*Container::_item*/ =  variable0 /*e*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_Container].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Container___item(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 150, LOCATE_abstract_collection___Container___item};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Container____item( self) /*Container::_item*/;
}
void abstract_collection___Container___item__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 150, LOCATE_abstract_collection___Container___item__eq};
  trace.prev = tracehead; tracehead = &trace;
  ATTR_abstract_collection___Container____item( self) /*Container::_item*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___ContainerIterator___item(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 157, LOCATE_abstract_collection___ContainerIterator___item};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___ContainerIterator____container( self) /*ContainerIterator::_container*/;
  variable0 = ((abstract_collection___Container___item_t)CALL(variable0,COLOR_abstract_collection___Container___item))(variable0) /*Container::item*/;
  goto return_label18;
  return_label18: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___ContainerIterator___next(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 159, LOCATE_abstract_collection___ContainerIterator___next};
  trace.prev = tracehead; tracehead = &trace;
  ATTR_abstract_collection___ContainerIterator____is_ok( self) /*ContainerIterator::_is_ok*/ =  TAG_Bool(false);
  tracehead = trace.prev;
  return;
}
void abstract_collection___ContainerIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 161, LOCATE_abstract_collection___ContainerIterator___init};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_ContainerIterator].i]) return;
  ATTR_abstract_collection___ContainerIterator____container( self) /*ContainerIterator::_container*/ =  variable0 /*c*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_ContainerIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___ContainerIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 163, LOCATE_abstract_collection___ContainerIterator___is_ok};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_abstract_collection___ContainerIterator____is_ok( self) /*ContainerIterator::_is_ok*/;
}
void abstract_collection___RemovableCollection___clear(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 171, LOCATE_abstract_collection___RemovableCollection___clear};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___ContainerIterator___init, LOCATE_abstract_collection, 171);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___RemovableCollection___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 174, LOCATE_abstract_collection___RemovableCollection___remove};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___ContainerIterator___init, LOCATE_abstract_collection, 174);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___RemovableCollection___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 177, LOCATE_abstract_collection___RemovableCollection___remove_all};
  val_t variable0;
    val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  while (true) { /*while*/
    variable1 = ((abstract_collection___Collection___has_t)CALL( self,COLOR_abstract_collection___Collection___has))( self,  variable0 /*item*/) /*Collection::has*/;
    if (!UNTAG_Bool(variable1)) break; /* while*/
    ((abstract_collection___RemovableCollection___remove_t)CALL( self,COLOR_abstract_collection___RemovableCollection___remove))( self,  variable0 /*item*/) /*RemovableCollection::remove*/;
    continue_22: while(0);
  }
  break_22: while(0);
  tracehead = trace.prev;
  return;
}
void abstract_collection___SimpleCollection___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 184, LOCATE_abstract_collection___SimpleCollection___add};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___RemovableCollection___remove_all, LOCATE_abstract_collection, 184);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___SimpleCollection___add_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 188, LOCATE_abstract_collection___SimpleCollection___add_all};
  val_t variable0;
  val_t variable1;
      val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*coll*/ ==  NIT_NULL /*null*/) || (( variable0 /*coll*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*coll*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*coll*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*coll*/,COLOR_kernel___Object_____eqeq))( variable0 /*coll*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = ((abstract_collection___Collection___iterator_t)CALL( variable0 /*coll*/,COLOR_abstract_collection___Collection___iterator))( variable0 /*coll*/) /*Collection::iterator*/;
    while (true) { /*for*/
      variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable2)) break; /*for*/
      variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
      ((abstract_collection___SimpleCollection___add_t)CALL( self,COLOR_abstract_collection___SimpleCollection___add))( self,  variable2 /*i*/) /*SimpleCollection::add*/;
      continue_24: while(0);
      ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
    }
    break_24: while(0);
  }
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Set___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 204, LOCATE_abstract_collection___Set___has_only};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___Collection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*Collection::length*/;
  variable1 = variable2;
  variable2 = TAG_Bool(( variable1 /*l*/)==( TAG_Int(1)));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable2 = ((abstract_collection___Collection___has_t)CALL( self,COLOR_abstract_collection___Collection___has))( self,  variable0 /*item*/) /*Collection::has*/;
    variable1 = variable2;
    goto return_label25;
  } else { /*if*/
    variable2 = TAG_Bool(( variable1 /*l*/)==( TAG_Int(0)));
    if (UNTAG_Bool(variable2)) { /*if*/
      variable1 =  TAG_Bool(true);
      goto return_label25;
    } else { /*if*/
      variable1 =  TAG_Bool(false);
      goto return_label25;
    }
  }
  return_label25: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___Set___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 216, LOCATE_abstract_collection___Set___count};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((abstract_collection___Collection___has_t)CALL( self,COLOR_abstract_collection___Collection___has))( self,  variable0 /*item*/) /*Collection::has*/;
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 =  TAG_Int(1);
    goto return_label26;
  } else { /*if*/
    variable1 =  TAG_Int(0);
    goto return_label26;
  }
  return_label26: while(false);
  tracehead = trace.prev;
  return variable1;
}
void abstract_collection___Set___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 226, LOCATE_abstract_collection___Set___remove_all};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  ((abstract_collection___RemovableCollection___remove_t)CALL( self,COLOR_abstract_collection___RemovableCollection___remove))( self,  variable0 /*item*/) /*RemovableCollection::remove*/;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Map_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 244, LOCATE_abstract_collection___Map_____bra};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___Set___remove_all, LOCATE_abstract_collection, 244);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___Map_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 247, LOCATE_abstract_collection___Map_____braeq};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___Set___remove_all, LOCATE_abstract_collection, 247);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Map___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 250, LOCATE_abstract_collection___Map___has_key};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___Set___remove_all, LOCATE_abstract_collection, 250);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___Map___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 253, LOCATE_abstract_collection___Map___remove_at};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___Set___remove_all, LOCATE_abstract_collection, 253);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___Map___recover_with(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 256, LOCATE_abstract_collection___Map___recover_with};
  val_t variable0;
  val_t variable1;
  val_t variable2;
    val_t variable3;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___Map___iterator_t)CALL( variable0 /*map*/,COLOR_abstract_collection___Collection___iterator))( variable0 /*map*/) /*Map::iterator*/;
  variable1 = variable2;
  while (true) { /*while*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___is_ok))( variable1 /*i*/) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /* while*/
    variable2 = ((abstract_collection___MapIterator___key_t)CALL( variable1 /*i*/,COLOR_abstract_collection___MapIterator___key))( variable1 /*i*/) /*MapIterator::key*/;
    variable3 = ((abstract_collection___Iterator___item_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___item))( variable1 /*i*/) /*Iterator::item*/;
    ((abstract_collection___Map_____braeq_t)CALL( self,COLOR_abstract_collection___Map_____braeq))( self, variable2, variable3) /*Map::[]=*/;
    ((abstract_collection___Iterator___next_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___next))( variable1 /*i*/) /*Iterator::next*/;
    continue_29: while(0);
  }
  break_29: while(0);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Map___iterator(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 267, LOCATE_abstract_collection___Map___iterator};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___Map___recover_with, LOCATE_abstract_collection, 267);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___MapIterator___key(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 273, LOCATE_abstract_collection___MapIterator___key};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___Map___recover_with, LOCATE_abstract_collection, 273);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___MapIterator___item__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 276, LOCATE_abstract_collection___MapIterator___item__eq};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___Map___recover_with, LOCATE_abstract_collection, 276);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 285, LOCATE_abstract_collection___IndexedCollection___first};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___Collection___is_empty_t)CALL( self,COLOR_abstract_collection___Collection___is_empty))( self) /*Collection::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable0)))) { fprintf(stderr, "Assert%s failed", " 'not_empty' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollection___first, LOCATE_abstract_collection, 289); nit_exit(1);}
  variable0 = ((abstract_collection___Map_____bra_t)CALL( self,COLOR_abstract_collection___Map_____bra))( self,  TAG_Int(0)) /*Map::[]*/;
  goto return_label30;
  return_label30: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___IndexedCollection___first__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 293, LOCATE_abstract_collection___IndexedCollection___first__eq};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  ((abstract_collection___Map_____braeq_t)CALL( self,COLOR_abstract_collection___Map_____braeq))( self,  TAG_Int(0),  variable0 /*item*/) /*Map::[]=*/;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___last(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 298, LOCATE_abstract_collection___IndexedCollection___last};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___Collection___is_empty_t)CALL( self,COLOR_abstract_collection___Collection___is_empty))( self) /*Collection::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable0)))) { fprintf(stderr, "Assert%s failed", " 'not_empty' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollection___last, LOCATE_abstract_collection, 302); nit_exit(1);}
  variable0 = ((abstract_collection___Collection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*Collection::length*/;
  variable0 = TAG_Int(UNTAG_Int(variable0)-UNTAG_Int( TAG_Int(1)));
  variable0 = ((abstract_collection___Map_____bra_t)CALL( self,COLOR_abstract_collection___Map_____bra))( self, variable0) /*Map::[]*/;
  goto return_label32;
  return_label32: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___IndexedCollection___last__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 306, LOCATE_abstract_collection___IndexedCollection___last__eq};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___Collection___length_t)CALL( self,COLOR_abstract_collection___Collection___length))( self) /*Collection::length*/;
  variable1 = variable2;
  variable2 = TAG_Bool(UNTAG_Int( variable1 /*l*/)>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable2 = TAG_Int(UNTAG_Int( variable1 /*l*/)-UNTAG_Int( TAG_Int(1)));
    ((abstract_collection___Map_____braeq_t)CALL( self,COLOR_abstract_collection___Map_____braeq))( self, variable2,  variable0 /*item*/) /*Map::[]=*/;
  } else { /*if*/
    ((abstract_collection___Map_____braeq_t)CALL( self,COLOR_abstract_collection___Map_____braeq))( self,  TAG_Int(0),  variable0 /*item*/) /*Map::[]=*/;
  }
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 318, LOCATE_abstract_collection___IndexedCollection___add};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  ((abstract_collection___IndexedCollection___push_t)CALL( self,COLOR_abstract_collection___IndexedCollection___push))( self,  variable0 /*e*/) /*IndexedCollection::push*/;
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___push(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 321, LOCATE_abstract_collection___IndexedCollection___push};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollection___add, LOCATE_abstract_collection, 321);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void abstract_collection___IndexedCollection___append(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 324, LOCATE_abstract_collection___IndexedCollection___append};
  val_t variable0;
  val_t variable1;
      val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable0 /*coll*/ ==  NIT_NULL /*null*/) || (( variable0 /*coll*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable0 /*coll*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable0 /*coll*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable0 /*coll*/,COLOR_kernel___Object_____eqeq))( variable0 /*coll*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable1)) { /*if*/
    variable1 = ((abstract_collection___Collection___iterator_t)CALL( variable0 /*coll*/,COLOR_abstract_collection___Collection___iterator))( variable0 /*coll*/) /*Collection::iterator*/;
    while (true) { /*for*/
      variable2 = ((abstract_collection___Iterator___is_ok_t)CALL(variable1,COLOR_abstract_collection___Iterator___is_ok))(variable1) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable2)) break; /*for*/
      variable2 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
      ((abstract_collection___IndexedCollection___push_t)CALL( self,COLOR_abstract_collection___IndexedCollection___push))( self,  variable2 /*i*/) /*IndexedCollection::push*/;
      continue_36: while(0);
      ((abstract_collection___Iterator___next_t)CALL(variable1,COLOR_abstract_collection___Iterator___next))(variable1) /*Iterator::next*/;
    }
    break_36: while(0);
  }
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___pop(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 327, LOCATE_abstract_collection___IndexedCollection___pop};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollection___append, LOCATE_abstract_collection, 327);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
void abstract_collection___IndexedCollection___unshift(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 330, LOCATE_abstract_collection___IndexedCollection___unshift};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollection___append, LOCATE_abstract_collection, 330);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___IndexedCollection___shift(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 333, LOCATE_abstract_collection___IndexedCollection___shift};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollection___append, LOCATE_abstract_collection, 333);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedCollection___index_of(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 337, LOCATE_abstract_collection___IndexedCollection___index_of};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___IndexedCollection___iterator_t)CALL( self,COLOR_abstract_collection___Collection___iterator))( self) /*IndexedCollection::iterator*/;
  variable1 = variable2;
  while (true) { /*while*/
    variable2 = ((abstract_collection___Iterator___is_ok_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___is_ok))( variable1 /*i*/) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable2)) break; /* while*/
    variable2 = ((abstract_collection___Iterator___item_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___item))( variable1 /*i*/) /*Iterator::item*/;
    variable2 = TAG_Bool((variable2 ==  variable0 /*item*/) || ((variable2 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable2, variable0 /*item*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable2,COLOR_kernel___Object_____eqeq))(variable2,  variable0 /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable2)) { /*if*/
      variable2 = ((abstract_collection___IndexedIterator___index_t)CALL( variable1 /*i*/,COLOR_abstract_collection___IndexedIterator___index))( variable1 /*i*/) /*IndexedIterator::index*/;
      variable1 = variable2;
      goto return_label37;
    }
    ((abstract_collection___Iterator___next_t)CALL( variable1 /*i*/,COLOR_abstract_collection___Iterator___next))( variable1 /*i*/) /*Iterator::next*/;
    continue_38: while(0);
  }
  break_38: while(0);
  variable2 = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable1 = variable2;
  goto return_label37;
  return_label37: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___IndexedCollection___iterator(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 349, LOCATE_abstract_collection___IndexedCollection___iterator};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollection___index_of, LOCATE_abstract_collection, 349);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedIterator___index(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 355, LOCATE_abstract_collection___IndexedIterator___index};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedCollection___index_of, LOCATE_abstract_collection, 355);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___IndexedIterator___key(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 358, LOCATE_abstract_collection___IndexedIterator___key};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ((abstract_collection___IndexedIterator___index_t)CALL( self,COLOR_abstract_collection___IndexedIterator___index))( self) /*IndexedIterator::index*/;
  goto return_label39;
  return_label39: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___CoupleMap___couple_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 365, LOCATE_abstract_collection___CoupleMap___couple_at};
  trace.prev = tracehead; tracehead = &trace;
  fprintf(stderr, "Deferred method %s called");
  fprintf(stderr, " in %s (%s:%d)\n", LOCATE_abstract_collection___IndexedIterator___key, LOCATE_abstract_collection, 365);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t abstract_collection___CoupleMap_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 369, LOCATE_abstract_collection___CoupleMap_____bra};
  val_t variable0;
  val_t variable1;
  val_t variable2;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable2 = ((abstract_collection___CoupleMap___couple_at_t)CALL( self,COLOR_abstract_collection___CoupleMap___couple_at))( self,  variable0 /*key*/) /*CoupleMap::couple_at*/;
  variable1 = variable2;
  variable2 = TAG_Bool(( variable1 /*c*/ ==  NIT_NULL /*null*/) || (( variable1 /*c*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable1 /*c*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable1 /*c*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable1 /*c*/,COLOR_kernel___Object_____eqeq))( variable1 /*c*/,  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable2)) { /*if*/
    variable1 =  NIT_NULL /*null*/;
    goto return_label40;
  } else { /*if*/
    variable2 = ((abstract_collection___Couple___second_t)CALL( variable1 /*c*/,COLOR_abstract_collection___Couple___second))( variable1 /*c*/) /*Couple::second*/;
    variable1 = variable2;
    goto return_label40;
  }
  return_label40: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___CoupleMap___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 379, LOCATE_abstract_collection___CoupleMap___has_key};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ((abstract_collection___CoupleMap___couple_at_t)CALL( self,COLOR_abstract_collection___CoupleMap___couple_at))( self,  variable0 /*key*/) /*CoupleMap::couple_at*/;
  variable1 = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Object::==*/)))))));
  goto return_label41;
  return_label41: while(false);
  tracehead = trace.prev;
  return variable1;
}
val_t abstract_collection___CoupleMapIterator___item(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 387, LOCATE_abstract_collection___CoupleMapIterator___item};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  variable0 = ((abstract_collection___Iterator___item_t)CALL(variable0,COLOR_abstract_collection___Iterator___item))(variable0) /*Iterator::item*/;
  variable0 = ((abstract_collection___Couple___second_t)CALL(variable0,COLOR_abstract_collection___Couple___second))(variable0) /*Couple::second*/;
  goto return_label42;
  return_label42: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___CoupleMapIterator___item__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 389, LOCATE_abstract_collection___CoupleMapIterator___item__eq};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  variable1 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
  ((abstract_collection___Couple___second__eq_t)CALL(variable1,COLOR_abstract_collection___Couple___second__eq))(variable1,  variable0 /*e*/) /*Couple::second=*/;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___CoupleMapIterator___key(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 391, LOCATE_abstract_collection___CoupleMapIterator___key};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  variable0 = ((abstract_collection___Iterator___item_t)CALL(variable0,COLOR_abstract_collection___Iterator___item))(variable0) /*Iterator::item*/;
  variable0 = ((abstract_collection___Couple___first_t)CALL(variable0,COLOR_abstract_collection___Couple___first))(variable0) /*Couple::first*/;
  goto return_label44;
  return_label44: while(false);
  tracehead = trace.prev;
  return variable0;
}
val_t abstract_collection___CoupleMapIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 393, LOCATE_abstract_collection___CoupleMapIterator___is_ok};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  variable0 = ((abstract_collection___Iterator___is_ok_t)CALL(variable0,COLOR_abstract_collection___Iterator___is_ok))(variable0) /*Iterator::is_ok*/;
  goto return_label45;
  return_label45: while(false);
  tracehead = trace.prev;
  return variable0;
}
void abstract_collection___CoupleMapIterator___next(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 395, LOCATE_abstract_collection___CoupleMapIterator___next};
  val_t variable0;
    val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
  ((abstract_collection___Iterator___next_t)CALL(variable0,COLOR_abstract_collection___Iterator___next))(variable0) /*Iterator::next*/;
  while (true) { /*while*/
    variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
    variable0 = ((abstract_collection___Iterator___is_ok_t)CALL(variable0,COLOR_abstract_collection___Iterator___is_ok))(variable0) /*Iterator::is_ok*/;
    variable1 = variable0;
    if (UNTAG_Bool(variable1)) { /* and */
      variable1 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
      variable1 = ((abstract_collection___Iterator___item_t)CALL(variable1,COLOR_abstract_collection___Iterator___item))(variable1) /*Iterator::item*/;
      variable1 = TAG_Bool((variable1 ==  NIT_NULL /*null*/) || ((variable1 != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable1, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable1,COLOR_kernel___Object_____eqeq))(variable1,  NIT_NULL /*null*/) /*Object::==*/)))));
    }
    variable0 = variable1;
    if (!UNTAG_Bool(variable0)) break; /* while*/
    variable0 = ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/;
    ((abstract_collection___Iterator___next_t)CALL(variable0,COLOR_abstract_collection___Iterator___next))(variable0) /*Iterator::next*/;
    continue_47: while(0);
  }
  break_47: while(0);
  tracehead = trace.prev;
  return;
}
void abstract_collection___CoupleMapIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 403, LOCATE_abstract_collection___CoupleMapIterator___init};
  val_t variable0;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_CoupleMapIterator].i]) return;
  ATTR_abstract_collection___CoupleMapIterator____iter( self) /*CoupleMapIterator::_iter*/ =  variable0 /*i*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_CoupleMapIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Couple___first(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 411, LOCATE_abstract_collection___Couple___first};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Couple____first( self) /*Couple::_first*/;
}
void abstract_collection___Couple___first__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 411, LOCATE_abstract_collection___Couple___first__eq};
  trace.prev = tracehead; tracehead = &trace;
  ATTR_abstract_collection___Couple____first( self) /*Couple::_first*/ =  param0;
  tracehead = trace.prev;
  return;
}
val_t abstract_collection___Couple___second(val_t  self) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 414, LOCATE_abstract_collection___Couple___second};
  trace.prev = tracehead; tracehead = &trace;
  tracehead = trace.prev;
  return ATTR_abstract_collection___Couple____second( self) /*Couple::_second*/;
}
void abstract_collection___Couple___second__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 414, LOCATE_abstract_collection___Couple___second__eq};
  trace.prev = tracehead; tracehead = &trace;
  ATTR_abstract_collection___Couple____second( self) /*Couple::_second*/ =  param0;
  tracehead = trace.prev;
  return;
}
void abstract_collection___Couple___init(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, LOCATE_abstract_collection, 417, LOCATE_abstract_collection___Couple___init};
  val_t variable0;
  val_t variable1;
  trace.prev = tracehead; tracehead = &trace;
  variable0 =  param0;
  variable1 =  param1;
  if (init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_Couple].i]) return;
  ATTR_abstract_collection___Couple____first( self) /*Couple::_first*/ =  variable0 /*f*/;
  ATTR_abstract_collection___Couple____second( self) /*Couple::_second*/ =  variable1 /*s*/;
  init_table[VAL2OBJ( self)->vft[INIT_TABLE_POS_Couple].i] = 1;
  tracehead = trace.prev;
  return;
}
