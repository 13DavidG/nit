/* This C file is generated by NIT to compile module genericity. */
#include "genericity._sep.h"
val_t genericity___MMLocalClass___get_type(val_t  self) {
  struct trace_t trace = {NULL, NULL, 80, LOCATE_genericity___MMLocalClass___get_type};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_static_type___MMLocalClass____base_type_cache(variable[2]) /*MMLocalClass::_base_type_cache*/;
  variable[2] = TAG_Bool((variable[2] ==  NIT_NULL /*null*/) || ((variable[2] != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable[2],COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[2], NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable[2],COLOR_kernel___Object_____eqeq))(variable[2],  NIT_NULL /*null*/) /*Object::==*/)))));
  variable[3] = variable[2];
  if (UNTAG_Bool(variable[3])) { /* and */
    variable[3] = variable[0];
    variable[3] = ((genericity___MMLocalClass___is_generic_t)CALL(variable[3],COLOR_genericity___MMLocalClass___is_generic))(variable[3]) /*MMLocalClass::is_generic*/;
  }
  variable[2] = variable[3];
  if (UNTAG_Bool(variable[2])) { /*if*/
    variable[2] = variable[0];
    variable[3] = variable[0];
    variable[4] = variable[0];
    variable[4] = ((genericity___MMLocalClass___formals_types_t)CALL(variable[4],COLOR_genericity___MMLocalClass___formals_types))(variable[4]) /*MMLocalClass::formals_types*/;
    variable[3] = ((genericity___MMLocalClass___get_instantiate_type_t)CALL(variable[3],COLOR_genericity___MMLocalClass___get_instantiate_type))(variable[3], variable[4]) /*MMLocalClass::get_instantiate_type*/;
    ATTR_static_type___MMLocalClass____base_type_cache(variable[2]) /*MMLocalClass::_base_type_cache*/ = variable[3];
    variable[2] = variable[0];
    variable[2] = ATTR_static_type___MMLocalClass____base_type_cache(variable[2]) /*MMLocalClass::_base_type_cache*/;
    variable[1] = variable[2];
    goto return_label0;
  } else { /*if*/
    variable[2] = ((genericity___MMLocalClass___get_type_t)CALL(variable[0],COLOR_SUPER_genericity___MMLocalClass___get_type))(variable[0]) /*super MMLocalClass::get_type*/;
    variable[1] = variable[2];
    goto return_label0;
  }
  return_label0: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t genericity___MMLocalClass___get_formal(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 25, LOCATE_genericity___MMLocalClass___get_formal};
  val_t variable[9];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ((genericity___MMLocalClass___formals_types_t)CALL(variable[3],COLOR_genericity___MMLocalClass___formals_types))(variable[3]) /*MMLocalClass::formals_types*/;
  variable[4] = variable[3];
  variable[5] =  variable[1] /*pos*/;
  variable[7] = TAG_Bool(UNTAG_Int( variable[5] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  variable[8] = variable[7];
  if (UNTAG_Bool(variable[8])) { /* and */
    variable[8] = variable[4];
    variable[8] = ATTR_array___AbstractArray____length(variable[8]) /*AbstractArray::_length*/;
    variable[8] = TAG_Bool(UNTAG_Int( variable[5] /*index*/)<UNTAG_Int(variable[8]));
  }
  variable[7] = variable[8];
  if (!UNTAG_Bool(variable[7])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
  variable[7] = variable[4];
  variable[7] = ATTR_array___Array____items(variable[7]) /*Array::_items*/;
  variable[7] = UNBOX_NativeArray(variable[7])[UNTAG_Int( variable[5] /*index*/)];
  variable[6] = variable[7];
  goto return_label2;
  return_label2: while(false);
  variable[3] = variable[6];
  variable[2] = variable[3];
  goto return_label1;
  return_label1: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void genericity___MMLocalClass___register_formal(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 31, LOCATE_genericity___MMLocalClass___register_formal};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = ((genericity___MMTypeFormalParameter___def_class_t)CALL( variable[1] /*f*/,COLOR_genericity___MMTypeFormalParameter___def_class))( variable[1] /*f*/) /*MMTypeFormalParameter::def_class*/;
  variable[4] = variable[0];
  variable[3] = TAG_Bool((variable[3] == variable[4]) || ((variable[3] != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable[3],COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3],variable[4])):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable[3],COLOR_kernel___Object_____eqeq))(variable[3], variable[4]) /*Object::==*/)))));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMLocalClass___register_formal, LOCATE_genericity, 35); nit_exit(1);}
  variable[3] = ((genericity___MMTypeFormalParameter___position_t)CALL( variable[1] /*f*/,COLOR_genericity___MMTypeFormalParameter___position))( variable[1] /*f*/) /*MMTypeFormalParameter::position*/;
  variable[4] = variable[0];
  variable[4] = ATTR_genericity___MMLocalClass____formals_types(variable[4]) /*MMLocalClass::_formals_types*/;
  variable[4] = ((array___AbstractArray___length_t)CALL(variable[4],COLOR_abstract_collection___Collection___length))(variable[4]) /*AbstractArray::length*/;
  variable[3] = TAG_Bool((variable[3])==(variable[4]));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMLocalClass___register_formal, LOCATE_genericity, 36); nit_exit(1);}
  variable[3] = variable[0];
  variable[3] = ATTR_genericity___MMLocalClass____formals_types(variable[3]) /*MMLocalClass::_formals_types*/;
  ((array___AbstractArray___add_t)CALL(variable[3],COLOR_abstract_collection___SimpleCollection___add))(variable[3],  variable[1] /*f*/) /*AbstractArray::add*/;
  return_label3: while(false);
  tracehead = trace.prev;
  return;
}
val_t genericity___MMLocalClass___get_instantiate_type(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 43, LOCATE_genericity___MMLocalClass___get_instantiate_type};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_genericity___MMLocalClass____types(variable[3]) /*MMLocalClass::_types*/;
  variable[3] = ((array___AbstractArray___iterator_t)CALL(variable[3],COLOR_abstract_collection___Collection___iterator))(variable[3]) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[4] = ((array___ArrayIterator___is_ok_t)CALL(variable[3],COLOR_abstract_collection___Iterator___is_ok))(variable[3]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = ((array___ArrayIterator___item_t)CALL(variable[3],COLOR_abstract_collection___Iterator___item))(variable[3]) /*ArrayIterator::item*/;
    variable[5] = variable[4];
    variable[6] = ((genericity___MMTypeGeneric___params_equals_t)CALL( variable[5] /*g*/,COLOR_genericity___MMTypeGeneric___params_equals))( variable[5] /*g*/,  variable[1] /*t*/) /*MMTypeGeneric::params_equals*/;
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[2] =  variable[5] /*g*/;
      goto return_label4;
    }
    continue_5: while(0);
    ((array___ArrayIterator___next_t)CALL(variable[3],COLOR_abstract_collection___Iterator___next))(variable[3]) /*ArrayIterator::next*/;
  }
  break_5: while(0);
  variable[4] = variable[0];
  variable[5] = NEW_MMTypeGeneric_genericity___MMTypeGeneric___init(variable[4],  variable[1] /*t*/); /*new MMTypeGeneric*/
  variable[4] = variable[5];
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = ATTR_genericity___MMLocalClass____types(variable[4]) /*MMLocalClass::_types*/;
  ((array___AbstractArray___add_t)CALL(variable[4],COLOR_abstract_collection___SimpleCollection___add))(variable[4],  variable[3] /*g*/) /*AbstractArray::add*/;
  variable[2] =  variable[3] /*g*/;
  goto return_label4;
  return_label4: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMLocalClass___formals_types(val_t  self) {
  struct trace_t trace = {NULL, NULL, 57, LOCATE_genericity___MMLocalClass___formals_types};
  val_t variable[13];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_genericity___MMLocalClass____formals_types(variable[2]) /*MMLocalClass::_formals_types*/;
  variable[2] = ((array___AbstractArray___is_empty_t)CALL(variable[2],COLOR_abstract_collection___Collection___is_empty))(variable[2]) /*AbstractArray::is_empty*/;
  if (UNTAG_Bool(variable[2])) { /*if*/
    variable[2] = variable[0];
    variable[2] = TAG_Bool((variable[2]==NIT_NULL) || VAL_ISA(variable[2], COLOR_MMConcreteClass, ID_MMConcreteClass)) /*cast MMConcreteClass*/;
    if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[2])))) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMLocalClass___formals_types, LOCATE_genericity, 62); nit_exit(1);}
    variable[2] = variable[0];
    variable[2] = ((abstractmetamodel___MMLocalClass___arity_t)CALL(variable[2],COLOR_abstractmetamodel___MMLocalClass___arity))(variable[2]) /*MMLocalClass::arity*/;
    variable[3] = NEW_Range_range___Range___without_last( TAG_Int(0), variable[2]); /*new Range[Int]*/
    variable[2] = variable[3];
    variable[2] = ((range___Range___iterator_t)CALL(variable[2],COLOR_abstract_collection___Collection___iterator))(variable[2]) /*Range::iterator*/;
    while (true) { /*for*/
      variable[3] = ((abstract_collection___Iterator___is_ok_t)CALL(variable[2],COLOR_abstract_collection___Iterator___is_ok))(variable[2]) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable[3])) break; /*for*/
      variable[3] = ((abstract_collection___Iterator___item_t)CALL(variable[2],COLOR_abstract_collection___Iterator___item))(variable[2]) /*Iterator::item*/;
      variable[4] = variable[3];
      variable[6] = variable[0];
      variable[6] = ((abstractmetamodel___MMLocalClass___global_t)CALL(variable[6],COLOR_abstractmetamodel___MMLocalClass___global))(variable[6]) /*MMLocalClass::global*/;
      variable[6] = ((abstractmetamodel___MMGlobalClass___intro_t)CALL(variable[6],COLOR_abstractmetamodel___MMGlobalClass___intro))(variable[6]) /*MMGlobalClass::intro*/;
      variable[6] = ((genericity___MMLocalClass___get_formal_t)CALL(variable[6],COLOR_genericity___MMLocalClass___get_formal))(variable[6],  variable[4] /*i*/) /*MMLocalClass::get_formal*/;
      variable[5] = variable[6];
      variable[7] = ((type_formal___MMTypeFormal___name_t)CALL( variable[5] /*oft*/,COLOR_type_formal___MMTypeFormal___name))( variable[5] /*oft*/) /*MMTypeFormal::name*/;
      variable[8] = variable[0];
      variable[9] = NEW_MMTypeFormalParameter_genericity___MMTypeFormalParameter___init(variable[7],  variable[4] /*i*/, variable[8]); /*new MMTypeFormalParameter*/
      variable[7] = variable[9];
      variable[6] = variable[7];
      variable[7] = variable[0];
      ((genericity___MMLocalClass___register_formal_t)CALL(variable[7],COLOR_genericity___MMLocalClass___register_formal))(variable[7],  variable[6] /*ft*/) /*MMLocalClass::register_formal*/;
      continue_7: while(0);
      ((abstract_collection___Iterator___next_t)CALL(variable[2],COLOR_abstract_collection___Iterator___next))(variable[2]) /*Iterator::next*/;
    }
    break_7: while(0);
    variable[2] = variable[0];
    variable[2] = ((abstractmetamodel___MMLocalClass___arity_t)CALL(variable[2],COLOR_abstractmetamodel___MMLocalClass___arity))(variable[2]) /*MMLocalClass::arity*/;
    variable[3] = NEW_Range_range___Range___without_last( TAG_Int(0), variable[2]); /*new Range[Int]*/
    variable[2] = variable[3];
    variable[2] = ((range___Range___iterator_t)CALL(variable[2],COLOR_abstract_collection___Collection___iterator))(variable[2]) /*Range::iterator*/;
    while (true) { /*for*/
      variable[3] = ((abstract_collection___Iterator___is_ok_t)CALL(variable[2],COLOR_abstract_collection___Iterator___is_ok))(variable[2]) /*Iterator::is_ok*/;
      if (!UNTAG_Bool(variable[3])) break; /*for*/
      variable[3] = ((abstract_collection___Iterator___item_t)CALL(variable[2],COLOR_abstract_collection___Iterator___item))(variable[2]) /*Iterator::item*/;
      variable[4] = variable[3];
      variable[6] = variable[0];
      variable[6] = ((abstractmetamodel___MMLocalClass___global_t)CALL(variable[6],COLOR_abstractmetamodel___MMLocalClass___global))(variable[6]) /*MMLocalClass::global*/;
      variable[6] = ((abstractmetamodel___MMGlobalClass___intro_t)CALL(variable[6],COLOR_abstractmetamodel___MMGlobalClass___intro))(variable[6]) /*MMGlobalClass::intro*/;
      variable[6] = ((genericity___MMLocalClass___get_formal_t)CALL(variable[6],COLOR_genericity___MMLocalClass___get_formal))(variable[6],  variable[4] /*i*/) /*MMLocalClass::get_formal*/;
      variable[5] = variable[6];
      variable[7] = variable[0];
      variable[7] = ATTR_genericity___MMLocalClass____formals_types(variable[7]) /*MMLocalClass::_formals_types*/;
      variable[8] = variable[7];
      variable[9] =  variable[4] /*i*/;
      variable[11] = TAG_Bool(UNTAG_Int( variable[9] /*index*/)>=UNTAG_Int( TAG_Int(0)));
      variable[12] = variable[11];
      if (UNTAG_Bool(variable[12])) { /* and */
        variable[12] = variable[8];
        variable[12] = ATTR_array___AbstractArray____length(variable[12]) /*AbstractArray::_length*/;
        variable[12] = TAG_Bool(UNTAG_Int( variable[9] /*index*/)<UNTAG_Int(variable[12]));
      }
      variable[11] = variable[12];
      if (!UNTAG_Bool(variable[11])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
      variable[11] = variable[8];
      variable[11] = ATTR_array___Array____items(variable[11]) /*Array::_items*/;
      variable[11] = UNBOX_NativeArray(variable[11])[UNTAG_Int( variable[9] /*index*/)];
      variable[10] = variable[11];
      goto return_label9;
      return_label9: while(false);
      variable[7] = variable[10];
      variable[6] = variable[7];
      variable[7] = ((type_formal___MMTypeFormal___bound_t)CALL( variable[5] /*oft*/,COLOR_type_formal___MMTypeFormal___bound))( variable[5] /*oft*/) /*MMTypeFormal::bound*/;
      variable[8] = variable[0];
      variable[8] = ((abstractmetamodel___MMLocalClass___module_t)CALL(variable[8],COLOR_abstractmetamodel___MMLocalClass___module))(variable[8]) /*MMLocalClass::module*/;
      variable[7] = ((static_type___MMType___for_module_t)CALL(variable[7],COLOR_static_type___MMType___for_module))(variable[7], variable[8]) /*MMType::for_module*/;
      ((genericity___MMTypeFormalParameter___bound__eq_t)CALL( variable[6] /*ft*/,COLOR_genericity___MMTypeFormalParameter___bound__eq))( variable[6] /*ft*/, variable[7]) /*MMTypeFormalParameter::bound=*/;
      continue_8: while(0);
      ((abstract_collection___Iterator___next_t)CALL(variable[2],COLOR_abstract_collection___Iterator___next))(variable[2]) /*Iterator::next*/;
    }
    break_8: while(0);
  }
  variable[2] = variable[0];
  variable[2] = ATTR_genericity___MMLocalClass____formals_types(variable[2]) /*MMLocalClass::_formals_types*/;
  variable[1] = variable[2];
  goto return_label6;
  return_label6: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t genericity___MMLocalClass___is_generic(val_t  self) {
  struct trace_t trace = {NULL, NULL, 90, LOCATE_genericity___MMLocalClass___is_generic};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ((abstractmetamodel___MMLocalClass___arity_t)CALL(variable[2],COLOR_abstractmetamodel___MMLocalClass___arity))(variable[2]) /*MMLocalClass::arity*/;
  variable[2] = TAG_Bool(UNTAG_Int(variable[2])>UNTAG_Int( TAG_Int(0)));
  variable[1] = variable[2];
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t genericity___MMType___is_generic(val_t  self) {
  struct trace_t trace = {NULL, NULL, 95, LOCATE_genericity___MMType___is_generic};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_genericity, 95);
  nit_exit(1);
  tracehead = trace.prev;
  return NIT_NULL;
}
val_t genericity___MMTypeFormal___is_generic(val_t  self) {
  struct trace_t trace = {NULL, NULL, 100, LOCATE_genericity___MMTypeFormal___is_generic};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_type_formal___MMTypeFormal____bound(variable[2]) /*MMTypeFormal::_bound*/;
  variable[2] = ((genericity___MMType___is_generic_t)CALL(variable[2],COLOR_genericity___MMType___is_generic))(variable[2]) /*MMType::is_generic*/;
  variable[1] = variable[2];
  goto return_label11;
  return_label11: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t genericity___MMTypeSimpleClass___is_generic(val_t  self) {
  struct trace_t trace = {NULL, NULL, 104, LOCATE_genericity___MMTypeSimpleClass___is_generic};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  TAG_Bool(false);
  goto return_label12;
  return_label12: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t genericity___MMTypeGeneric___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 174, LOCATE_genericity___MMTypeGeneric___to_s};
  val_t variable[13];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[2] = NEW_String_string___String___init(); /*new String*/
  variable[3] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
  variable[4] = variable[3];
  ((string___String___append_t)CALL(variable[2],COLOR_abstract_collection___IndexedCollection___append))(variable[2], variable[4]) /*String::append*/;
  variable[5] = ((genericity___MMTypeGeneric___to_s_t)CALL(variable[0],COLOR_SUPER_genericity___MMTypeGeneric___to_s))(variable[0]) /*super MMTypeGeneric::to_s*/;
  variable[6] = variable[5];
  ((string___String___append_t)CALL(variable[2],COLOR_abstract_collection___IndexedCollection___append))(variable[2], variable[6]) /*String::append*/;
  variable[7] = NEW_String_string___String___with_native(BOX_NativeString("["), TAG_Int(1)); /*new String*/
  variable[8] = variable[7];
  ((string___String___append_t)CALL(variable[2],COLOR_abstract_collection___IndexedCollection___append))(variable[2], variable[8]) /*String::append*/;
  variable[9] = variable[0];
  variable[9] = ATTR_genericity___MMTypeGeneric____params(variable[9]) /*MMTypeGeneric::_params*/;
  variable[10] = NEW_String_string___String___with_native(BOX_NativeString(", "), TAG_Int(2)); /*new String*/
  variable[9] = ((string___Collection___join_t)CALL(variable[9],COLOR_string___Collection___join))(variable[9], variable[10]) /*Collection::join*/;
  variable[10] = variable[9];
  ((string___String___append_t)CALL(variable[2],COLOR_abstract_collection___IndexedCollection___append))(variable[2], variable[10]) /*String::append*/;
  variable[11] = NEW_String_string___String___with_native(BOX_NativeString("]"), TAG_Int(1)); /*new String*/
  variable[12] = variable[11];
  ((string___String___append_t)CALL(variable[2],COLOR_abstract_collection___IndexedCollection___append))(variable[2], variable[12]) /*String::append*/;
  variable[1] = variable[2];
  goto return_label13;
  return_label13: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t genericity___MMTypeGeneric___is_supertype(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 114, LOCATE_genericity___MMTypeGeneric___is_supertype};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = ((static_type___MMType___local_class_t)CALL( variable[1] /*t*/,COLOR_static_type___MMType___local_class))( variable[1] /*t*/) /*MMType::local_class*/;
  variable[3] = ((abstractmetamodel___MMLocalClass___cshe_t)CALL(variable[3],COLOR_abstractmetamodel___MMLocalClass___cshe))(variable[3]) /*MMLocalClass::cshe*/;
  variable[4] = variable[0];
  variable[4] = ATTR_static_type___MMTypeClass____local_class(variable[4]) /*MMTypeClass::_local_class*/;
  variable[3] = ((partial_order___PartialOrderElement_____leq_t)CALL(variable[3],COLOR_partial_order___PartialOrderElement_____leq))(variable[3], variable[4]) /*PartialOrderElement::<=*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[4] = variable[0];
    variable[4] = ATTR_static_type___MMTypeClass____local_class(variable[4]) /*MMTypeClass::_local_class*/;
    variable[4] = ((static_type___MMType___upcast_for_t)CALL( variable[1] /*t*/,COLOR_static_type___MMType___upcast_for))( variable[1] /*t*/, variable[4]) /*MMType::upcast_for*/;
    variable[3] = variable[4];
    variable[4] = TAG_Bool(( variable[3] /*u*/==NIT_NULL) || VAL_ISA( variable[3] /*u*/, COLOR_MMTypeGeneric, ID_MMTypeGeneric)) /*cast MMTypeGeneric*/;
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[4] = variable[0];
      variable[4] = ((genericity___MMTypeGeneric___is_subtype_t)CALL(variable[4],COLOR_genericity___MMTypeGeneric___is_subtype))(variable[4],  variable[3] /*u*/) /*MMTypeGeneric::is_subtype*/;
      variable[2] = variable[4];
      goto return_label14;
    }
  }
  variable[2] =  TAG_Bool(false);
  goto return_label14;
  return_label14: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeGeneric___for_module(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 134, LOCATE_genericity___MMTypeGeneric___for_module};
  val_t variable[9];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = ((static_type___MMTypeClass___module_t)CALL(variable[4],COLOR_static_type___MMType___module))(variable[4]) /*MMTypeClass::module*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  variable[1] /*mod*/) || ((variable[4] != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable[4],COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], variable[1] /*mod*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable[4],COLOR_kernel___Object_____eqeq))(variable[4],  variable[1] /*mod*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[5] = NEW_Array_array___Array___init(); /*new Array[MMType]*/
    variable[4] = variable[5];
    variable[5] = variable[0];
    variable[5] = ATTR_genericity___MMTypeGeneric____params(variable[5]) /*MMTypeGeneric::_params*/;
    variable[5] = ((array___AbstractArray___iterator_t)CALL(variable[5],COLOR_abstract_collection___Collection___iterator))(variable[5]) /*AbstractArray::iterator*/;
    while (true) { /*for*/
      variable[6] = ((array___ArrayIterator___is_ok_t)CALL(variable[5],COLOR_abstract_collection___Iterator___is_ok))(variable[5]) /*ArrayIterator::is_ok*/;
      if (!UNTAG_Bool(variable[6])) break; /*for*/
      variable[6] = ((array___ArrayIterator___item_t)CALL(variable[5],COLOR_abstract_collection___Iterator___item))(variable[5]) /*ArrayIterator::item*/;
      variable[7] = variable[6];
      variable[8] = ((static_type___MMType___for_module_t)CALL( variable[7] /*p*/,COLOR_static_type___MMType___for_module))( variable[7] /*p*/,  variable[1] /*mod*/) /*MMType::for_module*/;
      ((array___AbstractArray___add_t)CALL( variable[4] /*parms*/,COLOR_abstract_collection___SimpleCollection___add))( variable[4] /*parms*/, variable[8]) /*AbstractArray::add*/;
      continue_16: while(0);
      ((array___ArrayIterator___next_t)CALL(variable[5],COLOR_abstract_collection___Iterator___next))(variable[5]) /*ArrayIterator::next*/;
    }
    break_16: while(0);
    variable[6] = variable[0];
    variable[6] = ATTR_static_type___MMTypeClass____local_class(variable[6]) /*MMTypeClass::_local_class*/;
    variable[6] = ((abstractmetamodel___MMLocalClass___for_module_t)CALL(variable[6],COLOR_abstractmetamodel___MMLocalClass___for_module))(variable[6],  variable[1] /*mod*/) /*MMLocalClass::for_module*/;
    variable[5] = variable[6];
    variable[6] = ((genericity___MMLocalClass___get_instantiate_type_t)CALL( variable[5] /*b*/,COLOR_genericity___MMLocalClass___get_instantiate_type))( variable[5] /*b*/,  variable[4] /*parms*/) /*MMLocalClass::get_instantiate_type*/;
    variable[3] = variable[6] /*t=*/;
  }
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable[3] /*t*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable[3] /*t*/,COLOR_kernel___Object_____eqeq))( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMTypeGeneric___for_module, LOCATE_genericity, 145); nit_exit(1);}
  variable[2] =  variable[3] /*t*/;
  goto return_label15;
  return_label15: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeGeneric___adapt_to(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 149, LOCATE_genericity___MMTypeGeneric___adapt_to};
  val_t variable[8];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = NEW_Array_array___Array___init(); /*new Array[MMType]*/
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = ATTR_genericity___MMTypeGeneric____params(variable[4]) /*MMTypeGeneric::_params*/;
  variable[4] = ((array___AbstractArray___iterator_t)CALL(variable[4],COLOR_abstract_collection___Collection___iterator))(variable[4]) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[5] = ((array___ArrayIterator___is_ok_t)CALL(variable[4],COLOR_abstract_collection___Iterator___is_ok))(variable[4]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[5])) break; /*for*/
    variable[5] = ((array___ArrayIterator___item_t)CALL(variable[4],COLOR_abstract_collection___Iterator___item))(variable[4]) /*ArrayIterator::item*/;
    variable[6] = variable[5];
    variable[7] = ((static_type___MMType___adapt_to_t)CALL( variable[6] /*i*/,COLOR_static_type___MMType___adapt_to))( variable[6] /*i*/,  variable[1] /*r*/) /*MMType::adapt_to*/;
    ((array___AbstractArray___add_t)CALL( variable[3] /*rv*/,COLOR_abstract_collection___SimpleCollection___add))( variable[3] /*rv*/, variable[7]) /*AbstractArray::add*/;
    continue_18: while(0);
    ((array___ArrayIterator___next_t)CALL(variable[4],COLOR_abstract_collection___Iterator___next))(variable[4]) /*ArrayIterator::next*/;
  }
  break_18: while(0);
  variable[5] = variable[0];
  variable[5] = ATTR_static_type___MMTypeClass____local_class(variable[5]) /*MMTypeClass::_local_class*/;
  variable[5] = ((genericity___MMLocalClass___get_instantiate_type_t)CALL(variable[5],COLOR_genericity___MMLocalClass___get_instantiate_type))(variable[5],  variable[3] /*rv*/) /*MMLocalClass::get_instantiate_type*/;
  variable[4] = variable[5];
  variable[2] =  variable[4] /*l*/;
  goto return_label17;
  return_label17: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeGeneric___upcast_for(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 125, LOCATE_genericity___MMTypeGeneric___upcast_for};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = ((genericity___MMTypeGeneric___upcast_for_t)CALL(variable[0],COLOR_SUPER_genericity___MMTypeGeneric___upcast_for))(variable[0], variable[1]) /*super MMTypeGeneric::upcast_for*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ == variable[4]) || (( variable[3] /*t*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable[3] /*t*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/,variable[4])):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable[3] /*t*/,COLOR_kernel___Object_____eqeq))( variable[3] /*t*/, variable[4]) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = ((static_type___MMType___adapt_to_t)CALL( variable[3] /*t*/,COLOR_static_type___MMType___adapt_to))( variable[3] /*t*/, variable[4]) /*MMType::adapt_to*/;
    variable[3] = variable[4] /*t=*/;
  }
  variable[2] =  variable[3] /*t*/;
  goto return_label19;
  return_label19: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeGeneric___is_generic(val_t  self) {
  struct trace_t trace = {NULL, NULL, 112, LOCATE_genericity___MMTypeGeneric___is_generic};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  TAG_Bool(true);
  goto return_label20;
  return_label20: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t genericity___MMTypeGeneric___params(val_t  self) {
  struct trace_t trace = {NULL, NULL, 109, LOCATE_genericity___MMTypeGeneric___params};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  tracehead = trace.prev;
  return ATTR_genericity___MMTypeGeneric____params( self) /*MMTypeGeneric::_params*/;
}
val_t genericity___MMTypeGeneric___params_equals(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 159, LOCATE_genericity___MMTypeGeneric___params_equals};
  val_t variable[12];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = ((array___AbstractArray___length_t)CALL( variable[1] /*t*/,COLOR_abstract_collection___Collection___length))( variable[1] /*t*/) /*AbstractArray::length*/;
  variable[4] = variable[0];
  variable[4] = ATTR_genericity___MMTypeGeneric____params(variable[4]) /*MMTypeGeneric::_params*/;
  variable[4] = ((array___AbstractArray___length_t)CALL(variable[4],COLOR_abstract_collection___Collection___length))(variable[4]) /*AbstractArray::length*/;
  variable[3] = TAG_Bool((variable[3])!=(variable[4]));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[2] =  TAG_Bool(false);
    goto return_label21;
  }
  variable[3] = ((array___AbstractArray___length_t)CALL( variable[1] /*t*/,COLOR_abstract_collection___Collection___length))( variable[1] /*t*/) /*AbstractArray::length*/;
  variable[4] = NEW_Range_range___Range___without_last( TAG_Int(0), variable[3]); /*new Range[Int]*/
  variable[3] = variable[4];
  variable[3] = ((range___Range___iterator_t)CALL(variable[3],COLOR_abstract_collection___Collection___iterator))(variable[3]) /*Range::iterator*/;
  while (true) { /*for*/
    variable[4] = ((abstract_collection___Iterator___is_ok_t)CALL(variable[3],COLOR_abstract_collection___Iterator___is_ok))(variable[3]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = ((abstract_collection___Iterator___item_t)CALL(variable[3],COLOR_abstract_collection___Iterator___item))(variable[3]) /*Iterator::item*/;
    variable[5] = variable[4];
    variable[6] = variable[0];
    variable[6] = ATTR_genericity___MMTypeGeneric____params(variable[6]) /*MMTypeGeneric::_params*/;
    variable[7] = variable[6];
    variable[8] =  variable[5] /*i*/;
    variable[10] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[11] = variable[10];
    if (UNTAG_Bool(variable[11])) { /* and */
      variable[11] = variable[7];
      variable[11] = ATTR_array___AbstractArray____length(variable[11]) /*AbstractArray::_length*/;
      variable[11] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)<UNTAG_Int(variable[11]));
    }
    variable[10] = variable[11];
    if (!UNTAG_Bool(variable[10])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
    variable[10] = variable[7];
    variable[10] = ATTR_array___Array____items(variable[10]) /*Array::_items*/;
    variable[10] = UNBOX_NativeArray(variable[10])[UNTAG_Int( variable[8] /*index*/)];
    variable[9] = variable[10];
    goto return_label23;
    return_label23: while(false);
    variable[6] = variable[9];
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[6] ==  NIT_NULL /*null*/) || ((variable[6] != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable[6],COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable[6],COLOR_kernel___Object_____eqeq))(variable[6],  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (!UNTAG_Bool(variable[6])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMTypeGeneric___params_equals, LOCATE_genericity, 165); nit_exit(1);}
    variable[6] =  variable[1] /*t*/;
    variable[7] =  variable[5] /*i*/;
    variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[10] = variable[9];
    if (UNTAG_Bool(variable[10])) { /* and */
      variable[10] = variable[6];
      variable[10] = ATTR_array___AbstractArray____length(variable[10]) /*AbstractArray::_length*/;
      variable[10] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)<UNTAG_Int(variable[10]));
    }
    variable[9] = variable[10];
    if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
    variable[9] = variable[6];
    variable[9] = ATTR_array___Array____items(variable[9]) /*Array::_items*/;
    variable[9] = UNBOX_NativeArray(variable[9])[UNTAG_Int( variable[7] /*index*/)];
    variable[8] = variable[9];
    goto return_label24;
    return_label24: while(false);
    variable[6] = variable[8];
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[6] ==  NIT_NULL /*null*/) || ((variable[6] != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable[6],COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable[6],COLOR_kernel___Object_____eqeq))(variable[6],  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (!UNTAG_Bool(variable[6])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMTypeGeneric___params_equals, LOCATE_genericity, 166); nit_exit(1);}
    variable[6] = variable[0];
    variable[6] = ATTR_genericity___MMTypeGeneric____params(variable[6]) /*MMTypeGeneric::_params*/;
    variable[7] = variable[6];
    variable[8] =  variable[5] /*i*/;
    variable[10] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[11] = variable[10];
    if (UNTAG_Bool(variable[11])) { /* and */
      variable[11] = variable[7];
      variable[11] = ATTR_array___AbstractArray____length(variable[11]) /*AbstractArray::_length*/;
      variable[11] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)<UNTAG_Int(variable[11]));
    }
    variable[10] = variable[11];
    if (!UNTAG_Bool(variable[10])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
    variable[10] = variable[7];
    variable[10] = ATTR_array___Array____items(variable[10]) /*Array::_items*/;
    variable[10] = UNBOX_NativeArray(variable[10])[UNTAG_Int( variable[8] /*index*/)];
    variable[9] = variable[10];
    goto return_label25;
    return_label25: while(false);
    variable[6] = variable[9];
    variable[7] =  variable[1] /*t*/;
    variable[8] =  variable[5] /*i*/;
    variable[10] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[11] = variable[10];
    if (UNTAG_Bool(variable[11])) { /* and */
      variable[11] = variable[7];
      variable[11] = ATTR_array___AbstractArray____length(variable[11]) /*AbstractArray::_length*/;
      variable[11] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)<UNTAG_Int(variable[11]));
    }
    variable[10] = variable[11];
    if (!UNTAG_Bool(variable[10])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
    variable[10] = variable[7];
    variable[10] = ATTR_array___Array____items(variable[10]) /*Array::_items*/;
    variable[10] = UNBOX_NativeArray(variable[10])[UNTAG_Int( variable[8] /*index*/)];
    variable[9] = variable[10];
    goto return_label26;
    return_label26: while(false);
    variable[7] = variable[9];
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[6] == variable[7]) || ((variable[6] != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable[6],COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6],variable[7])):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable[6],COLOR_kernel___Object_____eqeq))(variable[6], variable[7]) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label21;
    }
    continue_22: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable[3],COLOR_abstract_collection___Iterator___next))(variable[3]) /*Iterator::next*/;
  }
  break_22: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label21;
  return_label21: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeGeneric___is_subtype(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 179, LOCATE_genericity___MMTypeGeneric___is_subtype};
  val_t variable[13];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_genericity___MMTypeGeneric____params(variable[3]) /*MMTypeGeneric::_params*/;
  variable[3] = ((array___AbstractArray___length_t)CALL(variable[3],COLOR_abstract_collection___Collection___length))(variable[3]) /*AbstractArray::length*/;
  variable[4] = NEW_Range_range___Range___without_last( TAG_Int(0), variable[3]); /*new Range[Int]*/
  variable[3] = variable[4];
  variable[3] = ((range___Range___iterator_t)CALL(variable[3],COLOR_abstract_collection___Collection___iterator))(variable[3]) /*Range::iterator*/;
  while (true) { /*for*/
    variable[4] = ((abstract_collection___Iterator___is_ok_t)CALL(variable[3],COLOR_abstract_collection___Iterator___is_ok))(variable[3]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = ((abstract_collection___Iterator___item_t)CALL(variable[3],COLOR_abstract_collection___Iterator___item))(variable[3]) /*Iterator::item*/;
    variable[5] = variable[4];
    variable[6] = ((genericity___MMTypeGeneric___params_t)CALL( variable[1] /*t*/,COLOR_genericity___MMTypeGeneric___params))( variable[1] /*t*/) /*MMTypeGeneric::params*/;
    variable[7] = variable[6];
    variable[8] =  variable[5] /*i*/;
    variable[10] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[11] = variable[10];
    if (UNTAG_Bool(variable[11])) { /* and */
      variable[11] = variable[7];
      variable[11] = ATTR_array___AbstractArray____length(variable[11]) /*AbstractArray::_length*/;
      variable[11] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)<UNTAG_Int(variable[11]));
    }
    variable[10] = variable[11];
    if (!UNTAG_Bool(variable[10])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
    variable[10] = variable[7];
    variable[10] = ATTR_array___Array____items(variable[10]) /*Array::_items*/;
    variable[10] = UNBOX_NativeArray(variable[10])[UNTAG_Int( variable[8] /*index*/)];
    variable[9] = variable[10];
    goto return_label29;
    return_label29: while(false);
    variable[6] = variable[9];
    variable[7] = variable[0];
    variable[7] = ATTR_genericity___MMTypeGeneric____params(variable[7]) /*MMTypeGeneric::_params*/;
    variable[8] = variable[7];
    variable[9] =  variable[5] /*i*/;
    variable[11] = TAG_Bool(UNTAG_Int( variable[9] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[12] = variable[11];
    if (UNTAG_Bool(variable[12])) { /* and */
      variable[12] = variable[8];
      variable[12] = ATTR_array___AbstractArray____length(variable[12]) /*AbstractArray::_length*/;
      variable[12] = TAG_Bool(UNTAG_Int( variable[9] /*index*/)<UNTAG_Int(variable[12]));
    }
    variable[11] = variable[12];
    if (!UNTAG_Bool(variable[11])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
    variable[11] = variable[8];
    variable[11] = ATTR_array___Array____items(variable[11]) /*Array::_items*/;
    variable[11] = UNBOX_NativeArray(variable[11])[UNTAG_Int( variable[9] /*index*/)];
    variable[10] = variable[11];
    goto return_label30;
    return_label30: while(false);
    variable[7] = variable[10];
    variable[6] = ((static_type___MMType_____l_t)CALL(variable[6],COLOR_static_type___MMType_____l))(variable[6], variable[7]) /*MMType::<*/;
    if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[6])))) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label27;
    }
    continue_28: while(0);
    ((abstract_collection___Iterator___next_t)CALL(variable[3],COLOR_abstract_collection___Iterator___next))(variable[3]) /*Iterator::next*/;
  }
  break_28: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label27;
  return_label27: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void genericity___MMTypeGeneric___init(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 192, LOCATE_genericity___MMTypeGeneric___init};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_MMTypeGeneric].i]) return;
  ((static_type___MMTypeClass___init_t)CALL(variable[0],COLOR_static_type___MMTypeClass___init))(variable[0],  variable[1] /*c*/, init_table /*YYY*/) /*MMTypeClass::init*/;
  variable[4] = variable[0];
  ATTR_genericity___MMTypeGeneric____params(variable[4]) /*MMTypeGeneric::_params*/ =  variable[2] /*p*/;
  return_label31: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_MMTypeGeneric].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t genericity___MMTypeFormalParameter___module(val_t  self) {
  struct trace_t trace = {NULL, NULL, 207, LOCATE_genericity___MMTypeFormalParameter___module};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_genericity___MMTypeFormalParameter____def_class(variable[2]) /*MMTypeFormalParameter::_def_class*/;
  variable[2] = ((abstractmetamodel___MMLocalClass___module_t)CALL(variable[2],COLOR_abstractmetamodel___MMLocalClass___module))(variable[2]) /*MMLocalClass::module*/;
  variable[1] = variable[2];
  goto return_label32;
  return_label32: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t genericity___MMTypeFormalParameter___for_module(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 209, LOCATE_genericity___MMTypeFormalParameter___for_module};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = ((genericity___MMTypeFormalParameter___module_t)CALL(variable[4],COLOR_static_type___MMType___module))(variable[4]) /*MMTypeFormalParameter::module*/;
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[4] ==  variable[1] /*mod*/) || ((variable[4] != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable[4],COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], variable[1] /*mod*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable[4],COLOR_kernel___Object_____eqeq))(variable[4],  variable[1] /*mod*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = ATTR_genericity___MMTypeFormalParameter____def_class(variable[4]) /*MMTypeFormalParameter::_def_class*/;
    variable[4] = ((abstractmetamodel___MMLocalClass___global_t)CALL(variable[4],COLOR_abstractmetamodel___MMLocalClass___global))(variable[4]) /*MMLocalClass::global*/;
    variable[4] = ((abstractmetamodel___MMModule_____bra_t)CALL( variable[1] /*mod*/,COLOR_abstractmetamodel___MMModule_____bra))( variable[1] /*mod*/, variable[4]) /*MMModule::[]*/;
    variable[5] = variable[0];
    variable[5] = ((genericity___MMTypeFormalParameter___position_t)CALL(variable[5],COLOR_genericity___MMTypeFormalParameter___position))(variable[5]) /*MMTypeFormalParameter::position*/;
    variable[4] = ((genericity___MMLocalClass___get_formal_t)CALL(variable[4],COLOR_genericity___MMLocalClass___get_formal))(variable[4], variable[5]) /*MMLocalClass::get_formal*/;
    variable[3] = variable[4] /*t=*/;
  }
  variable[4] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[3] /*t*/ ==  NIT_NULL /*null*/) || (( variable[3] /*t*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable[3] /*t*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[3] /*t*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable[3] /*t*/,COLOR_kernel___Object_____eqeq))( variable[3] /*t*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMTypeFormalParameter___for_module, LOCATE_genericity, 215); nit_exit(1);}
  variable[2] =  variable[3] /*t*/;
  goto return_label33;
  return_label33: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeFormalParameter___adapt_to(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 227, LOCATE_genericity___MMTypeFormalParameter___adapt_to};
  val_t variable[12];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = ((type_formal___MMType___direct_type_t)CALL( variable[1] /*r*/,COLOR_type_formal___MMType___direct_type))( variable[1] /*r*/) /*MMType::direct_type*/;
  variable[1] = variable[3] /*r=*/;
  variable[4] = variable[0];
  variable[4] = ((genericity___MMTypeFormalParameter___def_class_t)CALL(variable[4],COLOR_genericity___MMTypeFormalParameter___def_class))(variable[4]) /*MMTypeFormalParameter::def_class*/;
  variable[4] = ((static_type___MMType___upcast_for_t)CALL( variable[1] /*r*/,COLOR_static_type___MMType___upcast_for))( variable[1] /*r*/, variable[4]) /*MMType::upcast_for*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(( variable[3] /*old_r*/==NIT_NULL) || VAL_ISA( variable[3] /*old_r*/, COLOR_MMTypeGeneric, ID_MMTypeGeneric)) /*cast MMTypeGeneric*/;
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMTypeFormalParameter___adapt_to, LOCATE_genericity, 235); nit_exit(1);}
  variable[5] = ((genericity___MMTypeGeneric___params_t)CALL( variable[3] /*old_r*/,COLOR_genericity___MMTypeGeneric___params))( variable[3] /*old_r*/) /*MMTypeGeneric::params*/;
  variable[6] = variable[0];
  variable[6] = ((genericity___MMTypeFormalParameter___position_t)CALL(variable[6],COLOR_genericity___MMTypeFormalParameter___position))(variable[6]) /*MMTypeFormalParameter::position*/;
  variable[7] = variable[5];
  variable[8] = variable[6];
  variable[10] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  variable[11] = variable[10];
  if (UNTAG_Bool(variable[11])) { /* and */
    variable[11] = variable[7];
    variable[11] = ATTR_array___AbstractArray____length(variable[11]) /*AbstractArray::_length*/;
    variable[11] = TAG_Bool(UNTAG_Int( variable[8] /*index*/)<UNTAG_Int(variable[11]));
  }
  variable[10] = variable[11];
  if (!UNTAG_Bool(variable[10])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_genericity, 229); nit_exit(1);}
  variable[10] = variable[7];
  variable[10] = ATTR_array___Array____items(variable[10]) /*Array::_items*/;
  variable[10] = UNBOX_NativeArray(variable[10])[UNTAG_Int( variable[8] /*index*/)];
  variable[9] = variable[10];
  goto return_label35;
  return_label35: while(false);
  variable[5] = variable[9];
  variable[4] = variable[5];
  variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*reduct*/ ==  NIT_NULL /*null*/) || (( variable[4] /*reduct*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable[4] /*reduct*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*reduct*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable[4] /*reduct*/,COLOR_kernel___Object_____eqeq))( variable[4] /*reduct*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable[5])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMTypeFormalParameter___adapt_to, LOCATE_genericity, 237); nit_exit(1);}
  variable[2] =  variable[4] /*reduct*/;
  goto return_label34;
  return_label34: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeFormalParameter___upcast_for(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 219, LOCATE_genericity___MMTypeFormalParameter___upcast_for};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[2] = variable[3];
  goto return_label36;
  return_label36: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeFormalParameter___def_class(val_t  self) {
  struct trace_t trace = {NULL, NULL, 201, LOCATE_genericity___MMTypeFormalParameter___def_class};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  tracehead = trace.prev;
  return ATTR_genericity___MMTypeFormalParameter____def_class( self) /*MMTypeFormalParameter::_def_class*/;
}
val_t genericity___MMTypeFormalParameter___position(val_t  self) {
  struct trace_t trace = {NULL, NULL, 204, LOCATE_genericity___MMTypeFormalParameter___position};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  tracehead = trace.prev;
  return ATTR_genericity___MMTypeFormalParameter____position( self) /*MMTypeFormalParameter::_position*/;
}
void genericity___MMTypeFormalParameter___bound__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 221, LOCATE_genericity___MMTypeFormalParameter___bound__eq};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_type_formal___MMTypeFormal____bound(variable[3]) /*MMTypeFormal::_bound*/;
  variable[3] = TAG_Bool((variable[3] ==  NIT_NULL /*null*/) || ((variable[3] != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL(variable[3],COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[3], NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL(variable[3],COLOR_kernel___Object_____eqeq))(variable[3],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMTypeFormalParameter___bound__eq, LOCATE_genericity, 223); nit_exit(1);}
  variable[3] = variable[0];
  ATTR_type_formal___MMTypeFormal____bound(variable[3]) /*MMTypeFormal::_bound*/ =  variable[1] /*t*/;
  return_label37: while(false);
  tracehead = trace.prev;
  return;
}
void genericity___MMTypeFormalParameter___with_bound(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3, int* init_table) {
  struct trace_t trace = {NULL, NULL, 241, LOCATE_genericity___MMTypeFormalParameter___with_bound};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[4] =  param3;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_MMTypeFormalParameter].i]) return;
  variable[6] = variable[0];
  ((genericity___MMTypeFormalParameter___init_t)CALL(variable[6],COLOR_genericity___MMTypeFormalParameter___init))(variable[6],  variable[1] /*n*/,  variable[2] /*p*/,  variable[3] /*intro*/, init_table /*YYY*/) /*MMTypeFormalParameter::init*/;
  variable[6] = variable[0];
  ATTR_type_formal___MMTypeFormal____bound(variable[6]) /*MMTypeFormal::_bound*/ =  variable[4] /*b*/;
  return_label38: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_MMTypeFormalParameter].i] = 1;
  tracehead = trace.prev;
  return;
}
void genericity___MMTypeFormalParameter___init(val_t  self, val_t  param0, val_t  param1, val_t  param2, int* init_table) {
  struct trace_t trace = {NULL, NULL, 247, LOCATE_genericity___MMTypeFormalParameter___init};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_MMTypeFormalParameter].i]) return;
  variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[1] /*n*/ ==  NIT_NULL /*null*/) || (( variable[1] /*n*/ != NIT_NULL) && ((((kernel___Object_____eqeq_t)CALL( variable[1] /*n*/,COLOR_kernel___Object_____eqeq))==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[1] /*n*/, NIT_NULL /*null*/)):(UNTAG_Bool(((kernel___Object_____eqeq_t)CALL( variable[1] /*n*/,COLOR_kernel___Object_____eqeq))( variable[1] /*n*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable[5])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_genericity___MMTypeFormalParameter___init, LOCATE_genericity, 249); nit_exit(1);}
  ((type_formal___MMTypeFormal___init_t)CALL(variable[0],COLOR_type_formal___MMTypeFormal___init))(variable[0],  variable[1] /*n*/,  NIT_NULL /*null*/, init_table /*YYY*/) /*MMTypeFormal::init*/;
  variable[5] = variable[0];
  ATTR_genericity___MMTypeFormalParameter____position(variable[5]) /*MMTypeFormalParameter::_position*/ =  variable[2] /*p*/;
  variable[5] = variable[0];
  ATTR_genericity___MMTypeFormalParameter____def_class(variable[5]) /*MMTypeFormalParameter::_def_class*/ =  variable[3] /*intro*/;
  return_label39: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_MMTypeFormalParameter].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t genericity___MMTypeNone___for_module(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 258, LOCATE_genericity___MMTypeNone___for_module};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[2] = variable[3];
  goto return_label40;
  return_label40: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeNone___adapt_to(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 259, LOCATE_genericity___MMTypeNone___adapt_to};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[2] = variable[3];
  goto return_label41;
  return_label41: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t genericity___MMTypeNone___is_generic(val_t  self) {
  struct trace_t trace = {NULL, NULL, 257, LOCATE_genericity___MMTypeNone___is_generic};
  val_t variable[2];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_genericity;
  variable[0] =  self;
  variable[1] =  TAG_Bool(false);
  goto return_label42;
  return_label42: while(false);
  tracehead = trace.prev;
  return variable[1];
}
