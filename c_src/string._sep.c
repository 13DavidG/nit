/* This C file is generated by NIT to compile module string. */
#include "string._sep.h"
val_t string___String_____eqeq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 294, LOCATE_string___String_____eqeq};
  val_t variable[9];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = TAG_Bool(( variable[1] /*o*/==NIT_NULL) || VAL_ISA( variable[1] /*o*/, COLOR_String, ID_String)) /*cast String*/;
  variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3]));
  if (!UNTAG_Bool(variable[3])) { /* or */
    variable[3] = TAG_Bool(IS_EQUAL_NN( variable[1] /*o*/, NIT_NULL /*null*/));
  }
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[2] =  TAG_Bool(false);
    goto return_label0;
  }
  variable[3] = TAG_Bool(( variable[1] /*o*/==NIT_NULL) || VAL_ISA( variable[1] /*o*/, COLOR_String, ID_String)) /*cast String*/;
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_string___String_____eqeq, LOCATE_string, 297); nit_exit(1);}
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[3] = variable[4];
  variable[4] = CALL_abstract_collection___Collection___length( variable[1] /*o*/)( variable[1] /*o*/) /*AbstractArray::length*/;
  variable[4] = TAG_Bool((variable[4])!=( variable[3] /*l*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[2] =  TAG_Bool(false);
    goto return_label0;
  }
  variable[4] =  TAG_Int(0);
  variable[6] = variable[0];
  variable[6] = ATTR_string___String____items(variable[6]) /*String::_items*/;
  variable[5] = variable[6];
  variable[7] = ATTR_string___String____items( variable[1] /*o*/) /*String::_items*/;
  variable[6] = variable[7];
  while (true) { /*while*/
    variable[7] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[3] /*l*/));
    if (!UNTAG_Bool(variable[7])) break; /* while*/
    variable[7] = TAG_Char(UNBOX_NativeString( variable[5] /*it*/)[UNTAG_Int( variable[4] /*i*/)]);
    variable[8] = TAG_Char(UNBOX_NativeString( variable[6] /*oit*/)[UNTAG_Int( variable[4] /*i*/)]);
    variable[7] = TAG_Bool((variable[7])!=(variable[8]));
    if (UNTAG_Bool(variable[7])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label0;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_1: while(0);
  }
  break_1: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void string___String___output(val_t  self) {
  struct trace_t trace = {NULL, NULL, 285, LOCATE_string___String___output};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] =  TAG_Int(0);
  while (true) { /*while*/
    variable[3] = variable[0];
    variable[3] = CALL_abstract_collection___Collection___length(variable[3])(variable[3]) /*AbstractArray::length*/;
    variable[3] = TAG_Bool(UNTAG_Int( variable[2] /*i*/)<UNTAG_Int(variable[3]));
    if (!UNTAG_Bool(variable[3])) break; /* while*/
    variable[3] = variable[0];
    variable[3] = ATTR_string___String____items(variable[3]) /*String::_items*/;
    variable[3] = TAG_Char(UNBOX_NativeString(variable[3])[UNTAG_Int( variable[2] /*i*/)]);
    printf("%c", (unsigned char)UNTAG_Char(variable[3]));
    variable[2] = TAG_Int(UNTAG_Int(variable[2])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_3: while(0);
  }
  break_3: while(0);
  return_label2: while(false);
  tracehead = trace.prev;
  return;
}
val_t string___String_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 31, LOCATE_string___String_____bra};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_string___String____items(variable[3]) /*String::_items*/;
  variable[3] = TAG_Char(UNBOX_NativeString(variable[3])[UNTAG_Int( variable[1] /*index*/)]);
  variable[2] = variable[3];
  goto return_label4;
  return_label4: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void string___String_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 33, LOCATE_string___String_____braeq};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Bool(( variable[1] /*index*/)==(variable[4]));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    CALL_abstract_collection___SimpleCollection___add(variable[4])(variable[4],  variable[2] /*item*/) /*String::add*/;
    goto return_label5;
  }
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  variable[5] = variable[4];
  if (UNTAG_Bool(variable[5])) { /* and */
    variable[5] = variable[0];
    variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
    variable[5] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)<UNTAG_Int(variable[5]));
  }
  variable[4] = variable[5];
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_string___String_____braeq, LOCATE_string, 39); nit_exit(1);}
  variable[4] = variable[0];
  variable[4] = ATTR_string___String____items(variable[4]) /*String::_items*/;
  UNBOX_NativeString(variable[4])[UNTAG_Int( variable[1] /*index*/)]=UNTAG_Char( variable[2] /*item*/);
  return_label5: while(false);
  tracehead = trace.prev;
  return;
}
void string___String___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 43, LOCATE_string___String___add};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_string___String____capacity(variable[3]) /*String::_capacity*/;
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])<=UNTAG_Int(variable[4]));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[4] = variable[0];
    variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(5)));
    CALL_array___AbstractArray___enlarge(variable[3])(variable[3], variable[4]) /*String::enlarge*/;
  }
  variable[3] = variable[0];
  variable[3] = ATTR_string___String____items(variable[3]) /*String::_items*/;
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  UNBOX_NativeString(variable[3])[UNTAG_Int(variable[4])]=UNTAG_Char( variable[1] /*c*/);
  variable[3] = variable[0];
  ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/ = TAG_Int(UNTAG_Int(ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/)+UNTAG_Int( TAG_Int(1)));
  return_label6: while(false);
  tracehead = trace.prev;
  return;
}
void string___String___append(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 61, LOCATE_string___String___append};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = TAG_Bool(( variable[1] /*s*/==NIT_NULL) || VAL_ISA( variable[1] /*s*/, COLOR_String, ID_String)) /*cast String*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[4] = CALL_abstract_collection___Collection___length( variable[1] /*s*/)( variable[1] /*s*/) /*AbstractArray::length*/;
    variable[3] = variable[4];
    variable[4] = variable[0];
    variable[4] = ATTR_string___String____capacity(variable[4]) /*String::_capacity*/;
    variable[5] = variable[0];
    variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
    variable[5] = TAG_Int(UNTAG_Int(variable[5])+UNTAG_Int( variable[3] /*sl*/));
    variable[4] = TAG_Bool(UNTAG_Int(variable[4])<UNTAG_Int(variable[5]));
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[4] = variable[0];
      variable[5] = variable[0];
      variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
      variable[5] = TAG_Int(UNTAG_Int(variable[5])+UNTAG_Int( variable[3] /*sl*/));
      CALL_array___AbstractArray___enlarge(variable[4])(variable[4], variable[5]) /*String::enlarge*/;
    }
    variable[4] = CALL_string___String___items( variable[1] /*s*/)( variable[1] /*s*/) /*String::items*/;
    variable[5] = variable[0];
    variable[5] = ATTR_string___String____items(variable[5]) /*String::_items*/;
    variable[6] = variable[0];
    variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*AbstractArray::length*/;
    (void)memcpy(UNBOX_NativeString(variable[5])+UNTAG_Int(variable[6]), UNBOX_NativeString(variable[4])+UNTAG_Int( TAG_Int(0)), UNTAG_Int( variable[3] /*sl*/));
    variable[4] = variable[0];
    ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/ = TAG_Int(UNTAG_Int(ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/)+UNTAG_Int( variable[3] /*sl*/));
  } else { /*if*/
    CALL_SUPER_string___String___append(variable[0])(variable[0], variable[1]) /*super String::append*/;
  }
  return_label7: while(false);
  tracehead = trace.prev;
  return;
}
void string___String___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 50, LOCATE_string___String___enlarge};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = ATTR_string___String____capacity(variable[4]) /*String::_capacity*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*cap*/)<=UNTAG_Int( variable[3] /*c*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label8;
  }
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*c*/)<=UNTAG_Int( variable[1] /*cap*/));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[4] = TAG_Int(UNTAG_Int( variable[3] /*c*/)*UNTAG_Int( TAG_Int(2)));
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(2)));
    variable[3] = variable[4] /*c=*/;
    continue_9: while(0);
  }
  break_9: while(0);
  variable[5] = variable[0];
  variable[5] = BOX_NativeString((char*)malloc((UNTAG_Int( variable[3] /*c*/) * sizeof(char))));
  variable[4] = variable[5];
  variable[5] = variable[0];
  variable[5] = ATTR_string___String____items(variable[5]) /*String::_items*/;
  variable[6] = variable[0];
  variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*AbstractArray::length*/;
  (void)memcpy(UNBOX_NativeString( variable[4] /*a*/)+UNTAG_Int( TAG_Int(0)), UNBOX_NativeString(variable[5])+UNTAG_Int( TAG_Int(0)), UNTAG_Int(variable[6]));
  variable[5] = variable[0];
  ATTR_string___String____items(variable[5]) /*String::_items*/ =  variable[4] /*a*/;
  variable[5] = variable[0];
  ATTR_string___String____capacity(variable[5]) /*String::_capacity*/ =  variable[3] /*c*/;
  return_label8: while(false);
  tracehead = trace.prev;
  return;
}
val_t string___String___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 94, LOCATE_string___String___to_s};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[3] = NEW_String_string___String___from(variable[2]); /*new String*/
  variable[2] = variable[3];
  variable[1] = variable[2];
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___String_____l(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 209, LOCATE_string___String_____l};
  val_t variable[9];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] =  TAG_Int(0);
  variable[5] = variable[0];
  variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
  variable[4] = variable[5];
  variable[6] = CALL_abstract_collection___Collection___length( variable[1] /*s*/)( variable[1] /*s*/) /*AbstractArray::length*/;
  variable[5] = variable[6];
  while (true) { /*while*/
    variable[6] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l1*/));
    variable[7] = variable[6];
    if (UNTAG_Bool(variable[7])) { /* and */
      variable[7] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[5] /*l2*/));
    }
    variable[6] = variable[7];
    if (!UNTAG_Bool(variable[6])) break; /* while*/
    variable[7] = variable[0];
    variable[7] = CALL_abstract_collection___Map_____bra(variable[7])(variable[7],  variable[3] /*i*/) /*String::[]*/;
    variable[7] = TAG_Int((unsigned char)UNTAG_Char(variable[7]));
    variable[6] = variable[7];
    variable[8] = CALL_abstract_collection___Map_____bra( variable[1] /*s*/)( variable[1] /*s*/,  variable[3] /*i*/) /*String::[]*/;
    variable[8] = TAG_Int((unsigned char)UNTAG_Char(variable[8]));
    variable[7] = variable[8];
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*c1*/)<UNTAG_Int( variable[7] /*c2*/));
    if (UNTAG_Bool(variable[8])) { /*if*/
      variable[2] =  TAG_Bool(true);
      goto return_label11;
    } else { /*if*/
      variable[8] = TAG_Bool(UNTAG_Int( variable[7] /*c2*/)<UNTAG_Int( variable[6] /*c1*/));
      if (UNTAG_Bool(variable[8])) { /*if*/
        variable[2] =  TAG_Bool(false);
        goto return_label11;
      }
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_12: while(0);
  }
  break_12: while(0);
  variable[6] = TAG_Bool(UNTAG_Int( variable[4] /*l1*/)<UNTAG_Int( variable[5] /*l2*/));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[2] =  TAG_Bool(true);
    goto return_label11;
  } else { /*if*/
    variable[2] =  TAG_Bool(false);
    goto return_label11;
  }
  return_label11: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t string___String_____plus(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 73, LOCATE_string___String_____plus};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[5] = CALL_abstract_collection___Collection___length( variable[1] /*s*/)( variable[1] /*s*/) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int(variable[5]));
  variable[5] = NEW_String_string___String___with_capacity(variable[4]); /*new String*/
  variable[4] = variable[5];
  variable[3] = variable[4];
  variable[4] = variable[0];
  CALL_abstract_collection___IndexedCollection___append( variable[3] /*r*/)( variable[3] /*r*/, variable[4]) /*String::append*/;
  CALL_abstract_collection___IndexedCollection___append( variable[3] /*r*/)( variable[3] /*r*/,  variable[1] /*s*/) /*String::append*/;
  variable[2] =  variable[3] /*r*/;
  goto return_label13;
  return_label13: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t string___String_____star(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 82, LOCATE_string___String_____star};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_string___String_____star, LOCATE_string, 85); nit_exit(1);}
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])*UNTAG_Int( variable[1] /*i*/));
  variable[5] = NEW_String_string___String___with_capacity(variable[4]); /*new String*/
  variable[4] = variable[5];
  variable[3] = variable[4];
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*i*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[4] = variable[0];
    CALL_abstract_collection___IndexedCollection___append( variable[3] /*r*/)( variable[3] /*r*/, variable[4]) /*String::append*/;
    variable[1] = TAG_Int(UNTAG_Int(variable[1])-UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_15: while(0);
  }
  break_15: while(0);
  variable[2] =  variable[3] /*r*/;
  goto return_label14;
  return_label14: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t string___String___to_i(val_t  self) {
  struct trace_t trace = {NULL, NULL, 97, LOCATE_string___String___to_i};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_string___String___to_cstring(variable[2])(variable[2]) /*String::to_cstring*/;
  variable[2] = TAG_Int(atoi(UNBOX_NativeString(variable[2])));
  variable[1] = variable[2];
  goto return_label16;
  return_label16: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___String___to_hex(val_t  self) {
  struct trace_t trace = {NULL, NULL, 104, LOCATE_string___String___to_hex};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_string___String___a_to(variable[2])(variable[2],  TAG_Int(16)) /*String::a_to*/;
  variable[1] = variable[2];
  goto return_label17;
  return_label17: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___String___a_to(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 107, LOCATE_string___String___a_to};
  val_t variable[10];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] =  TAG_Int(0);
  variable[4] =  TAG_Bool(false);
  variable[5] = variable[0];
  variable[5] = CALL_abstract_collection___Collection___iterator(variable[5])(variable[5]) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[6] = CALL_abstract_collection___Iterator___is_ok(variable[5])(variable[5]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[6])) break; /*for*/
    variable[6] = CALL_abstract_collection___Iterator___item(variable[5])(variable[5]) /*ArrayIterator::item*/;
    variable[7] = variable[6];
    variable[9] = CALL_kernel___Char___to_i( variable[7] /*c*/)( variable[7] /*c*/) /*Char::to_i*/;
    variable[8] = variable[9];
    variable[9] = TAG_Bool(UNTAG_Int( variable[8] /*v*/)>UNTAG_Int( variable[1] /*base*/));
    if (UNTAG_Bool(variable[9])) { /*if*/
      if (UNTAG_Bool( variable[4] /*neg*/)) { /*if*/
        variable[9] = TAG_Int(-UNTAG_Int( variable[3] /*i*/));
        variable[2] = variable[9];
        goto return_label18;
      } else { /*if*/
        variable[2] =  variable[3] /*i*/;
        goto return_label18;
      }
    } else { /*if*/
      variable[9] = TAG_Bool(UNTAG_Int( variable[8] /*v*/)<UNTAG_Int( TAG_Int(0)));
      if (UNTAG_Bool(variable[9])) { /*if*/
        variable[4] =  TAG_Bool(true) /*neg=*/;
      } else { /*if*/
        variable[9] = TAG_Int(UNTAG_Int( variable[3] /*i*/)*UNTAG_Int( variable[1] /*base*/));
        variable[9] = TAG_Int(UNTAG_Int(variable[9])+UNTAG_Int( variable[8] /*v*/));
        variable[3] = variable[9] /*i=*/;
      }
    }
    continue_19: while(0);
    CALL_abstract_collection___Iterator___next(variable[5])(variable[5]) /*ArrayIterator::next*/;
  }
  break_19: while(0);
  if (UNTAG_Bool( variable[4] /*neg*/)) { /*if*/
    variable[5] = TAG_Int(-UNTAG_Int( variable[3] /*i*/));
    variable[2] = variable[5];
    goto return_label18;
  } else { /*if*/
    variable[2] =  variable[3] /*i*/;
    goto return_label18;
  }
  return_label18: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t string___String___to_cstring(val_t  self) {
  struct trace_t trace = {NULL, NULL, 135, LOCATE_string___String___to_cstring};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___length(variable[3])(variable[3]) /*AbstractArray::length*/;
  CALL_abstract_collection___Map_____braeq(variable[2])(variable[2], variable[3],  TAG_Char('\0')) /*String::[]=*/;
  variable[2] = variable[0];
  ATTR_array___AbstractArray____length(variable[2]) /*AbstractArray::_length*/ = TAG_Int(UNTAG_Int(ATTR_array___AbstractArray____length(variable[2]) /*AbstractArray::_length*/)-UNTAG_Int( TAG_Int(1)));
  variable[2] = variable[0];
  variable[2] = ATTR_string___String____items(variable[2]) /*String::_items*/;
  variable[1] = variable[2];
  goto return_label20;
  return_label20: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___String___substring(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 143, LOCATE_string___String___substring};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*count*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_string___String___substring, LOCATE_string, 151); nit_exit(1);}
  variable[2] = TAG_Int(UNTAG_Int(variable[2])+UNTAG_Int( variable[1] /*from*/)) /*count*/;
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*from*/)<UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[1] =  TAG_Int(0) /*from=*/;
  }
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*count*/)>UNTAG_Int(variable[4]));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
    variable[2] = variable[4] /*count=*/;
  }
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*from*/)<UNTAG_Int( variable[2] /*count*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[5] = TAG_Int(UNTAG_Int( variable[2] /*count*/)-UNTAG_Int( variable[1] /*from*/));
    variable[6] = NEW_String_string___String___with_capacity(variable[5]); /*new String*/
    variable[5] = variable[6];
    variable[4] = variable[5];
    while (true) { /*while*/
      variable[5] = TAG_Bool(UNTAG_Int( variable[1] /*from*/)<UNTAG_Int( variable[2] /*count*/));
      if (!UNTAG_Bool(variable[5])) break; /* while*/
      variable[5] = variable[0];
      variable[5] = ATTR_string___String____items(variable[5]) /*String::_items*/;
      variable[5] = TAG_Char(UNBOX_NativeString(variable[5])[UNTAG_Int( variable[1] /*from*/)]);
      CALL_abstract_collection___IndexedCollection___push( variable[4] /*r*/)( variable[4] /*r*/, variable[5]) /*AbstractArray::push*/;
      variable[1] = TAG_Int(UNTAG_Int(variable[1])+UNTAG_Int( TAG_Int(1))) /*from*/;
      continue_22: while(0);
    }
    break_22: while(0);
    variable[3] =  variable[4] /*r*/;
    goto return_label21;
  } else { /*if*/
    variable[4] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[3] = variable[4];
    goto return_label21;
  }
  return_label21: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t string___String___substring_from(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 167, LOCATE_string___String___substring_from};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___length(variable[3])(variable[3]) /*AbstractArray::length*/;
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*from*/)<UNTAG_Int(variable[3]));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_string___String___substring_from, LOCATE_string, 174); nit_exit(1);}
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( variable[1] /*from*/));
  variable[3] = CALL_string___String___substring(variable[3])(variable[3],  variable[1] /*from*/, variable[4]) /*String::substring*/;
  variable[2] = variable[3];
  goto return_label23;
  return_label23: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t string___String___has_substring(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 178, LOCATE_string___String___has_substring};
  val_t variable[10];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[5] = CALL_abstract_collection___Collection___length( variable[1] /*str*/)( variable[1] /*str*/) /*AbstractArray::length*/;
  variable[5] = TAG_Int(UNTAG_Int(variable[5])-UNTAG_Int( TAG_Int(1)));
  variable[4] = variable[5];
  variable[6] = TAG_Int(UNTAG_Int( variable[2] /*pos*/)+UNTAG_Int( variable[4] /*itsindex*/));
  variable[5] = variable[6];
  variable[7] = variable[0];
  variable[7] = ATTR_string___String____items(variable[7]) /*String::_items*/;
  variable[6] = variable[7];
  variable[8] = ATTR_string___String____items( variable[1] /*str*/) /*String::_items*/;
  variable[7] = variable[8];
  variable[8] = variable[0];
  variable[8] = CALL_abstract_collection___Collection___length(variable[8])(variable[8]) /*AbstractArray::length*/;
  variable[8] = TAG_Bool(UNTAG_Int( variable[5] /*myindex*/)>UNTAG_Int(variable[8]));
  variable[9] = variable[8];
  if (!UNTAG_Bool(variable[9])) { /* or */
    variable[9] = TAG_Bool(UNTAG_Int( variable[4] /*itsindex*/)>UNTAG_Int( variable[5] /*myindex*/));
  }
  variable[8] = variable[9];
  if (UNTAG_Bool(variable[8])) { /*if*/
    variable[3] =  TAG_Bool(false);
    goto return_label24;
  }
  while (true) { /*while*/
    variable[8] = TAG_Bool(UNTAG_Int( variable[4] /*itsindex*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[8])) break; /* while*/
    variable[8] = TAG_Char(UNBOX_NativeString( variable[6] /*myitems*/)[UNTAG_Int( variable[5] /*myindex*/)]);
    variable[9] = TAG_Char(UNBOX_NativeString( variable[7] /*itsitems*/)[UNTAG_Int( variable[4] /*itsindex*/)]);
    variable[8] = TAG_Bool((variable[8])!=(variable[9]));
    if (UNTAG_Bool(variable[8])) { /*if*/
      variable[3] =  TAG_Bool(false);
      goto return_label24;
    }
    variable[5] = TAG_Int(UNTAG_Int(variable[5])-UNTAG_Int( variable[5] /*myindex*/)) /*myindex*/;
    variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( variable[4] /*itsindex*/)) /*itsindex*/;
    continue_25: while(0);
  }
  break_25: while(0);
  variable[3] =  TAG_Bool(true);
  goto return_label24;
  return_label24: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t string___String___has_prefix(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 197, LOCATE_string___String___has_prefix};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_string___String___has_substring(variable[3])(variable[3],  variable[1] /*prefix*/,  TAG_Int(0)) /*String::has_substring*/;
  variable[2] = variable[3];
  goto return_label26;
  return_label26: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t string___String___has_suffix(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 203, LOCATE_string___String___has_suffix};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[5] = CALL_abstract_collection___Collection___length( variable[1] /*suffix*/)( variable[1] /*suffix*/) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int(variable[5]));
  variable[3] = CALL_string___String___has_substring(variable[3])(variable[3],  variable[1] /*suffix*/, variable[4]) /*String::has_substring*/;
  variable[2] = variable[3];
  goto return_label27;
  return_label27: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void string___String___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 231, LOCATE_string___String___init};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i]) return;
  variable[2] = variable[0];
  CALL_string___String___with_capacity(variable[2])(variable[2],  TAG_Int(5), init_table /*YYY*/) /*String::with_capacity*/;
  return_label28: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i] = 1;
  tracehead = trace.prev;
  return;
}
void string___String___from(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 237, LOCATE_string___String___from};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i]) return;
  variable[3] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length( variable[1] /*s*/)( variable[1] /*s*/) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1)));
  ATTR_string___String____capacity(variable[3]) /*String::_capacity*/ = variable[4];
  variable[3] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length( variable[1] /*s*/)( variable[1] /*s*/) /*AbstractArray::length*/;
  ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/ = variable[4];
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[5] = variable[0];
  variable[5] = ATTR_string___String____capacity(variable[5]) /*String::_capacity*/;
  variable[4] = BOX_NativeString((char*)malloc((UNTAG_Int(variable[5]) * sizeof(char))));
  ATTR_string___String____items(variable[3]) /*String::_items*/ = variable[4];
  variable[3] = CALL_string___String___items( variable[1] /*s*/)( variable[1] /*s*/) /*String::items*/;
  variable[4] = variable[0];
  variable[4] = ATTR_string___String____items(variable[4]) /*String::_items*/;
  variable[5] = variable[0];
  variable[5] = ATTR_array___AbstractArray____length(variable[5]) /*AbstractArray::_length*/;
  (void)memcpy(UNBOX_NativeString(variable[4])+UNTAG_Int( TAG_Int(0)), UNBOX_NativeString(variable[3])+UNTAG_Int( TAG_Int(0)), UNTAG_Int(variable[5]));
  return_label29: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i] = 1;
  tracehead = trace.prev;
  return;
}
void string___String___with_capacity(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 245, LOCATE_string___String___with_capacity};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i]) return;
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*cap*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_string___String___with_capacity, LOCATE_string, 248); nit_exit(1);}
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = BOX_NativeString((char*)malloc((UNTAG_Int( variable[1] /*cap*/) * sizeof(char))));
  ATTR_string___String____items(variable[3]) /*String::_items*/ = variable[4];
  variable[3] = variable[0];
  ATTR_string___String____capacity(variable[3]) /*String::_capacity*/ =  variable[1] /*cap*/;
  variable[3] = variable[0];
  ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/ =  TAG_Int(0);
  return_label30: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i] = 1;
  tracehead = trace.prev;
  return;
}
void string___String___with_native(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 255, LOCATE_string___String___with_native};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i]) return;
  variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*size*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_string___String___with_native, LOCATE_string, 258); nit_exit(1);}
  variable[4] = variable[0];
  ATTR_string___String____items(variable[4]) /*String::_items*/ =  variable[1] /*nat*/;
  variable[4] = variable[0];
  ATTR_string___String____capacity(variable[4]) /*String::_capacity*/ =  variable[2] /*size*/;
  variable[4] = variable[0];
  ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/ =  variable[2] /*size*/;
  return_label31: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i] = 1;
  tracehead = trace.prev;
  return;
}
void string___String___from_cstring(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 264, LOCATE_string___String___from_cstring};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i]) return;
  variable[4] = CALL_string___NativeString___cstring_length( variable[1] /*str*/)( variable[1] /*str*/) /*NativeString::cstring_length*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  ATTR_string___String____items(variable[4]) /*String::_items*/ =  variable[1] /*str*/;
  variable[4] = variable[0];
  variable[5] = TAG_Int(UNTAG_Int( variable[3] /*size*/)+UNTAG_Int( TAG_Int(1)));
  ATTR_string___String____capacity(variable[4]) /*String::_capacity*/ = variable[5];
  variable[4] = variable[0];
  ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/ =  variable[3] /*size*/;
  return_label32: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i] = 1;
  tracehead = trace.prev;
  return;
}
void string___String___filled_with(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 273, LOCATE_string___String___filled_with};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i]) return;
  variable[4] = variable[0];
  CALL_string___String___with_capacity(variable[4])(variable[4],  variable[2] /*count*/, init_table /*YYY*/) /*String::with_capacity*/;
  variable[4] =  TAG_Int(0);
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[2] /*count*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = variable[0];
    variable[5] = ATTR_string___String____items(variable[5]) /*String::_items*/;
    UNBOX_NativeString(variable[5])[UNTAG_Int( variable[4] /*i*/)]=UNTAG_Char( variable[1] /*c*/);
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_34: while(0);
  }
  break_34: while(0);
  variable[5] = variable[0];
  ATTR_array___AbstractArray____length(variable[5]) /*AbstractArray::_length*/ =  variable[2] /*count*/;
  return_label33: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_String].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t string___String___to_upper(val_t  self) {
  struct trace_t trace = {NULL, NULL, 310, LOCATE_string___String___to_upper};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___length(variable[3])(variable[3]) /*AbstractArray::length*/;
  variable[4] = NEW_String_string___String___with_capacity(variable[3]); /*new String*/
  variable[3] = variable[4];
  variable[2] = variable[3];
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[3])(variable[3]) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*ArrayIterator::item*/;
    variable[5] = variable[4];
    variable[6] = CALL_kernel___Char___to_upper( variable[5] /*i*/)( variable[5] /*i*/) /*Char::to_upper*/;
    CALL_abstract_collection___SimpleCollection___add( variable[2] /*s*/)( variable[2] /*s*/, variable[6]) /*String::add*/;
    continue_36: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*ArrayIterator::next*/;
  }
  break_36: while(0);
  variable[1] =  variable[2] /*s*/;
  goto return_label35;
  return_label35: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___String___to_lower(val_t  self) {
  struct trace_t trace = {NULL, NULL, 318, LOCATE_string___String___to_lower};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___length(variable[3])(variable[3]) /*AbstractArray::length*/;
  variable[4] = NEW_String_string___String___with_capacity(variable[3]); /*new String*/
  variable[3] = variable[4];
  variable[2] = variable[3];
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[3])(variable[3]) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*ArrayIterator::item*/;
    variable[5] = variable[4];
    variable[6] = CALL_kernel___Char___to_lower( variable[5] /*i*/)( variable[5] /*i*/) /*Char::to_lower*/;
    CALL_abstract_collection___SimpleCollection___add( variable[2] /*s*/)( variable[2] /*s*/, variable[6]) /*String::add*/;
    continue_38: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*ArrayIterator::next*/;
  }
  break_38: while(0);
  variable[1] =  variable[2] /*s*/;
  goto return_label37;
  return_label37: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___String___items(val_t  self) {
  struct trace_t trace = {NULL, NULL, 326, LOCATE_string___String___items};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return ATTR_string___String____items( self) /*String::_items*/;
}
val_t string___String___capacity(val_t  self) {
  struct trace_t trace = {NULL, NULL, 327, LOCATE_string___String___capacity};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return ATTR_string___String____capacity( self) /*String::_capacity*/;
}
val_t string___Object___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 337, LOCATE_string___Object___to_s};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_string___Object___inspect(variable[2])(variable[2]) /*Object::inspect*/;
  variable[1] = variable[2];
  goto return_label39;
  return_label39: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Object___inspect(val_t  self) {
  struct trace_t trace = {NULL, NULL, 340, LOCATE_string___Object___inspect};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[3] = variable[0];
  variable[3] = CALL_string___Object___inspect_head(variable[3])(variable[3]) /*Object::inspect_head*/;
  variable[2] = variable[3];
  CALL_abstract_collection___SimpleCollection___add( variable[2] /*r*/)( variable[2] /*r*/,  TAG_Char('>')) /*String::add*/;
  variable[1] =  variable[2] /*r*/;
  goto return_label40;
  return_label40: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Object___inspect_head(val_t  self) {
  struct trace_t trace = {NULL, NULL, 349, LOCATE_string___Object___inspect_head};
  val_t variable[9];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = NEW_Array_array___Array___with_capacity(TAG_Int(3)); /*new Array[String]*/
  variable[3] = NEW_String_string___String___with_native(BOX_NativeString("<"), TAG_Int(1)); /*new String*/
  variable[4] = variable[3];
  CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[4]) /*AbstractArray::add*/;
  variable[5] = variable[0];
  variable[5] = TAG_Int((bigint)variable[5]);
  variable[5] = CALL_string___Int___to_hex(variable[5])(variable[5]) /*Int::to_hex*/;
  variable[6] = variable[5];
  CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[6]) /*AbstractArray::add*/;
  variable[7] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
  variable[8] = variable[7];
  CALL_abstract_collection___SimpleCollection___add(variable[2])(variable[2], variable[8]) /*AbstractArray::add*/;
  variable[2] = CALL_string___Object___to_s(variable[2])(variable[2]) /*Object::to_s*/;
  variable[1] = variable[2];
  goto return_label41;
  return_label41: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Object___args(val_t  self) {
  struct trace_t trace = {NULL, NULL, 356, LOCATE_string___Object___args};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = (G_sys);
  variable[2] = CALL_string___Object___args(variable[2])(variable[2]) /*Sys::args*/;
  variable[1] = variable[2];
  goto return_label42;
  return_label42: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Bool___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 363, LOCATE_string___Bool___to_s};
    static val_t once_value_44; static int once_bool_44; /* Once value for variable[2]*/
    static val_t once_value_45; static int once_bool_45; /* Once value for variable[2]*/
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  if (UNTAG_Bool(variable[2])) { /*if*/
    if (once_bool_44) variable[2] = once_value_44;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("true"), TAG_Int(4)); /*new String*/
      once_value_44 = variable[2];
      once_bool_44 = true;
    }
    variable[1] = variable[2];
    goto return_label43;
  } else { /*if*/
    if (once_bool_45) variable[2] = once_value_45;
    else {
      variable[2] = NEW_String_string___String___with_native(BOX_NativeString("false"), TAG_Int(5)); /*new String*/
      once_value_45 = variable[2];
      once_bool_45 = true;
    }
    variable[1] = variable[2];
    goto return_label43;
  }
  return_label43: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Int___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 398, LOCATE_string___Int___to_s};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_string___Int___to_base(variable[2])(variable[2],  TAG_Int(10),  TAG_Bool(true)) /*Int::to_base*/;
  variable[1] = variable[2];
  goto return_label46;
  return_label46: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void string___Int___fill_string(val_t  self, val_t  param0, val_t  param1, val_t  param2) {
  struct trace_t trace = {NULL, NULL, 374, LOCATE_string___Int___fill_string};
  val_t variable[9];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  /*variable[5] is variable n*/
  variable[6] = variable[0];
  variable[6] = TAG_Bool(UNTAG_Int(variable[6])<UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = variable[0];
    variable[6] = TAG_Int(-UNTAG_Int(variable[6]));
    variable[5] = variable[6] /*n=*/;
    CALL_abstract_collection___Map_____braeq( variable[1] /*s*/)( variable[1] /*s*/,  TAG_Int(0),  TAG_Char('-')) /*String::[]=*/;
  } else { /*if*/
    variable[6] = variable[0];
    variable[6] = TAG_Bool((variable[6])==( TAG_Int(0)));
    if (UNTAG_Bool(variable[6])) { /*if*/
      CALL_abstract_collection___Map_____braeq( variable[1] /*s*/)( variable[1] /*s*/,  TAG_Int(0),  TAG_Char('0')) /*String::[]=*/;
      goto return_label47;
    } else { /*if*/
      variable[6] = variable[0];
      variable[5] = variable[6] /*n=*/;
    }
  }
  variable[7] = variable[0];
  variable[7] = CALL_kernel___Int___digit_count(variable[7])(variable[7],  variable[2] /*base*/) /*Int::digit_count*/;
  variable[7] = TAG_Int(UNTAG_Int(variable[7])-UNTAG_Int( TAG_Int(1)));
  variable[6] = variable[7];
  while (true) { /*while*/
    variable[7] = TAG_Bool(UNTAG_Int( variable[6] /*pos*/)>=UNTAG_Int( TAG_Int(0)));
    variable[8] = variable[7];
    if (UNTAG_Bool(variable[8])) { /* and */
      variable[8] = TAG_Bool(UNTAG_Int( variable[5] /*n*/)>UNTAG_Int( TAG_Int(0)));
    }
    variable[7] = variable[8];
    if (!UNTAG_Bool(variable[7])) break; /* while*/
    variable[7] = TAG_Int(UNTAG_Int( variable[5] /*n*/)%UNTAG_Int( variable[2] /*base*/));
    variable[7] = CALL_kernel___Int___to_c(variable[7])(variable[7]) /*Int::to_c*/;
    CALL_abstract_collection___Map_____braeq( variable[1] /*s*/)( variable[1] /*s*/,  variable[6] /*pos*/, variable[7]) /*String::[]=*/;
    variable[7] = TAG_Int(UNTAG_Int( variable[5] /*n*/)/UNTAG_Int( variable[2] /*base*/));
    variable[5] = variable[7] /*n=*/;
    variable[6] = TAG_Int(UNTAG_Int(variable[6])-UNTAG_Int( TAG_Int(1))) /*pos*/;
    continue_48: while(0);
  }
  break_48: while(0);
  return_label47: while(false);
  tracehead = trace.prev;
  return;
}
val_t string___Int___to_hex(val_t  self) {
  struct trace_t trace = {NULL, NULL, 401, LOCATE_string___Int___to_hex};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_string___Int___to_base(variable[2])(variable[2],  TAG_Int(16),  TAG_Bool(false)) /*Int::to_base*/;
  variable[1] = variable[2];
  goto return_label49;
  return_label49: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Int___to_base(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 404, LOCATE_string___Int___to_base};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[5] = variable[0];
  variable[5] = CALL_kernel___Int___digit_count(variable[5])(variable[5],  variable[1] /*base*/) /*Int::digit_count*/;
  variable[4] = variable[5];
  variable[6] = NEW_String_string___String___filled_with( TAG_Char(' '),  variable[4] /*l*/); /*new String*/
  variable[5] = variable[6];
  variable[6] = variable[0];
  CALL_string___Int___fill_string(variable[6])(variable[6],  variable[5] /*s*/,  variable[1] /*base*/,  variable[2] /*signed*/) /*Int::fill_string*/;
  variable[3] =  variable[5] /*s*/;
  goto return_label50;
  return_label50: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t string___Float___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 415, LOCATE_string___Float___to_s};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_string___Float___to_precision(variable[2])(variable[2],  TAG_Int(6)) /*Float::to_precision*/;
  variable[1] = variable[2];
  goto return_label51;
  return_label51: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Float___to_precision(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 417, LOCATE_string___Float___to_precision};
  val_t variable[15];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = TAG_Bool(( variable[1] /*nb*/)==( TAG_Int(0)));
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = variable[0];
    variable[3] = TAG_Int((bigint)UNBOX_Float(variable[3]));
    variable[3] = CALL_string___Object___to_s(variable[3])(variable[3]) /*Int::to_s*/;
    variable[2] = variable[3];
    goto return_label52;
  }
  variable[4] = variable[0];
  variable[4] = TAG_Int((bigint)UNBOX_Float(variable[4]));
  variable[3] = variable[4];
  variable[5] = BOX_Float(1.0);
  variable[4] = variable[5];
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[1] /*nb*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = BOX_Float(10.0);
    variable[5] = BOX_Float(UNBOX_Float( variable[4] /*dec*/)*UNBOX_Float(variable[5]));
    variable[4] = variable[5] /*dec=*/;
    variable[1] = TAG_Int(UNTAG_Int(variable[1])-UNTAG_Int( TAG_Int(1))) /*nb*/;
    continue_53: while(0);
  }
  break_53: while(0);
  variable[6] = variable[0];
  variable[7] = BOX_Float((float)UNTAG_Int( variable[3] /*i*/));
  variable[6] = BOX_Float(UNBOX_Float(variable[6])-UNBOX_Float(variable[7]));
  variable[6] = BOX_Float(UNBOX_Float(variable[6])*UNBOX_Float( variable[4] /*dec*/));
  variable[6] = TAG_Int((bigint)UNBOX_Float(variable[6]));
  variable[5] = variable[6];
  variable[6] = NEW_Array_array___Array___with_capacity(TAG_Int(5)); /*new Array[String]*/
  variable[7] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
  variable[8] = variable[7];
  CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[8]) /*AbstractArray::add*/;
  variable[9] =  variable[3] /*i*/;
  variable[9] = CALL_string___Object___to_s(variable[9])(variable[9]) /*Object::to_s*/;
  CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[9]) /*AbstractArray::add*/;
  variable[10] = NEW_String_string___String___with_native(BOX_NativeString("."), TAG_Int(1)); /*new String*/
  variable[11] = variable[10];
  CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[11]) /*AbstractArray::add*/;
  variable[12] =  variable[5] /*d*/;
  variable[12] = CALL_string___Object___to_s(variable[12])(variable[12]) /*Object::to_s*/;
  CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[12]) /*AbstractArray::add*/;
  variable[13] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
  variable[14] = variable[13];
  CALL_abstract_collection___SimpleCollection___add(variable[6])(variable[6], variable[14]) /*AbstractArray::add*/;
  variable[6] = CALL_string___Object___to_s(variable[6])(variable[6]) /*Object::to_s*/;
  variable[2] = variable[6];
  goto return_label52;
  return_label52: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t string___Char___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 434, LOCATE_string___Char___to_s};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[3] = NEW_String_string___String___with_capacity( TAG_Int(1)); /*new String*/
  variable[2] = variable[3];
  variable[3] = variable[0];
  CALL_abstract_collection___Map_____braeq( variable[2] /*s*/)( variable[2] /*s*/,  TAG_Int(0), variable[3]) /*String::[]=*/;
  variable[1] =  variable[2] /*s*/;
  goto return_label54;
  return_label54: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Collection___to_s(val_t  self) {
  struct trace_t trace = {NULL, NULL, 443, LOCATE_string___Collection___to_s};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[3] = NEW_String_string___String___init(); /*new String*/
  variable[2] = variable[3];
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[3])(variable[3]) /*Collection::iterator*/;
  while (true) { /*for*/
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*Iterator::item*/;
    variable[5] = variable[4];
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[5] /*e*/ ==  NIT_NULL /*null*/) || (( variable[5] /*e*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*e*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*e*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*e*/)( variable[5] /*e*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[6] = CALL_string___Object___to_s( variable[5] /*e*/)( variable[5] /*e*/) /*Object::to_s*/;
      CALL_abstract_collection___IndexedCollection___append( variable[2] /*s*/)( variable[2] /*s*/, variable[6]) /*String::append*/;
    }
    continue_56: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*Iterator::next*/;
  }
  break_56: while(0);
  variable[1] =  variable[2] /*s*/;
  goto return_label55;
  return_label55: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Collection___join(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 451, LOCATE_string___Collection___join};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___is_empty(variable[3])(variable[3]) /*Collection::is_empty*/;
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[3] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[2] = variable[3];
    goto return_label57;
  }
  variable[4] = NEW_String_string___String___init(); /*new String*/
  variable[3] = variable[4];
  variable[5] = variable[0];
  variable[5] = CALL_abstract_collection___Collection___iterator(variable[5])(variable[5]) /*Collection::iterator*/;
  variable[4] = variable[5];
  variable[6] = CALL_abstract_collection___Iterator___item( variable[4] /*i*/)( variable[4] /*i*/) /*Iterator::item*/;
  variable[5] = variable[6];
  variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[5] /*e*/ ==  NIT_NULL /*null*/) || (( variable[5] /*e*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*e*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*e*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*e*/)( variable[5] /*e*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[6])) { /*if*/
    variable[6] = CALL_string___Object___to_s( variable[5] /*e*/)( variable[5] /*e*/) /*Object::to_s*/;
    CALL_abstract_collection___IndexedCollection___append( variable[3] /*s*/)( variable[3] /*s*/, variable[6]) /*String::append*/;
  }
  CALL_abstract_collection___Iterator___next( variable[4] /*i*/)( variable[4] /*i*/) /*Iterator::next*/;
  while (true) { /*while*/
    variable[6] = CALL_abstract_collection___Iterator___is_ok( variable[4] /*i*/)( variable[4] /*i*/) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[6])) break; /* while*/
    CALL_abstract_collection___IndexedCollection___append( variable[3] /*s*/)( variable[3] /*s*/,  variable[1] /*sep*/) /*String::append*/;
    variable[6] = CALL_abstract_collection___Iterator___item( variable[4] /*i*/)( variable[4] /*i*/) /*Iterator::item*/;
    variable[5] = variable[6] /*e=*/;
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[5] /*e*/ ==  NIT_NULL /*null*/) || (( variable[5] /*e*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[5] /*e*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[5] /*e*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[5] /*e*/)( variable[5] /*e*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[6] = CALL_string___Object___to_s( variable[5] /*e*/)( variable[5] /*e*/) /*Object::to_s*/;
      CALL_abstract_collection___IndexedCollection___append( variable[3] /*s*/)( variable[3] /*s*/, variable[6]) /*String::append*/;
    }
    CALL_abstract_collection___Iterator___next( variable[4] /*i*/)( variable[4] /*i*/) /*Iterator::next*/;
    continue_58: while(0);
  }
  break_58: while(0);
  variable[2] =  variable[3] /*s*/;
  goto return_label57;
  return_label57: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t string___Map___map_join(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 476, LOCATE_string___Map___map_join};
  val_t variable[20];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___is_empty(variable[4])(variable[4]) /*Collection::is_empty*/;
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[3] = variable[4];
    goto return_label59;
  }
  variable[5] = NEW_String_string___String___init(); /*new String*/
  variable[4] = variable[5];
  variable[6] = variable[0];
  variable[6] = CALL_abstract_collection___Collection___iterator(variable[6])(variable[6]) /*Map::iterator*/;
  variable[5] = variable[6];
  variable[7] = CALL_abstract_collection___MapIterator___key( variable[5] /*i*/)( variable[5] /*i*/) /*MapIterator::key*/;
  variable[6] = variable[7];
  variable[8] = CALL_abstract_collection___Iterator___item( variable[5] /*i*/)( variable[5] /*i*/) /*Iterator::item*/;
  variable[7] = variable[8];
  variable[8] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[7] /*e*/ ==  NIT_NULL /*null*/) || (( variable[7] /*e*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[7] /*e*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[7] /*e*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[7] /*e*/)( variable[7] /*e*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (UNTAG_Bool(variable[8])) { /*if*/
    variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(7)); /*new Array[String]*/
    variable[9] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[10] = variable[9];
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[10]) /*AbstractArray::add*/;
    variable[11] =  variable[6] /*k*/;
    variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[11]) /*AbstractArray::add*/;
    variable[12] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[13] = variable[12];
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[13]) /*AbstractArray::add*/;
    variable[14] =  variable[2] /*couple_sep*/;
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[14]) /*AbstractArray::add*/;
    variable[15] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[16] = variable[15];
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[16]) /*AbstractArray::add*/;
    variable[17] =  variable[7] /*e*/;
    variable[17] = CALL_string___Object___to_s(variable[17])(variable[17]) /*Object::to_s*/;
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[17]) /*AbstractArray::add*/;
    variable[18] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
    variable[19] = variable[18];
    CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[19]) /*AbstractArray::add*/;
    variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
    CALL_abstract_collection___IndexedCollection___append( variable[4] /*s*/)( variable[4] /*s*/, variable[8]) /*String::append*/;
  }
  CALL_abstract_collection___Iterator___next( variable[5] /*i*/)( variable[5] /*i*/) /*Iterator::next*/;
  while (true) { /*while*/
    variable[8] = CALL_abstract_collection___Iterator___is_ok( variable[5] /*i*/)( variable[5] /*i*/) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[8])) break; /* while*/
    CALL_abstract_collection___IndexedCollection___append( variable[4] /*s*/)( variable[4] /*s*/,  variable[1] /*sep*/) /*String::append*/;
    variable[8] = CALL_abstract_collection___MapIterator___key( variable[5] /*i*/)( variable[5] /*i*/) /*MapIterator::key*/;
    variable[6] = variable[8] /*k=*/;
    variable[8] = CALL_abstract_collection___Iterator___item( variable[5] /*i*/)( variable[5] /*i*/) /*Iterator::item*/;
    variable[7] = variable[8] /*e=*/;
    variable[8] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[7] /*e*/ ==  NIT_NULL /*null*/) || (( variable[7] /*e*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[7] /*e*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[7] /*e*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[7] /*e*/)( variable[7] /*e*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[8])) { /*if*/
      variable[8] = NEW_Array_array___Array___with_capacity(TAG_Int(7)); /*new Array[String]*/
      variable[9] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
      variable[10] = variable[9];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[10]) /*AbstractArray::add*/;
      variable[11] =  variable[6] /*k*/;
      variable[11] = CALL_string___Object___to_s(variable[11])(variable[11]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[11]) /*AbstractArray::add*/;
      variable[12] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
      variable[13] = variable[12];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[13]) /*AbstractArray::add*/;
      variable[14] =  variable[2] /*couple_sep*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[14]) /*AbstractArray::add*/;
      variable[15] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
      variable[16] = variable[15];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[16]) /*AbstractArray::add*/;
      variable[17] =  variable[7] /*e*/;
      variable[17] = CALL_string___Object___to_s(variable[17])(variable[17]) /*Object::to_s*/;
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[17]) /*AbstractArray::add*/;
      variable[18] = NEW_String_string___String___with_native(BOX_NativeString(""), TAG_Int(0)); /*new String*/
      variable[19] = variable[18];
      CALL_abstract_collection___SimpleCollection___add(variable[8])(variable[8], variable[19]) /*AbstractArray::add*/;
      variable[8] = CALL_string___Object___to_s(variable[8])(variable[8]) /*Object::to_s*/;
      CALL_abstract_collection___IndexedCollection___append( variable[4] /*s*/)( variable[4] /*s*/, variable[8]) /*String::append*/;
    }
    CALL_abstract_collection___Iterator___next( variable[5] /*i*/)( variable[5] /*i*/) /*Iterator::next*/;
    continue_60: while(0);
  }
  break_60: while(0);
  variable[3] =  variable[4] /*s*/;
  goto return_label59;
  return_label59: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t string___NativeString_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 508, LOCATE_string___NativeString_____bra};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return TAG_Char(UNBOX_NativeString( self)[UNTAG_Int( param0)]);
}
void string___NativeString_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 509, LOCATE_string___NativeString_____braeq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  UNBOX_NativeString( self)[UNTAG_Int( param0)]=UNTAG_Char( param1);
  tracehead = trace.prev;
  return;
}
void string___NativeString___copy_to(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 510, LOCATE_string___NativeString___copy_to};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  (void)memcpy(UNBOX_NativeString( param0)+UNTAG_Int( param3), UNBOX_NativeString( self)+UNTAG_Int( param2), UNTAG_Int( param1));
  tracehead = trace.prev;
  return;
}
val_t string___NativeString___cstring_length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 512, LOCATE_string___NativeString___cstring_length};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] =  TAG_Int(0);
  while (true) { /*while*/
    variable[3] = variable[0];
    variable[3] = TAG_Char(UNBOX_NativeString(variable[3])[UNTAG_Int( variable[2] /*l*/)]);
    variable[3] = TAG_Bool((variable[3])!=( TAG_Char('\0')));
    if (!UNTAG_Bool(variable[3])) break; /* while*/
    variable[2] = TAG_Int(UNTAG_Int(variable[2])+UNTAG_Int( TAG_Int(1))) /*l*/;
    continue_62: while(0);
  }
  break_62: while(0);
  variable[1] =  variable[2] /*l*/;
  goto return_label61;
  return_label61: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___NativeString___atoi(val_t  self) {
  struct trace_t trace = {NULL, NULL, 519, LOCATE_string___NativeString___atoi};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return TAG_Int(atoi(UNBOX_NativeString( self)));
}
void string___NativeString___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 0, LOCATE_string___NativeString___init};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return;
}
val_t string___StringCapable___calloc_string(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 524, LOCATE_string___StringCapable___calloc_string};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return BOX_NativeString((char*)malloc((UNTAG_Int( param0) * sizeof(char))));
}
void string___StringCapable___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 0, LOCATE_string___StringCapable___init};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return;
}
val_t string___Sys___args(val_t  self) {
  struct trace_t trace = {NULL, NULL, 530, LOCATE_string___Sys___args};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_string___Sys____args_cache(variable[2]) /*Sys::_args_cache*/;
  variable[2] = TAG_Bool((variable[2] ==  NIT_NULL /*null*/) || ((variable[2] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[2])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[2], NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[2])(variable[2],  NIT_NULL /*null*/) /*Object::==*/)))));
  if (UNTAG_Bool(variable[2])) { /*if*/
    variable[2] = variable[0];
    CALL_string___Sys___init_args(variable[2])(variable[2]) /*Sys::init_args*/;
  }
  variable[2] = variable[0];
  variable[2] = ATTR_string___Sys____args_cache(variable[2]) /*Sys::_args_cache*/;
  variable[1] = variable[2];
  goto return_label63;
  return_label63: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t string___Sys___program_name(val_t  self) {
  struct trace_t trace = {NULL, NULL, 536, LOCATE_string___Sys___program_name};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_string___Sys___native_argv(variable[2])(variable[2],  TAG_Int(0)) /*Sys::native_argv*/;
  variable[3] = NEW_String_string___String___from_cstring(variable[2]); /*new String*/
  variable[2] = variable[3];
  variable[1] = variable[2];
  goto return_label64;
  return_label64: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void string___Sys___init_args(val_t  self) {
  struct trace_t trace = {NULL, NULL, 542, LOCATE_string___Sys___init_args};
  val_t variable[8];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  variable[0] =  self;
  variable[3] = variable[0];
  variable[3] = CALL_string___Sys___native_argc(variable[3])(variable[3]) /*Sys::native_argc*/;
  variable[2] = variable[3];
  variable[4] = NEW_Array_array___Array___with_capacity( TAG_Int(0)); /*new Array[String]*/
  variable[3] = variable[4];
  variable[4] =  TAG_Int(1);
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[2] /*argc*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = TAG_Int(UNTAG_Int( variable[4] /*i*/)-UNTAG_Int( TAG_Int(1)));
    variable[6] = variable[0];
    variable[6] = CALL_string___Sys___native_argv(variable[6])(variable[6],  variable[4] /*i*/) /*Sys::native_argv*/;
    variable[7] = NEW_String_string___String___from_cstring(variable[6]); /*new String*/
    variable[6] = variable[7];
    CALL_abstract_collection___Map_____braeq( variable[3] /*args*/)( variable[3] /*args*/, variable[5], variable[6]) /*Array::[]=*/;
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_66: while(0);
  }
  break_66: while(0);
  variable[5] = variable[0];
  ATTR_string___Sys____args_cache(variable[5]) /*Sys::_args_cache*/ =  variable[3] /*args*/;
  return_label65: while(false);
  tracehead = trace.prev;
  return;
}
val_t string___Sys___native_argc(val_t  self) {
  struct trace_t trace = {NULL, NULL, 555, LOCATE_string___Sys___native_argc};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return TAG_Int(kernel_Sys_Sys_native_argc_0( self));
}
val_t string___Sys___native_argv(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 557, LOCATE_string___Sys___native_argv};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_string;
  tracehead = trace.prev;
  return BOX_NativeString(kernel_Sys_Sys_native_argv_1( self, UNTAG_Int( param0)));
}
