/* This C file is generated by NIT to compile module array. */
#include "array._sep.h"
val_t array___AbstractArray_____eqeq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 199, LOCATE_array___AbstractArray_____eqeq};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = TAG_Bool(( variable[1] /*o*/==NIT_NULL) || VAL_ISA( variable[1] /*o*/, COLOR_AbstractArray, ID_AbstractArray)) /*cast AbstractArray[E]*/;
  variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3]));
  if (!UNTAG_Bool(variable[3])) { /* or */
    variable[3] = TAG_Bool(IS_EQUAL_NN( variable[1] /*o*/, NIT_NULL /*null*/));
  }
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[2] =  TAG_Bool(false);
    goto return_label0;
  }
  variable[3] = TAG_Bool(( variable[1] /*o*/==NIT_NULL) || VAL_ISA( variable[1] /*o*/, COLOR_AbstractArray, ID_AbstractArray)) /*cast AbstractArray[E]*/;
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___AbstractArray_____eqeq, LOCATE_array, 203); nit_exit(1);}
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[3] = variable[4];
  variable[4] = CALL_abstract_collection___Collection___length( variable[1] /*o*/)( variable[1] /*o*/) /*AbstractArray::length*/;
  variable[4] = TAG_Bool((variable[4])!=( variable[3] /*l*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[2] =  TAG_Bool(false);
    goto return_label0;
  }
  variable[4] =  TAG_Int(0);
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[3] /*l*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = variable[0];
    variable[5] = CALL_abstract_collection___Map_____bra(variable[5])(variable[5],  variable[4] /*i*/) /*Map::[]*/;
    variable[6] = CALL_abstract_collection___Map_____bra( variable[1] /*o*/)( variable[1] /*o*/,  variable[4] /*i*/) /*Map::[]*/;
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] == variable[6]) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5],variable[6])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5], variable[6]) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label0;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_1: while(0);
  }
  break_1: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___AbstractArray___output(val_t  self) {
  struct trace_t trace = {NULL, NULL, 186, LOCATE_array___AbstractArray___output};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] =  TAG_Int(0);
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[3] = variable[4];
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*i*/)<UNTAG_Int( variable[3] /*l*/));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[5] = variable[0];
    variable[5] = CALL_abstract_collection___Map_____bra(variable[5])(variable[5],  variable[2] /*i*/) /*Map::[]*/;
    variable[4] = variable[5];
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*e*/ ==  NIT_NULL /*null*/) || (( variable[4] /*e*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*e*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*e*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*e*/)( variable[4] /*e*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      CALL_kernel___Object___output( variable[4] /*e*/)( variable[4] /*e*/) /*Object::output*/;
    }
    variable[2] = TAG_Int(UNTAG_Int(variable[2])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_3: while(0);
  }
  break_3: while(0);
  return_label2: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___AbstractArray___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 197, LOCATE_array___AbstractArray___iterator};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[3] = NEW_ArrayIterator_array___ArrayIterator___init(variable[2]); /*new ArrayIterator[E]*/
  variable[2] = variable[3];
  variable[1] = variable[2];
  goto return_label4;
  return_label4: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___AbstractArray___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 28, LOCATE_array___AbstractArray___is_empty};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___AbstractArray____length(variable[2]) /*AbstractArray::_length*/;
  variable[2] = TAG_Bool((variable[2])==( TAG_Int(0)));
  variable[1] = variable[2];
  goto return_label5;
  return_label5: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___AbstractArray___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 25, LOCATE_array___AbstractArray___length};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return ATTR_array___AbstractArray____length( self) /*AbstractArray::_length*/;
}
val_t array___AbstractArray___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 75, LOCATE_array___AbstractArray___has};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] =  TAG_Int(0);
  variable[5] = variable[0];
  variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
  variable[4] = variable[5];
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = variable[0];
    variable[5] = CALL_abstract_collection___Map_____bra(variable[5])(variable[5],  variable[3] /*i*/) /*Map::[]*/;
    variable[5] = TAG_Bool((variable[5] ==  variable[1] /*item*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[2] =  TAG_Bool(true);
      goto return_label6;
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_7: while(0);
  }
  break_7: while(0);
  variable[2] =  TAG_Bool(false);
  goto return_label6;
  return_label6: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArray___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 86, LOCATE_array___AbstractArray___has_only};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] =  TAG_Int(0);
  variable[5] = variable[0];
  variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
  variable[4] = variable[5];
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = variable[0];
    variable[5] = CALL_abstract_collection___Map_____bra(variable[5])(variable[5],  variable[3] /*i*/) /*Map::[]*/;
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  variable[1] /*item*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*item*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label8;
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_9: while(0);
  }
  break_9: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label8;
  return_label8: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArray___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 99, LOCATE_array___AbstractArray___count};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] =  TAG_Int(0);
  variable[4] =  TAG_Int(0);
  variable[6] = variable[0];
  variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*AbstractArray::length*/;
  variable[5] = variable[6];
  while (true) { /*while*/
    variable[6] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[5] /*l*/));
    if (!UNTAG_Bool(variable[6])) break; /* while*/
    variable[6] = variable[0];
    variable[6] = CALL_abstract_collection___Map_____bra(variable[6])(variable[6],  variable[4] /*i*/) /*Map::[]*/;
    variable[6] = TAG_Bool((variable[6] ==  variable[1] /*item*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*res*/;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_11: while(0);
  }
  break_11: while(0);
  variable[2] =  variable[3] /*res*/;
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___AbstractArray___clear(val_t  self) {
  struct trace_t trace = {NULL, NULL, 73, LOCATE_array___AbstractArray___clear};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  ATTR_array___AbstractArray____length(variable[2]) /*AbstractArray::_length*/ =  TAG_Int(0);
  return_label12: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 152, LOCATE_array___AbstractArray___remove};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___IndexedCollection___index_of(variable[4])(variable[4],  variable[1] /*item*/) /*AbstractArray::index_of*/;
  CALL_abstract_collection___Map___remove_at(variable[3])(variable[3], variable[4]) /*AbstractArray::remove_at*/;
  return_label13: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 154, LOCATE_array___AbstractArray___remove_all};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___IndexedCollection___index_of(variable[4])(variable[4],  variable[1] /*item*/) /*AbstractArray::index_of*/;
  variable[3] = variable[4];
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[4] = variable[0];
    CALL_abstract_collection___Map___remove_at(variable[4])(variable[4],  variable[3] /*i*/) /*AbstractArray::remove_at*/;
    variable[4] = variable[0];
    variable[4] = CALL_array___AbstractArray___index_of_from(variable[4])(variable[4],  variable[1] /*item*/,  variable[3] /*i*/) /*AbstractArray::index_of_from*/;
    variable[3] = variable[4] /*i=*/;
    continue_15: while(0);
  }
  break_15: while(0);
  return_label14: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___AbstractArray___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 97, LOCATE_array___AbstractArray___has_key};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  variable[4] = variable[3];
  if (UNTAG_Bool(variable[4])) { /* and */
    variable[4] = variable[0];
    variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
    variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)<UNTAG_Int(variable[4]));
  }
  variable[3] = variable[4];
  variable[2] = variable[3];
  goto return_label16;
  return_label16: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___AbstractArray___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 163, LOCATE_array___AbstractArray___remove_at};
  val_t variable[8];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  variable[5] = variable[4];
  if (UNTAG_Bool(variable[5])) { /* and */
    variable[5] = TAG_Bool(UNTAG_Int( variable[1] /*i*/)<UNTAG_Int( variable[3] /*l*/));
  }
  variable[4] = variable[5];
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[5] = TAG_Int(UNTAG_Int( variable[1] /*i*/)+UNTAG_Int( TAG_Int(1)));
    variable[4] = variable[5];
    while (true) { /*while*/
      variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*j*/)<UNTAG_Int( variable[3] /*l*/));
      if (!UNTAG_Bool(variable[5])) break; /* while*/
      variable[5] = variable[0];
      variable[6] = TAG_Int(UNTAG_Int( variable[4] /*j*/)-UNTAG_Int( TAG_Int(1)));
      variable[7] = variable[0];
      variable[7] = CALL_abstract_collection___Map_____bra(variable[7])(variable[7],  variable[4] /*j*/) /*Map::[]*/;
      CALL_abstract_collection___Map_____braeq(variable[5])(variable[5], variable[6], variable[7]) /*Map::[]=*/;
      variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*j*/;
      continue_18: while(0);
    }
    break_18: while(0);
    variable[5] = variable[0];
    variable[6] = TAG_Int(UNTAG_Int( variable[3] /*l*/)-UNTAG_Int( TAG_Int(1)));
    ATTR_array___AbstractArray____length(variable[5]) /*AbstractArray::_length*/ = variable[6];
  }
  return_label17: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 71, LOCATE_array___AbstractArray___add};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  CALL_abstract_collection___Map_____braeq(variable[3])(variable[3], variable[4],  variable[1] /*item*/) /*Map::[]=*/;
  return_label19: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___push(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 30, LOCATE_array___AbstractArray___push};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3],  variable[1] /*item*/) /*AbstractArray::add*/;
  return_label20: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___AbstractArray___pop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 32, LOCATE_array___AbstractArray___pop};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[2])(variable[2]) /*AbstractArray::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[2])))) { fprintf(stderr, "Assert%s failed", " 'not_empty' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___AbstractArray___pop, LOCATE_array, 34); nit_exit(1);}
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___IndexedCollection___last(variable[3])(variable[3]) /*IndexedCollection::last*/;
  variable[2] = variable[3];
  variable[3] = variable[0];
  ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/ = TAG_Int(UNTAG_Int(ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/)-UNTAG_Int( TAG_Int(1)));
  variable[1] =  variable[2] /*r*/;
  goto return_label21;
  return_label21: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___AbstractArray___unshift(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 54, LOCATE_array___AbstractArray___unshift};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[4];
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[4] = variable[0];
    variable[5] = TAG_Int(UNTAG_Int( variable[3] /*i*/)+UNTAG_Int( TAG_Int(1)));
    variable[6] = variable[0];
    variable[6] = CALL_abstract_collection___Map_____bra(variable[6])(variable[6],  variable[3] /*i*/) /*Map::[]*/;
    CALL_abstract_collection___Map_____braeq(variable[4])(variable[4], variable[5], variable[6]) /*Map::[]=*/;
    variable[3] = TAG_Int(UNTAG_Int(variable[3])-UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_23: while(0);
  }
  break_23: while(0);
  variable[4] = variable[0];
  CALL_abstract_collection___Map_____braeq(variable[4])(variable[4],  TAG_Int(0),  variable[1] /*item*/) /*Map::[]=*/;
  return_label22: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___AbstractArray___shift(val_t  self) {
  struct trace_t trace = {NULL, NULL, 40, LOCATE_array___AbstractArray___shift};
  val_t variable[8];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[2])(variable[2]) /*AbstractArray::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[2])))) { fprintf(stderr, "Assert%s failed", " 'not_empty' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___AbstractArray___shift, LOCATE_array, 42); nit_exit(1);}
  variable[3] = variable[0];
  variable[3] = CALL_abstract_collection___Collection___first(variable[3])(variable[3]) /*IndexedCollection::first*/;
  variable[2] = variable[3];
  variable[3] =  TAG_Int(1);
  variable[5] = variable[0];
  variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
  variable[4] = variable[5];
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = variable[0];
    variable[6] = TAG_Int(UNTAG_Int( variable[3] /*i*/)-UNTAG_Int( TAG_Int(1)));
    variable[7] = variable[0];
    variable[7] = CALL_abstract_collection___Map_____bra(variable[7])(variable[7],  variable[3] /*i*/) /*Map::[]*/;
    CALL_abstract_collection___Map_____braeq(variable[5])(variable[5], variable[6], variable[7]) /*Map::[]=*/;
    variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_25: while(0);
  }
  break_25: while(0);
  variable[5] = variable[0];
  variable[6] = TAG_Int(UNTAG_Int( variable[4] /*l*/)-UNTAG_Int( TAG_Int(1)));
  ATTR_array___AbstractArray____length(variable[5]) /*AbstractArray::_length*/ = variable[6];
  variable[1] =  variable[2] /*r*/;
  goto return_label24;
  return_label24: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___AbstractArray___index_of(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 111, LOCATE_array___AbstractArray___index_of};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_array___AbstractArray___index_of_from(variable[3])(variable[3],  variable[1] /*item*/,  TAG_Int(0)) /*AbstractArray::index_of_from*/;
  variable[2] = variable[3];
  goto return_label26;
  return_label26: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___AbstractArray___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 23, LOCATE_array___AbstractArray___enlarge};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_array, 23);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___insert(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 64, LOCATE_array___AbstractArray___insert};
  val_t variable[8];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = variable[0];
  variable[5] = variable[0];
  variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
  variable[5] = TAG_Int(UNTAG_Int(variable[5])+UNTAG_Int( TAG_Int(1)));
  CALL_array___AbstractArray___enlarge(variable[4])(variable[4], variable[5]) /*AbstractArray::enlarge*/;
  variable[4] = variable[0];
  variable[5] = variable[0];
  variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
  variable[5] = TAG_Int(UNTAG_Int(variable[5])-UNTAG_Int( variable[2] /*pos*/));
  variable[6] = variable[0];
  variable[7] = TAG_Int(UNTAG_Int( variable[2] /*pos*/)+UNTAG_Int( TAG_Int(1)));
  CALL_array___AbstractArray___copy_to(variable[4])(variable[4],  variable[2] /*pos*/, variable[5], variable[6], variable[7]) /*AbstractArray::copy_to*/;
  variable[4] = variable[0];
  CALL_abstract_collection___Map_____braeq(variable[4])(variable[4],  variable[2] /*pos*/,  variable[1] /*item*/) /*Map::[]=*/;
  return_label27: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___AbstractArray___last_index_of(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 113, LOCATE_array___AbstractArray___last_index_of};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1)));
  variable[3] = CALL_array___AbstractArray___last_index_of_from(variable[3])(variable[3],  variable[1] /*item*/, variable[4]) /*AbstractArray::last_index_of_from*/;
  variable[2] = variable[3];
  goto return_label28;
  return_label28: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArray___index_of_from(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 115, LOCATE_array___AbstractArray___index_of_from};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] =  variable[2] /*pos*/;
  variable[6] = variable[0];
  variable[6] = CALL_abstract_collection___Collection___length(variable[6])(variable[6]) /*AbstractArray::length*/;
  variable[5] = variable[6];
  while (true) { /*while*/
    variable[6] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[5] /*len*/));
    if (!UNTAG_Bool(variable[6])) break; /* while*/
    variable[6] = variable[0];
    variable[6] = CALL_abstract_collection___Map_____bra(variable[6])(variable[6],  variable[4] /*i*/) /*Map::[]*/;
    variable[6] = TAG_Bool((variable[6] ==  variable[1] /*item*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[3] =  variable[4] /*i*/;
      goto return_label29;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_30: while(0);
  }
  break_30: while(0);
  variable[6] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[6];
  goto return_label29;
  return_label29: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t array___AbstractArray___last_index_of_from(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 128, LOCATE_array___AbstractArray___last_index_of_from};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] =  variable[2] /*pos*/;
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)>=UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = variable[0];
    variable[5] = CALL_abstract_collection___Map_____bra(variable[5])(variable[5],  variable[4] /*i*/) /*Map::[]*/;
    variable[5] = TAG_Bool((variable[5] ==  variable[1] /*item*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[3] =  variable[4] /*i*/;
      goto return_label31;
    } else { /*if*/
      variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1))) /*i*/;
    }
    continue_32: while(0);
  }
  break_32: while(0);
  variable[5] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[5];
  goto return_label31;
  return_label31: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t array___AbstractArray___reversed(val_t  self) {
  struct trace_t trace = {NULL, NULL, 141, LOCATE_array___AbstractArray___reversed};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[3] = variable[0];
  variable[3] = ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/;
  variable[2] = variable[3];
  variable[4] = NEW_Array_array___Array___with_capacity( variable[2] /*cmp*/); /*new Array[E]*/
  variable[3] = variable[4];
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*cmp*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[2] = TAG_Int(UNTAG_Int(variable[2])-UNTAG_Int( TAG_Int(1))) /*cmp*/;
    variable[4] = variable[0];
    variable[4] = CALL_abstract_collection___Map_____bra(variable[4])(variable[4],  variable[2] /*cmp*/) /*Map::[]*/;
    CALL_abstract_collection___SimpleCollection___add( variable[3] /*result*/)( variable[3] /*result*/, variable[4]) /*AbstractArray::add*/;
    continue_34: while(0);
  }
  break_34: while(0);
  variable[1] =  variable[3] /*result*/;
  goto return_label33;
  return_label33: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___AbstractArray___copy_to(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 176, LOCATE_array___AbstractArray___copy_to};
  val_t variable[10];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[3] =  param2;
  variable[4] =  param3;
  variable[6] =  variable[2] /*len*/;
  while (true) { /*while*/
    variable[7] = TAG_Bool(UNTAG_Int( variable[6] /*i*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[7])) break; /* while*/
    variable[6] = TAG_Int(UNTAG_Int(variable[6])-UNTAG_Int( TAG_Int(1))) /*i*/;
    variable[7] = TAG_Int(UNTAG_Int( variable[4] /*new_start*/)+UNTAG_Int( variable[6] /*i*/));
    variable[8] = variable[0];
    variable[9] = TAG_Int(UNTAG_Int( variable[1] /*start*/)+UNTAG_Int( variable[6] /*i*/));
    variable[8] = CALL_abstract_collection___Map_____bra(variable[8])(variable[8], variable[9]) /*Map::[]*/;
    CALL_abstract_collection___Map_____braeq( variable[3] /*dest*/)( variable[3] /*dest*/, variable[7], variable[8]) /*Map::[]=*/;
    continue_36: while(0);
  }
  break_36: while(0);
  return_label35: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 0, LOCATE_array___AbstractArray___init};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return;
}
val_t array___Array_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 227, LOCATE_array___Array_____bra};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  variable[4] = variable[3];
  if (UNTAG_Bool(variable[4])) { /* and */
    variable[4] = variable[0];
    variable[4] = ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/;
    variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)<UNTAG_Int(variable[4]));
  }
  variable[3] = variable[4];
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 229); nit_exit(1);}
  variable[3] = variable[0];
  variable[3] = ATTR_array___Array____items(variable[3]) /*Array::_items*/;
  variable[3] = UNBOX_NativeArray(variable[3])[UNTAG_Int( variable[1] /*index*/)];
  variable[2] = variable[3];
  goto return_label37;
  return_label37: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___Array_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 233, LOCATE_array___Array_____braeq};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  variable[5] = variable[4];
  if (UNTAG_Bool(variable[5])) { /* and */
    variable[5] = variable[0];
    variable[5] = ATTR_array___AbstractArray____length(variable[5]) /*AbstractArray::_length*/;
    variable[5] = TAG_Int(UNTAG_Int(variable[5])+UNTAG_Int( TAG_Int(1)));
    variable[5] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)<UNTAG_Int(variable[5]));
  }
  variable[4] = variable[5];
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____braeq, LOCATE_array, 235); nit_exit(1);}
  variable[4] = variable[0];
  variable[4] = ATTR_array___Array____capacity(variable[4]) /*Array::_capacity*/;
  variable[4] = TAG_Bool(UNTAG_Int(variable[4])<=UNTAG_Int( variable[1] /*index*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = TAG_Int(UNTAG_Int( variable[1] /*index*/)+UNTAG_Int( TAG_Int(1)));
    CALL_array___AbstractArray___enlarge(variable[4])(variable[4], variable[5]) /*Array::enlarge*/;
  }
  variable[4] = variable[0];
  variable[4] = ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/;
  variable[4] = TAG_Bool(UNTAG_Int(variable[4])<=UNTAG_Int( variable[1] /*index*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[5] = TAG_Int(UNTAG_Int( variable[1] /*index*/)+UNTAG_Int( TAG_Int(1)));
    ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/ = variable[5];
  }
  variable[4] = variable[0];
  variable[4] = ATTR_array___Array____items(variable[4]) /*Array::_items*/;
  UNBOX_NativeArray(variable[4])[UNTAG_Int( variable[1] /*index*/)]= variable[2] /*item*/;
  return_label38: while(false);
  tracehead = trace.prev;
  return;
}
void array___Array___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 245, LOCATE_array___Array___enlarge};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = ATTR_array___Array____capacity(variable[4]) /*Array::_capacity*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*cap*/)<=UNTAG_Int( variable[3] /*c*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label39;
  }
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*c*/)<=UNTAG_Int( variable[1] /*cap*/));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[4] = TAG_Int(UNTAG_Int( variable[3] /*c*/)*UNTAG_Int( TAG_Int(2)));
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(2)));
    variable[3] = variable[4] /*c=*/;
    continue_40: while(0);
  }
  break_40: while(0);
  variable[5] = variable[0];
  variable[5] = BOX_NativeArray((val_t*)malloc((UNTAG_Int( variable[3] /*c*/) * sizeof(val_t))));
  variable[4] = variable[5];
  variable[5] = variable[0];
  variable[5] = ATTR_array___Array____capacity(variable[5]) /*Array::_capacity*/;
  variable[5] = TAG_Bool(UNTAG_Int(variable[5])>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[5] = variable[0];
    variable[5] = ATTR_array___Array____items(variable[5]) /*Array::_items*/;
    variable[6] = variable[0];
    variable[6] = ATTR_array___AbstractArray____length(variable[6]) /*AbstractArray::_length*/;
    (void)memcpy(UNBOX_NativeArray( variable[4] /*a*/), UNBOX_NativeArray(variable[5]), UNTAG_Int(variable[6])*sizeof(val_t));
  }
  variable[5] = variable[0];
  ATTR_array___Array____items(variable[5]) /*Array::_items*/ =  variable[4] /*a*/;
  variable[5] = variable[0];
  ATTR_array___Array____capacity(variable[5]) /*Array::_capacity*/ =  variable[3] /*c*/;
  return_label39: while(false);
  tracehead = trace.prev;
  return;
}
void array___Array___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 256, LOCATE_array___Array___init};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  variable[2] = variable[0];
  ATTR_array___Array____capacity(variable[2]) /*Array::_capacity*/ =  TAG_Int(0);
  variable[2] = variable[0];
  ATTR_array___AbstractArray____length(variable[2]) /*AbstractArray::_length*/ =  TAG_Int(0);
  return_label41: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___Array___with_items(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 263, LOCATE_array___Array___with_items};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  /* check if p<Array[E] with p:E */
  if (( param0!=NIT_NULL) && !VAL_ISA( param0, COLOR_Array, ID_Array)) { fprintf(stderr, "Cast failled"); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array___with_items, LOCATE_array, 264); nit_exit(1); } /*cast Array[E]*/;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  variable[3] = variable[0];
  variable[4] = ATTR_array___Array____items( variable[1] /*objects*/) /*Array::_items*/;
  ATTR_array___Array____items(variable[3]) /*Array::_items*/ = variable[4];
  variable[3] = variable[0];
  variable[4] = ATTR_array___Array____capacity( variable[1] /*objects*/) /*Array::_capacity*/;
  ATTR_array___Array____capacity(variable[3]) /*Array::_capacity*/ = variable[4];
  variable[3] = variable[0];
  variable[4] = CALL_abstract_collection___Collection___length( variable[1] /*objects*/)( variable[1] /*objects*/) /*AbstractArray::length*/;
  ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/ = variable[4];
  return_label42: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___Array___with_capacity(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 271, LOCATE_array___Array___with_capacity};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*cap*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", " 'positive' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array___with_capacity, LOCATE_array, 274); nit_exit(1);}
  variable[3] = variable[0];
  variable[4] = variable[0];
  variable[4] = BOX_NativeArray((val_t*)malloc((UNTAG_Int( variable[1] /*cap*/) * sizeof(val_t))));
  ATTR_array___Array____items(variable[3]) /*Array::_items*/ = variable[4];
  variable[3] = variable[0];
  ATTR_array___Array____capacity(variable[3]) /*Array::_capacity*/ =  variable[1] /*cap*/;
  variable[3] = variable[0];
  ATTR_array___AbstractArray____length(variable[3]) /*AbstractArray::_length*/ =  TAG_Int(0);
  return_label43: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___Array___filled_with(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 280, LOCATE_array___Array___filled_with};
  val_t variable[6];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*count*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", " 'positive' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array___filled_with, LOCATE_array, 283); nit_exit(1);}
  variable[4] = variable[0];
  variable[5] = variable[0];
  variable[5] = BOX_NativeArray((val_t*)malloc((UNTAG_Int( variable[2] /*count*/) * sizeof(val_t))));
  ATTR_array___Array____items(variable[4]) /*Array::_items*/ = variable[5];
  variable[4] = variable[0];
  ATTR_array___Array____capacity(variable[4]) /*Array::_capacity*/ =  variable[2] /*count*/;
  variable[4] = variable[0];
  ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/ =  variable[2] /*count*/;
  variable[4] =  TAG_Int(0);
  while (true) { /*while*/
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[2] /*count*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = variable[0];
    CALL_abstract_collection___Map_____braeq(variable[5])(variable[5],  variable[4] /*i*/,  variable[1] /*value*/) /*Array::[]=*/;
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_45: while(0);
  }
  break_45: while(0);
  return_label44: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___Array___with_native(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 294, LOCATE_array___Array___with_native};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*size*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", " 'positive' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array___with_native, LOCATE_array, 297); nit_exit(1);}
  variable[4] = variable[0];
  ATTR_array___Array____items(variable[4]) /*Array::_items*/ =  variable[1] /*nat*/;
  variable[4] = variable[0];
  ATTR_array___Array____capacity(variable[4]) /*Array::_capacity*/ =  variable[2] /*size*/;
  variable[4] = variable[0];
  ATTR_array___AbstractArray____length(variable[4]) /*AbstractArray::_length*/ =  variable[2] /*size*/;
  return_label46: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___ArrayIterator___item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 313, LOCATE_array___ArrayIterator___item};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArrayIterator____array(variable[2]) /*ArrayIterator::_array*/;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArrayIterator____index(variable[3]) /*ArrayIterator::_index*/;
  variable[2] = CALL_abstract_collection___Map_____bra(variable[2])(variable[2], variable[3]) /*Map::[]*/;
  variable[1] = variable[2];
  goto return_label47;
  return_label47: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArrayIterator___next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 319, LOCATE_array___ArrayIterator___next};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  ATTR_array___ArrayIterator____index(variable[2]) /*ArrayIterator::_index*/ = TAG_Int(UNTAG_Int(ATTR_array___ArrayIterator____index(variable[2]) /*ArrayIterator::_index*/)+UNTAG_Int( TAG_Int(1)));
  return_label48: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 317, LOCATE_array___ArrayIterator___is_ok};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArrayIterator____index(variable[2]) /*ArrayIterator::_index*/;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArrayIterator____array(variable[3]) /*ArrayIterator::_array*/;
  variable[3] = CALL_abstract_collection___Collection___length(variable[3])(variable[3]) /*AbstractArray::length*/;
  variable[2] = TAG_Bool(UNTAG_Int(variable[2])<UNTAG_Int(variable[3]));
  variable[1] = variable[2];
  goto return_label49;
  return_label49: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArrayIterator___item__eq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 315, LOCATE_array___ArrayIterator___item__eq};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArrayIterator____array(variable[3]) /*ArrayIterator::_array*/;
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArrayIterator____index(variable[4]) /*ArrayIterator::_index*/;
  CALL_abstract_collection___Map_____braeq(variable[3])(variable[3], variable[4],  variable[1] /*e*/) /*Map::[]=*/;
  return_label50: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayIterator___index(val_t  self) {
  struct trace_t trace = {NULL, NULL, 328, LOCATE_array___ArrayIterator___index};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return ATTR_array___ArrayIterator____index( self) /*ArrayIterator::_index*/;
}
void array___ArrayIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 321, LOCATE_array___ArrayIterator___init};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArrayIterator].i]) return;
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[1] /*a*/ ==  NIT_NULL /*null*/) || (( variable[1] /*a*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[1] /*a*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[1] /*a*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[1] /*a*/)( variable[1] /*a*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", " 'not_nil' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___ArrayIterator___init, LOCATE_array, 323); nit_exit(1);}
  variable[3] = variable[0];
  ATTR_array___ArrayIterator____array(variable[3]) /*ArrayIterator::_array*/ =  variable[1] /*a*/;
  variable[3] = variable[0];
  ATTR_array___ArrayIterator____index(variable[3]) /*ArrayIterator::_index*/ =  TAG_Int(0);
  return_label51: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArrayIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___ArraySet___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 364, LOCATE_array___ArraySet___iterator};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySet____array(variable[2]) /*ArraySet::_array*/;
  variable[2] = CALL_abstract_collection___Collection___iterator(variable[2])(variable[2]) /*AbstractArray::iterator*/;
  variable[3] = NEW_ArraySetIterator_array___ArraySetIterator___init(variable[2]); /*new ArraySetIterator[E]*/
  variable[2] = variable[3];
  variable[1] = variable[2];
  goto return_label52;
  return_label52: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArraySet___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 344, LOCATE_array___ArraySet___is_empty};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySet____array(variable[2]) /*ArraySet::_array*/;
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[2])(variable[2]) /*AbstractArray::is_empty*/;
  variable[1] = variable[2];
  goto return_label53;
  return_label53: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArraySet___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 346, LOCATE_array___ArraySet___length};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySet____array(variable[2]) /*ArraySet::_array*/;
  variable[2] = CALL_abstract_collection___Collection___length(variable[2])(variable[2]) /*AbstractArray::length*/;
  variable[1] = variable[2];
  goto return_label54;
  return_label54: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArraySet___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 340, LOCATE_array___ArraySet___has};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArraySet____array(variable[3]) /*ArraySet::_array*/;
  variable[3] = CALL_abstract_collection___Collection___has(variable[3])(variable[3],  variable[1] /*e*/) /*AbstractArray::has*/;
  variable[2] = variable[3];
  goto return_label55;
  return_label55: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArraySet___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 348, LOCATE_array___ArraySet___first};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySet____array(variable[2]) /*ArraySet::_array*/;
  variable[2] = CALL_abstract_collection___Collection___length(variable[2])(variable[2]) /*AbstractArray::length*/;
  variable[2] = TAG_Bool(UNTAG_Int(variable[2])>UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[2])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___ArraySet___first, LOCATE_array, 350); nit_exit(1);}
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySet____array(variable[2]) /*ArraySet::_array*/;
  variable[2] = CALL_abstract_collection___Collection___first(variable[2])(variable[2]) /*IndexedCollection::first*/;
  variable[1] = variable[2];
  goto return_label56;
  return_label56: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArraySet___clear(val_t  self) {
  struct trace_t trace = {NULL, NULL, 362, LOCATE_array___ArraySet___clear};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySet____array(variable[2]) /*ArraySet::_array*/;
  CALL_abstract_collection___RemovableCollection___clear(variable[2])(variable[2]) /*AbstractArray::clear*/;
  return_label57: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 354, LOCATE_array___ArraySet___remove};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArraySet____array(variable[4]) /*ArraySet::_array*/;
  variable[4] = CALL_abstract_collection___IndexedCollection___index_of(variable[4])(variable[4],  variable[1] /*item*/) /*AbstractArray::index_of*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    CALL_array___ArraySet___remove_at(variable[4])(variable[4],  variable[3] /*i*/) /*ArraySet::remove_at*/;
  }
  return_label58: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 360, LOCATE_array___ArraySet___remove_all};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  CALL_abstract_collection___RemovableCollection___remove(variable[3])(variable[3],  variable[1] /*item*/) /*ArraySet::remove*/;
  return_label59: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 342, LOCATE_array___ArraySet___add};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArraySet____array(variable[3]) /*ArraySet::_array*/;
  variable[3] = CALL_abstract_collection___Collection___has(variable[3])(variable[3],  variable[1] /*e*/) /*AbstractArray::has*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    variable[3] = variable[0];
    variable[3] = ATTR_array___ArraySet____array(variable[3]) /*ArraySet::_array*/;
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3],  variable[1] /*e*/) /*AbstractArray::add*/;
  }
  return_label60: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 366, LOCATE_array___ArraySet___enlarge};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArraySet____array(variable[3]) /*ArraySet::_array*/;
  CALL_array___AbstractArray___enlarge(variable[3])(variable[3],  variable[1] /*cap*/) /*Array::enlarge*/;
  return_label61: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 369, LOCATE_array___ArraySet___remove_at};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArraySet____array(variable[3]) /*ArraySet::_array*/;
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArraySet____array(variable[4]) /*ArraySet::_array*/;
  variable[4] = CALL_abstract_collection___IndexedCollection___last(variable[4])(variable[4]) /*IndexedCollection::last*/;
  CALL_abstract_collection___Map_____braeq(variable[3])(variable[3],  variable[1] /*i*/, variable[4]) /*Array::[]=*/;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArraySet____array(variable[3]) /*ArraySet::_array*/;
  CALL_abstract_collection___IndexedCollection___pop(variable[3])(variable[3]) /*AbstractArray::pop*/;
  return_label62: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 375, LOCATE_array___ArraySet___init};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySet].i]) return;
  variable[2] = variable[0];
  variable[3] = NEW_Array_array___Array___init(); /*new Array[E]*/
  ATTR_array___ArraySet____array(variable[2]) /*ArraySet::_array*/ = variable[3];
  return_label63: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySet].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___ArraySet___with_capacity(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 378, LOCATE_array___ArraySet___with_capacity};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySet].i]) return;
  variable[3] = variable[0];
  variable[4] = NEW_Array_array___Array___with_capacity( variable[1] /*i*/); /*new Array[E]*/
  ATTR_array___ArraySet____array(variable[3]) /*ArraySet::_array*/ = variable[4];
  return_label64: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySet].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___ArraySetIterator___item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 390, LOCATE_array___ArraySetIterator___item};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySetIterator____iter(variable[2]) /*ArraySetIterator::_iter*/;
  variable[2] = CALL_abstract_collection___Iterator___item(variable[2])(variable[2]) /*ArrayIterator::item*/;
  variable[1] = variable[2];
  goto return_label65;
  return_label65: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArraySetIterator___next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 388, LOCATE_array___ArraySetIterator___next};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySetIterator____iter(variable[2]) /*ArraySetIterator::_iter*/;
  CALL_abstract_collection___Iterator___next(variable[2])(variable[2]) /*ArrayIterator::next*/;
  return_label66: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArraySetIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 386, LOCATE_array___ArraySetIterator___is_ok};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArraySetIterator____iter(variable[2]) /*ArraySetIterator::_iter*/;
  variable[2] = CALL_abstract_collection___Iterator___is_ok(variable[2])(variable[2]) /*ArrayIterator::is_ok*/;
  variable[1] = variable[2];
  goto return_label67;
  return_label67: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArraySetIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 392, LOCATE_array___ArraySetIterator___init};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySetIterator].i]) return;
  variable[3] = variable[0];
  ATTR_array___ArraySetIterator____iter(variable[3]) /*ArraySetIterator::_iter*/ =  variable[1] /*iter*/;
  return_label68: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySetIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 454, LOCATE_array___ArrayMap___iterator};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArrayMap____items(variable[2]) /*ArrayMap::_items*/;
  variable[2] = CALL_abstract_collection___Collection___iterator(variable[2])(variable[2]) /*AbstractArray::iterator*/;
  variable[3] = NEW_CoupleMapIterator_abstract_collection___CoupleMapIterator___init(variable[2]); /*new CoupleMapIterator[K, E]*/
  variable[2] = variable[3];
  variable[1] = variable[2];
  goto return_label69;
  return_label69: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayMap___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 456, LOCATE_array___ArrayMap___is_empty};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArrayMap____items(variable[2]) /*ArrayMap::_items*/;
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[2])(variable[2]) /*AbstractArray::is_empty*/;
  variable[1] = variable[2];
  goto return_label70;
  return_label70: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayMap___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 441, LOCATE_array___ArrayMap___length};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArrayMap____items(variable[2]) /*ArrayMap::_items*/;
  variable[2] = CALL_abstract_collection___Collection___length(variable[2])(variable[2]) /*AbstractArray::length*/;
  variable[1] = variable[2];
  goto return_label71;
  return_label71: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayMap___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 427, LOCATE_array___ArrayMap___has};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArrayMap____items(variable[3]) /*ArrayMap::_items*/;
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[3])(variable[3]) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*ArrayIterator::item*/;
    variable[5] = variable[4];
    variable[6] = CALL_abstract_collection___Couple___second( variable[5] /*i*/)( variable[5] /*i*/) /*Couple::second*/;
    variable[6] = TAG_Bool((variable[6] ==  variable[1] /*item*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[2] =  TAG_Bool(true);
      goto return_label72;
    }
    continue_73: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*ArrayIterator::next*/;
  }
  break_73: while(0);
  variable[2] =  TAG_Bool(false);
  goto return_label72;
  return_label72: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArrayMap___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 434, LOCATE_array___ArrayMap___has_only};
  val_t variable[7];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArrayMap____items(variable[3]) /*ArrayMap::_items*/;
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[3])(variable[3]) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*ArrayIterator::item*/;
    variable[5] = variable[4];
    variable[6] = CALL_abstract_collection___Couple___second( variable[5] /*i*/)( variable[5] /*i*/) /*Couple::second*/;
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[6] ==  variable[1] /*item*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  variable[1] /*item*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label74;
    }
    continue_75: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*ArrayIterator::next*/;
  }
  break_75: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label74;
  return_label74: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArrayMap___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 446, LOCATE_array___ArrayMap___count};
  val_t variable[8];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] =  TAG_Int(0);
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
  variable[4] = CALL_abstract_collection___Collection___iterator(variable[4])(variable[4]) /*AbstractArray::iterator*/;
  while (true) { /*for*/
    variable[5] = CALL_abstract_collection___Iterator___is_ok(variable[4])(variable[4]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[5])) break; /*for*/
    variable[5] = CALL_abstract_collection___Iterator___item(variable[4])(variable[4]) /*ArrayIterator::item*/;
    variable[6] = variable[5];
    variable[7] = CALL_abstract_collection___Couple___second( variable[6] /*i*/)( variable[6] /*i*/) /*Couple::second*/;
    variable[7] = TAG_Bool((variable[7] ==  variable[1] /*item*/) || ((variable[7] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[7])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[7], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[7])(variable[7],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[7])) { /*if*/
      variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*nb*/;
    }
    continue_77: while(0);
    CALL_abstract_collection___Iterator___next(variable[4])(variable[4]) /*ArrayIterator::next*/;
  }
  break_77: while(0);
  variable[2] =  variable[3] /*nb*/;
  goto return_label76;
  return_label76: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArrayMap___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 444, LOCATE_array___ArrayMap___first};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArrayMap____items(variable[2]) /*ArrayMap::_items*/;
  variable[2] = CALL_abstract_collection___Collection___first(variable[2])(variable[2]) /*IndexedCollection::first*/;
  variable[2] = CALL_abstract_collection___Couple___first(variable[2])(variable[2]) /*Couple::first*/;
  variable[1] = variable[2];
  goto return_label78;
  return_label78: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArrayMap___clear(val_t  self) {
  struct trace_t trace = {NULL, NULL, 487, LOCATE_array___ArrayMap___clear};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = ATTR_array___ArrayMap____items(variable[2]) /*ArrayMap::_items*/;
  CALL_abstract_collection___RemovableCollection___clear(variable[2])(variable[2]) /*AbstractArray::clear*/;
  return_label79: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArrayMap___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 458, LOCATE_array___ArrayMap___remove};
  val_t variable[10];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[4];
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[4] = variable[0];
    variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
    variable[5] = variable[4];
    variable[6] =  variable[3] /*i*/;
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[9] = variable[8];
    if (UNTAG_Bool(variable[9])) { /* and */
      variable[9] = variable[5];
      variable[9] = ATTR_array___AbstractArray____length(variable[9]) /*AbstractArray::_length*/;
      variable[9] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[9]));
    }
    variable[8] = variable[9];
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 229); nit_exit(1);}
    variable[8] = variable[5];
    variable[8] = ATTR_array___Array____items(variable[8]) /*Array::_items*/;
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label82;
    return_label82: while(false);
    variable[4] = variable[7];
    variable[4] = CALL_abstract_collection___Couple___second(variable[4])(variable[4]) /*Couple::second*/;
    variable[4] = TAG_Bool((variable[4] ==  variable[1] /*item*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[4] = variable[0];
      CALL_array___ArrayMap___remove_at_index(variable[4])(variable[4],  variable[3] /*i*/) /*ArrayMap::remove_at_index*/;
      goto return_label80;
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])-UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_81: while(0);
  }
  break_81: while(0);
  return_label80: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArrayMap___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 470, LOCATE_array___ArrayMap___remove_all};
  val_t variable[10];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[4];
  while (true) { /*while*/
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[4] = variable[0];
    variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
    variable[5] = variable[4];
    variable[6] =  variable[3] /*i*/;
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[9] = variable[8];
    if (UNTAG_Bool(variable[9])) { /* and */
      variable[9] = variable[5];
      variable[9] = ATTR_array___AbstractArray____length(variable[9]) /*AbstractArray::_length*/;
      variable[9] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[9]));
    }
    variable[8] = variable[9];
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 229); nit_exit(1);}
    variable[8] = variable[5];
    variable[8] = ATTR_array___Array____items(variable[8]) /*Array::_items*/;
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label85;
    return_label85: while(false);
    variable[4] = variable[7];
    variable[4] = CALL_abstract_collection___Couple___second(variable[4])(variable[4]) /*Couple::second*/;
    variable[4] = TAG_Bool((variable[4] ==  variable[1] /*item*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[4])) { /*if*/
      variable[4] = variable[0];
      CALL_array___ArrayMap___remove_at_index(variable[4])(variable[4],  variable[3] /*i*/) /*ArrayMap::remove_at_index*/;
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])-UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_84: while(0);
  }
  break_84: while(0);
  return_label83: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 402, LOCATE_array___ArrayMap_____bra};
  val_t variable[10];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_array___ArrayMap___index(variable[4])(variable[4],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
    variable[5] = variable[4];
    variable[6] =  variable[3] /*i*/;
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[9] = variable[8];
    if (UNTAG_Bool(variable[9])) { /* and */
      variable[9] = variable[5];
      variable[9] = ATTR_array___AbstractArray____length(variable[9]) /*AbstractArray::_length*/;
      variable[9] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[9]));
    }
    variable[8] = variable[9];
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 229); nit_exit(1);}
    variable[8] = variable[5];
    variable[8] = ATTR_array___Array____items(variable[8]) /*Array::_items*/;
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label87;
    return_label87: while(false);
    variable[4] = variable[7];
    variable[4] = CALL_abstract_collection___Couple___second(variable[4])(variable[4]) /*Couple::second*/;
    variable[2] = variable[4];
    goto return_label86;
  } else { /*if*/
    variable[2] =  NIT_NULL /*null*/;
    goto return_label86;
  }
  return_label86: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___ArrayMap_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 413, LOCATE_array___ArrayMap_____braeq};
  val_t variable[11];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[2] =  param1;
  variable[5] = variable[0];
  variable[5] = CALL_array___ArrayMap___index(variable[5])(variable[5],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[4] = variable[5];
  variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[5])) { /*if*/
    variable[5] = variable[0];
    variable[5] = ATTR_array___ArrayMap____items(variable[5]) /*ArrayMap::_items*/;
    variable[6] = variable[5];
    variable[7] =  variable[4] /*i*/;
    variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[10] = variable[9];
    if (UNTAG_Bool(variable[10])) { /* and */
      variable[10] = variable[6];
      variable[10] = ATTR_array___AbstractArray____length(variable[10]) /*AbstractArray::_length*/;
      variable[10] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)<UNTAG_Int(variable[10]));
    }
    variable[9] = variable[10];
    if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 229); nit_exit(1);}
    variable[9] = variable[6];
    variable[9] = ATTR_array___Array____items(variable[9]) /*Array::_items*/;
    variable[9] = UNBOX_NativeArray(variable[9])[UNTAG_Int( variable[7] /*index*/)];
    variable[8] = variable[9];
    goto return_label89;
    return_label89: while(false);
    variable[5] = variable[8];
    CALL_abstract_collection___Couple___second__eq(variable[5])(variable[5],  variable[2] /*item*/) /*Couple::second=*/;
  } else { /*if*/
    variable[5] = variable[0];
    variable[5] = ATTR_array___ArrayMap____items(variable[5]) /*ArrayMap::_items*/;
    variable[6] = NEW_Couple_abstract_collection___Couple___init( variable[1] /*key*/,  variable[2] /*item*/); /*new Couple[K, E]*/
    CALL_abstract_collection___IndexedCollection___push(variable[5])(variable[5], variable[6]) /*AbstractArray::push*/;
  }
  return_label88: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 424, LOCATE_array___ArrayMap___has_key};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = CALL_array___ArrayMap___index(variable[3])(variable[3],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])>=UNTAG_Int( TAG_Int(0)));
  variable[2] = variable[3];
  goto return_label90;
  return_label90: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___ArrayMap___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 481, LOCATE_array___ArrayMap___remove_at};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_array___ArrayMap___index(variable[4])(variable[4],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    CALL_array___ArrayMap___remove_at_index(variable[4])(variable[4],  variable[3] /*i*/) /*ArrayMap::remove_at_index*/;
  }
  return_label91: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap___couple_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 492, LOCATE_array___ArrayMap___couple_at};
  val_t variable[10];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = CALL_array___ArrayMap___index(variable[4])(variable[4],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[3] = variable[4];
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[4] = variable[0];
    variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
    variable[5] = variable[4];
    variable[6] =  variable[3] /*i*/;
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[9] = variable[8];
    if (UNTAG_Bool(variable[9])) { /* and */
      variable[9] = variable[5];
      variable[9] = ATTR_array___AbstractArray____length(variable[9]) /*AbstractArray::_length*/;
      variable[9] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[9]));
    }
    variable[8] = variable[9];
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 229); nit_exit(1);}
    variable[8] = variable[5];
    variable[8] = ATTR_array___Array____items(variable[8]) /*Array::_items*/;
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label93;
    return_label93: while(false);
    variable[4] = variable[7];
    variable[2] = variable[4];
    goto return_label92;
  } else { /*if*/
    variable[2] =  NIT_NULL /*null*/;
    goto return_label92;
  }
  return_label92: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___ArrayMap___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 489, LOCATE_array___ArrayMap___enlarge};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArrayMap____items(variable[3]) /*ArrayMap::_items*/;
  CALL_array___AbstractArray___enlarge(variable[3])(variable[3],  variable[1] /*cap*/) /*Array::enlarge*/;
  return_label94: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArrayMap___remove_at_index(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 505, LOCATE_array___ArrayMap___remove_at_index};
  val_t variable[5];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArrayMap____items(variable[3]) /*ArrayMap::_items*/;
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
  variable[4] = CALL_abstract_collection___IndexedCollection___last(variable[4])(variable[4]) /*IndexedCollection::last*/;
  CALL_abstract_collection___Map_____braeq(variable[3])(variable[3],  variable[1] /*i*/, variable[4]) /*Array::[]=*/;
  variable[3] = variable[0];
  variable[3] = ATTR_array___ArrayMap____items(variable[3]) /*ArrayMap::_items*/;
  CALL_abstract_collection___IndexedCollection___pop(variable[3])(variable[3]) /*AbstractArray::pop*/;
  return_label95: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap___index(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 515, LOCATE_array___ArrayMap___index};
  val_t variable[11];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[1] =  param0;
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArrayMap____last_index(variable[4]) /*ArrayMap::_last_index*/;
  variable[3] = variable[4];
  variable[4] = variable[0];
  variable[4] = ATTR_array___ArrayMap____items(variable[4]) /*ArrayMap::_items*/;
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArray::length*/;
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*l*/)<UNTAG_Int(variable[4]));
  variable[5] = variable[4];
  if (UNTAG_Bool(variable[5])) { /* and */
    variable[5] = variable[0];
    variable[5] = ATTR_array___ArrayMap____items(variable[5]) /*ArrayMap::_items*/;
    variable[6] = variable[5];
    variable[7] =  variable[3] /*l*/;
    variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[10] = variable[9];
    if (UNTAG_Bool(variable[10])) { /* and */
      variable[10] = variable[6];
      variable[10] = ATTR_array___AbstractArray____length(variable[10]) /*AbstractArray::_length*/;
      variable[10] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)<UNTAG_Int(variable[10]));
    }
    variable[9] = variable[10];
    if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 229); nit_exit(1);}
    variable[9] = variable[6];
    variable[9] = ATTR_array___Array____items(variable[9]) /*Array::_items*/;
    variable[9] = UNBOX_NativeArray(variable[9])[UNTAG_Int( variable[7] /*index*/)];
    variable[8] = variable[9];
    goto return_label97;
    return_label97: while(false);
    variable[5] = variable[8];
    variable[5] = CALL_abstract_collection___Couple___first(variable[5])(variable[5]) /*Couple::first*/;
    variable[5] = TAG_Bool((variable[5] ==  variable[1] /*key*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*key*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*key*/) /*Object::==*/)))));
  }
  variable[4] = variable[5];
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[2] =  variable[3] /*l*/;
    goto return_label96;
  }
  variable[4] =  TAG_Int(0);
  while (true) { /*while*/
    variable[5] = variable[0];
    variable[5] = ATTR_array___ArrayMap____items(variable[5]) /*ArrayMap::_items*/;
    variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArray::length*/;
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int(variable[5]));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    variable[5] = variable[0];
    variable[5] = ATTR_array___ArrayMap____items(variable[5]) /*ArrayMap::_items*/;
    variable[6] = variable[5];
    variable[7] =  variable[4] /*i*/;
    variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    variable[10] = variable[9];
    if (UNTAG_Bool(variable[10])) { /* and */
      variable[10] = variable[6];
      variable[10] = ATTR_array___AbstractArray____length(variable[10]) /*AbstractArray::_length*/;
      variable[10] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)<UNTAG_Int(variable[10]));
    }
    variable[9] = variable[10];
    if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 229); nit_exit(1);}
    variable[9] = variable[6];
    variable[9] = ATTR_array___Array____items(variable[9]) /*Array::_items*/;
    variable[9] = UNBOX_NativeArray(variable[9])[UNTAG_Int( variable[7] /*index*/)];
    variable[8] = variable[9];
    goto return_label99;
    return_label99: while(false);
    variable[5] = variable[8];
    variable[5] = CALL_abstract_collection___Couple___first(variable[5])(variable[5]) /*Couple::first*/;
    variable[5] = TAG_Bool((variable[5] ==  variable[1] /*key*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*key*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*key*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[5] = variable[0];
      ATTR_array___ArrayMap____last_index(variable[5]) /*ArrayMap::_last_index*/ =  variable[4] /*i*/;
      variable[2] =  variable[4] /*i*/;
      goto return_label96;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_98: while(0);
  }
  break_98: while(0);
  variable[5] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable[2] = variable[5];
  goto return_label96;
  return_label96: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___ArrayMap___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 533, LOCATE_array___ArrayMap___init};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArrayMap].i]) return;
  variable[2] = variable[0];
  variable[3] = NEW_Array_array___Array___init(); /*new Array[Couple[K, E]]*/
  ATTR_array___ArrayMap____items(variable[2]) /*ArrayMap::_items*/ = variable[3];
  return_label100: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArrayMap].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___Iterator___to_a(val_t  self) {
  struct trace_t trace = {NULL, NULL, 543, LOCATE_array___Iterator___to_a};
  val_t variable[4];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[3] = NEW_Array_array___Array___init(); /*new Array[E]*/
  variable[2] = variable[3];
  while (true) { /*while*/
    variable[3] = variable[0];
    variable[3] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[3])) break; /* while*/
    variable[3] = variable[0];
    variable[3] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*Iterator::item*/;
    CALL_abstract_collection___SimpleCollection___add( variable[2] /*res*/)( variable[2] /*res*/, variable[3]) /*AbstractArray::add*/;
    variable[3] = variable[0];
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*Iterator::next*/;
    continue_102: while(0);
  }
  break_102: while(0);
  variable[1] =  variable[2] /*res*/;
  goto return_label101;
  return_label101: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___Collection___to_a(val_t  self) {
  struct trace_t trace = {NULL, NULL, 556, LOCATE_array___Collection___to_a};
  val_t variable[3];
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  variable[0] =  self;
  variable[2] = variable[0];
  variable[2] = CALL_abstract_collection___Collection___iterator(variable[2])(variable[2]) /*Collection::iterator*/;
  variable[2] = CALL_array___Iterator___to_a(variable[2])(variable[2]) /*Iterator::to_a*/;
  variable[1] = variable[2];
  goto return_label103;
  return_label103: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayCapable___calloc_array(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 567, LOCATE_array___ArrayCapable___calloc_array};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return BOX_NativeArray((val_t*)malloc((UNTAG_Int( param0) * sizeof(val_t))));
}
val_t array___NativeArray_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 573, LOCATE_array___NativeArray_____bra};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return UNBOX_NativeArray( self)[UNTAG_Int( param0)];
}
void array___NativeArray_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 574, LOCATE_array___NativeArray_____braeq};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  UNBOX_NativeArray( self)[UNTAG_Int( param0)]= param1;
  tracehead = trace.prev;
  return;
}
void array___NativeArray___copy_to(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 575, LOCATE_array___NativeArray___copy_to};
  val_t *variable = NULL;
  void **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  (void)memcpy(UNBOX_NativeArray( param0), UNBOX_NativeArray( self), UNTAG_Int( param1)*sizeof(val_t));
  tracehead = trace.prev;
  return;
}
