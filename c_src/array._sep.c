/* This C file is generated by NIT to compile module array. */
#include "array._sep.h"
val_t array___AbstractArrayRead_____eqeq(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 128, LOCATE_array___AbstractArrayRead_____eqeq};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(( variable[1] /*o*/==NIT_NULL) || VAL_ISA( variable[1] /*o*/, COLOR_AbstractArray, ID_AbstractArray)) /*cast AbstractArray[E]*/;
  variable[3] =  TAG_Bool(!UNTAG_Bool(variable[3])) /* Ensure var: Left 'or' operand*/;
  if (!UNTAG_Bool(variable[3])) { /* or */
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool(IS_EQUAL_NN( variable[1] /*o*/, NIT_NULL /*null*/));
  }
  /* Register variable[3]: Result */
  if (UNTAG_Bool(variable[3])) { /*if*/
    variable[2] =  TAG_Bool(false);
    goto return_label0;
  }
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(( variable[1] /*o*/==NIT_NULL) || VAL_ISA( variable[1] /*o*/, COLOR_AbstractArray, ID_AbstractArray)) /*cast AbstractArray[E]*/;
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___AbstractArrayRead_____eqeq, LOCATE_array, 132); nit_exit(1);}
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length( variable[1] /*o*/)( variable[1] /*o*/) /*AbstractArrayRead::length*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool((variable[4])!=( variable[3] /*l*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[2] =  TAG_Bool(false);
    goto return_label0;
  }
  /* Register variable[4]: Local variable */
  variable[4] =  TAG_Int(0);
  while (true) { /*while*/
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[3] /*l*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[4] /*i*/) /*MapRead::[]*/;
    /* Register variable[6]: Result */
    variable[6] = CALL_abstract_collection___MapRead_____bra( variable[1] /*o*/)( variable[1] /*o*/,  variable[4] /*i*/) /*MapRead::[]*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] == variable[6]) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5],variable[6])):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5], variable[6]) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label0;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_1: while(0);
  }
  break_1: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label0;
  return_label0: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___AbstractArrayRead___output(val_t  self) {
  struct trace_t trace = {NULL, NULL, 115, LOCATE_array___AbstractArrayRead___output};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Local variable */
  variable[2] =  TAG_Int(0);
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  variable[3] = variable[4];
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*i*/)<UNTAG_Int( variable[3] /*l*/));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    /* Register variable[4]: Local variable */
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[2] /*i*/) /*MapRead::[]*/;
    variable[4] = variable[5];
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[4] /*e*/ ==  NIT_NULL /*null*/) || (( variable[4] /*e*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[4] /*e*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[4] /*e*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[4] /*e*/)( variable[4] /*e*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      CALL_kernel___Object___output( variable[4] /*e*/)( variable[4] /*e*/) /*Object::output*/;
    }
    variable[2] = TAG_Int(UNTAG_Int(variable[2])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_3: while(0);
  }
  break_3: while(0);
  return_label2: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___AbstractArrayRead___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 126, LOCATE_array___AbstractArrayRead___iterator};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = NEW_ArrayIterator_array___ArrayIterator___init(variable[0]) /*new ArrayIterator[E]*/;
  variable[1] = variable[2];
  goto return_label4;
  return_label4: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___AbstractArrayRead___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 26, LOCATE_array___AbstractArrayRead___is_empty};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/;
  /* Register variable[2]: Result */
  variable[2] = TAG_Bool((variable[2])==( TAG_Int(0)));
  variable[1] = variable[2];
  goto return_label5;
  return_label5: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___AbstractArrayRead___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 23, LOCATE_array___AbstractArrayRead___length};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return ATTR_array___AbstractArrayRead____length( self) /*AbstractArrayRead::_length*/;
}
val_t array___AbstractArrayRead___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 28, LOCATE_array___AbstractArrayRead___has};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  variable[3] =  TAG_Int(0);
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  variable[4] = variable[5];
  while (true) { /*while*/
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[3] /*i*/) /*MapRead::[]*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool((variable[5] ==  variable[1] /*item*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[2] =  TAG_Bool(true);
      goto return_label6;
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_7: while(0);
  }
  break_7: while(0);
  variable[2] =  TAG_Bool(false);
  goto return_label6;
  return_label6: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArrayRead___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 39, LOCATE_array___AbstractArrayRead___has_only};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  variable[3] =  TAG_Int(0);
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  variable[4] = variable[5];
  while (true) { /*while*/
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[3] /*i*/) /*MapRead::[]*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[5] ==  variable[1] /*item*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*item*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label8;
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_9: while(0);
  }
  break_9: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label8;
  return_label8: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArrayRead___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 52, LOCATE_array___AbstractArrayRead___count};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  variable[3] =  TAG_Int(0);
  /* Register variable[4]: Local variable */
  variable[4] =  TAG_Int(0);
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  variable[5] = variable[6];
  while (true) { /*while*/
    /* Register variable[6]: Result */
    variable[6] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[5] /*l*/));
    if (!UNTAG_Bool(variable[6])) break; /* while*/
    /* Register variable[6]: Result */
    variable[6] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[4] /*i*/) /*MapRead::[]*/;
    /* Register variable[6]: Result */
    variable[6] = TAG_Bool((variable[6] ==  variable[1] /*item*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*res*/;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_11: while(0);
  }
  break_11: while(0);
  variable[2] =  variable[3] /*res*/;
  goto return_label10;
  return_label10: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArrayRead___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 50, LOCATE_array___AbstractArrayRead___has_key};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  /* Ensure var variable[3]: Left 'and' operand*/
  if (UNTAG_Bool(variable[3])) { /* and */
    /* Register variable[3]: Result */
    variable[3] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)<UNTAG_Int(variable[3]));
  }
  /* Register variable[3]: Result */
  variable[2] = variable[3];
  goto return_label12;
  return_label12: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArrayRead___index_of(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 64, LOCATE_array___AbstractArrayRead___index_of};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_array___AbstractArrayRead___index_of_from(variable[0])(variable[0],  variable[1] /*item*/,  TAG_Int(0)) /*AbstractArrayRead::index_of_from*/;
  variable[2] = variable[3];
  goto return_label13;
  return_label13: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArrayRead___last_index_of(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 66, LOCATE_array___AbstractArrayRead___last_index_of};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Int(UNTAG_Int(variable[3])-UNTAG_Int( TAG_Int(1)));
  /* Register variable[3]: Result */
  variable[3] = CALL_array___AbstractArrayRead___last_index_of_from(variable[0])(variable[0],  variable[1] /*item*/, variable[3]) /*AbstractArrayRead::last_index_of_from*/;
  variable[2] = variable[3];
  goto return_label14;
  return_label14: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___AbstractArrayRead___index_of_from(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 68, LOCATE_array___AbstractArrayRead___index_of_from};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Local variable */
  variable[4] =  variable[2] /*pos*/;
  /* Register variable[5]: Local variable */
  /* Register variable[6]: Result */
  variable[6] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  variable[5] = variable[6];
  while (true) { /*while*/
    /* Register variable[6]: Result */
    variable[6] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[5] /*len*/));
    if (!UNTAG_Bool(variable[6])) break; /* while*/
    /* Register variable[6]: Result */
    variable[6] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[4] /*i*/) /*MapRead::[]*/;
    /* Register variable[6]: Result */
    variable[6] = TAG_Bool((variable[6] ==  variable[1] /*item*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[3] =  variable[4] /*i*/;
      goto return_label15;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_16: while(0);
  }
  break_16: while(0);
  /* Register variable[6]: Result */
  variable[6] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[6];
  goto return_label15;
  return_label15: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t array___AbstractArrayRead___last_index_of_from(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 81, LOCATE_array___AbstractArrayRead___last_index_of_from};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Local variable */
  variable[4] =  variable[2] /*pos*/;
  while (true) { /*while*/
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)>=UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[4] /*i*/) /*MapRead::[]*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool((variable[5] ==  variable[1] /*item*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      variable[3] =  variable[4] /*i*/;
      goto return_label17;
    } else { /*if*/
      variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1))) /*i*/;
    }
    continue_18: while(0);
  }
  break_18: while(0);
  /* Register variable[5]: Result */
  variable[5] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[5];
  goto return_label17;
  return_label17: while(false);
  tracehead = trace.prev;
  return variable[3];
}
val_t array___AbstractArrayRead___reversed(val_t  self) {
  struct trace_t trace = {NULL, NULL, 94, LOCATE_array___AbstractArrayRead___reversed};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Local variable */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/;
  variable[2] = variable[3];
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = NEW_Array_array___Array___with_capacity( variable[2] /*cmp*/) /*new Array[E]*/;
  variable[3] = variable[4];
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*cmp*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    variable[2] = TAG_Int(UNTAG_Int(variable[2])-UNTAG_Int( TAG_Int(1))) /*cmp*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[2] /*cmp*/) /*MapRead::[]*/;
    CALL_abstract_collection___SimpleCollection___add( variable[3] /*result*/)( variable[3] /*result*/, variable[4]) /*AbstractArray::add*/;
    continue_20: while(0);
  }
  break_20: while(0);
  variable[1] =  variable[3] /*result*/;
  goto return_label19;
  return_label19: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___AbstractArrayRead___copy_to(val_t  self, val_t  param0, val_t  param1, val_t  param2, val_t  param3) {
  struct trace_t trace = {NULL, NULL, 105, LOCATE_array___AbstractArrayRead___copy_to};
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Local variable */
  variable[3] =  param2;
  /* Register variable[4]: Local variable */
  variable[4] =  param3;
  /* Register variable[5]: Method return value and escape marker */
  /* Register variable[6]: Local variable */
  variable[6] =  variable[2] /*len*/;
  while (true) { /*while*/
    /* Register variable[7]: Result */
    variable[7] = TAG_Bool(UNTAG_Int( variable[6] /*i*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[7])) break; /* while*/
    variable[6] = TAG_Int(UNTAG_Int(variable[6])-UNTAG_Int( TAG_Int(1))) /*i*/;
    /* Register variable[7]: Result */
    variable[7] = TAG_Int(UNTAG_Int( variable[4] /*new_start*/)+UNTAG_Int( variable[6] /*i*/));
    /* Register variable[8]: Result */
    variable[8] = TAG_Int(UNTAG_Int( variable[1] /*start*/)+UNTAG_Int( variable[6] /*i*/));
    /* Register variable[8]: Result */
    variable[8] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0], variable[8]) /*MapRead::[]*/;
    CALL_abstract_collection___Map_____braeq( variable[3] /*dest*/)( variable[3] /*dest*/, variable[7], variable[8]) /*Map::[]=*/;
    continue_22: while(0);
  }
  break_22: while(0);
  return_label21: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArrayRead___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 0, LOCATE_array___AbstractArrayRead___init};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___clear(val_t  self) {
  struct trace_t trace = {NULL, NULL, 193, LOCATE_array___AbstractArray___clear};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ =  TAG_Int(0);
  return_label23: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 195, LOCATE_array___AbstractArray___remove};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___IndexedCollectionRead___index_of(variable[0])(variable[0],  variable[1] /*item*/) /*AbstractArrayRead::index_of*/;
  CALL_abstract_collection___Map___remove_at(variable[0])(variable[0], variable[3]) /*AbstractArray::remove_at*/;
  return_label24: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 197, LOCATE_array___AbstractArray___remove_all};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___IndexedCollectionRead___index_of(variable[0])(variable[0],  variable[1] /*item*/) /*AbstractArrayRead::index_of*/;
  variable[3] = variable[4];
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    CALL_abstract_collection___Map___remove_at(variable[0])(variable[0],  variable[3] /*i*/) /*AbstractArray::remove_at*/;
    /* Register variable[4]: Result */
    variable[4] = CALL_array___AbstractArrayRead___index_of_from(variable[0])(variable[0],  variable[1] /*item*/,  variable[3] /*i*/) /*AbstractArrayRead::index_of_from*/;
    variable[3] = variable[4] /*i=*/;
    continue_26: while(0);
  }
  break_26: while(0);
  return_label25: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 206, LOCATE_array___AbstractArray___remove_at};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  /* Ensure var variable[4]: Left 'and' operand*/
  if (UNTAG_Bool(variable[4])) { /* and */
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*i*/)<UNTAG_Int( variable[3] /*l*/));
  }
  /* Register variable[4]: Result */
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Local variable */
    /* Register variable[5]: Result */
    variable[5] = TAG_Int(UNTAG_Int( variable[1] /*i*/)+UNTAG_Int( TAG_Int(1)));
    variable[4] = variable[5];
    while (true) { /*while*/
      /* Register variable[5]: Result */
      variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*j*/)<UNTAG_Int( variable[3] /*l*/));
      if (!UNTAG_Bool(variable[5])) break; /* while*/
      /* Register variable[5]: Result */
      variable[5] = TAG_Int(UNTAG_Int( variable[4] /*j*/)-UNTAG_Int( TAG_Int(1)));
      /* Register variable[6]: Result */
      variable[6] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[4] /*j*/) /*MapRead::[]*/;
      CALL_abstract_collection___Map_____braeq(variable[0])(variable[0], variable[5], variable[6]) /*Map::[]=*/;
      variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*j*/;
      continue_28: while(0);
    }
    break_28: while(0);
    /* Register variable[5]: Result */
    variable[5] = TAG_Int(UNTAG_Int( variable[3] /*l*/)-UNTAG_Int( TAG_Int(1)));
    ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ = variable[5];
  }
  return_label27: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 191, LOCATE_array___AbstractArray___add};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  CALL_abstract_collection___Map_____braeq(variable[0])(variable[0], variable[3],  variable[1] /*item*/) /*Map::[]=*/;
  return_label29: while(false);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___push(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 150, LOCATE_array___AbstractArray___push};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_abstract_collection___SimpleCollection___add(variable[0])(variable[0],  variable[1] /*item*/) /*AbstractArray::add*/;
  return_label30: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___AbstractArray___pop(val_t  self) {
  struct trace_t trace = {NULL, NULL, 152, LOCATE_array___AbstractArray___pop};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[0])(variable[0]) /*AbstractArrayRead::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[2])))) { fprintf(stderr, "Assert%s failed", " 'not_empty' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___AbstractArray___pop, LOCATE_array, 154); nit_exit(1);}
  /* Register variable[2]: Local variable */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___IndexedCollectionRead___last(variable[0])(variable[0]) /*IndexedCollectionRead::last*/;
  variable[2] = variable[3];
  ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ = TAG_Int(UNTAG_Int(ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/)-UNTAG_Int( TAG_Int(1)));
  variable[1] =  variable[2] /*r*/;
  goto return_label31;
  return_label31: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___AbstractArray___unshift(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 174, LOCATE_array___AbstractArray___unshift};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[4];
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Int(UNTAG_Int( variable[3] /*i*/)+UNTAG_Int( TAG_Int(1)));
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[3] /*i*/) /*MapRead::[]*/;
    CALL_abstract_collection___Map_____braeq(variable[0])(variable[0], variable[4], variable[5]) /*Map::[]=*/;
    variable[3] = TAG_Int(UNTAG_Int(variable[3])-UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_33: while(0);
  }
  break_33: while(0);
  CALL_abstract_collection___Map_____braeq(variable[0])(variable[0],  TAG_Int(0),  variable[1] /*item*/) /*Map::[]=*/;
  return_label32: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___AbstractArray___shift(val_t  self) {
  struct trace_t trace = {NULL, NULL, 160, LOCATE_array___AbstractArray___shift};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[0])(variable[0]) /*AbstractArrayRead::is_empty*/;
  if (!UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[2])))) { fprintf(stderr, "Assert%s failed", " 'not_empty' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___AbstractArray___shift, LOCATE_array, 162); nit_exit(1);}
  /* Register variable[2]: Local variable */
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___Collection___first(variable[0])(variable[0]) /*IndexedCollectionRead::first*/;
  variable[2] = variable[3];
  /* Register variable[3]: Local variable */
  variable[3] =  TAG_Int(1);
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  variable[4] = variable[5];
  while (true) { /*while*/
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)<UNTAG_Int( variable[4] /*l*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    /* Register variable[5]: Result */
    variable[5] = TAG_Int(UNTAG_Int( variable[3] /*i*/)-UNTAG_Int( TAG_Int(1)));
    /* Register variable[6]: Result */
    variable[6] = CALL_abstract_collection___MapRead_____bra(variable[0])(variable[0],  variable[3] /*i*/) /*MapRead::[]*/;
    CALL_abstract_collection___Map_____braeq(variable[0])(variable[0], variable[5], variable[6]) /*Map::[]=*/;
    variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_35: while(0);
  }
  break_35: while(0);
  /* Register variable[5]: Result */
  variable[5] = TAG_Int(UNTAG_Int( variable[4] /*l*/)-UNTAG_Int( TAG_Int(1)));
  ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ = variable[5];
  variable[1] =  variable[2] /*r*/;
  goto return_label34;
  return_label34: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___AbstractArray___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 148, LOCATE_array___AbstractArray___enlarge};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  fprintf(stderr, "Deferred method called");
  fprintf(stderr, " (%s:%d)\n", LOCATE_array, 148);
  nit_exit(1);
  tracehead = trace.prev;
  return;
}
void array___AbstractArray___insert(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 184, LOCATE_array___AbstractArray___insert};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1)));
  CALL_array___AbstractArray___enlarge(variable[0])(variable[0], variable[4]) /*AbstractArray::enlarge*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[0])(variable[0]) /*AbstractArrayRead::length*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( variable[2] /*pos*/));
  /* Register variable[5]: Result */
  variable[5] = TAG_Int(UNTAG_Int( variable[2] /*pos*/)+UNTAG_Int( TAG_Int(1)));
  CALL_array___AbstractArrayRead___copy_to(variable[0])(variable[0],  variable[2] /*pos*/, variable[4], variable[0], variable[5]) /*AbstractArrayRead::copy_to*/;
  CALL_abstract_collection___Map_____braeq(variable[0])(variable[0],  variable[2] /*pos*/,  variable[1] /*item*/) /*Map::[]=*/;
  return_label36: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___Array_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 232, LOCATE_array___Array_____bra};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  /* Ensure var variable[3]: Left 'and' operand*/
  if (UNTAG_Bool(variable[3])) { /* and */
    /* Register variable[3]: Result */
    variable[3] = ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/;
    /* Register variable[3]: Result */
    variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)<UNTAG_Int(variable[3]));
  }
  /* Register variable[3]: Result */
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 234); nit_exit(1);}
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___Array____items(variable[0]) /*Array::_items*/;
  /* Register variable[3]: Result */
  variable[3] = UNBOX_NativeArray(variable[3])[UNTAG_Int( variable[1] /*index*/)];
  variable[2] = variable[3];
  goto return_label37;
  return_label37: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___Array_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 238, LOCATE_array___Array_____braeq};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)>=UNTAG_Int( TAG_Int(0)));
  /* Ensure var variable[4]: Left 'and' operand*/
  if (UNTAG_Bool(variable[4])) { /* and */
    /* Register variable[4]: Result */
    variable[4] = ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/;
    /* Register variable[4]: Result */
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1)));
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*index*/)<UNTAG_Int(variable[4]));
  }
  /* Register variable[4]: Result */
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____braeq, LOCATE_array, 240); nit_exit(1);}
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int(variable[4])<=UNTAG_Int( variable[1] /*index*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Int(UNTAG_Int( variable[1] /*index*/)+UNTAG_Int( TAG_Int(1)));
    CALL_array___AbstractArray___enlarge(variable[0])(variable[0], variable[4]) /*Array::enlarge*/;
  }
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int(variable[4])<=UNTAG_Int( variable[1] /*index*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Int(UNTAG_Int( variable[1] /*index*/)+UNTAG_Int( TAG_Int(1)));
    ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ = variable[4];
  }
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___Array____items(variable[0]) /*Array::_items*/;
  UNBOX_NativeArray(variable[4])[UNTAG_Int( variable[1] /*index*/)]= variable[2] /*item*/;
  return_label38: while(false);
  tracehead = trace.prev;
  return;
}
void array___Array___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 250, LOCATE_array___Array___enlarge};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[1] /*cap*/)<=UNTAG_Int( variable[3] /*c*/));
  if (UNTAG_Bool(variable[4])) { /*if*/
    goto return_label39;
  }
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*c*/)<=UNTAG_Int( variable[1] /*cap*/));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Int(UNTAG_Int( variable[3] /*c*/)*UNTAG_Int( TAG_Int(2)));
    /* Register variable[4]: Result */
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(2)));
    variable[3] = variable[4] /*c=*/;
    continue_40: while(0);
  }
  break_40: while(0);
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = BOX_NativeArray((val_t*)malloc((UNTAG_Int( variable[3] /*c*/) * sizeof(val_t))));
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/;
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(UNTAG_Int(variable[5])>UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Result */
    variable[5] = ATTR_array___Array____items(variable[0]) /*Array::_items*/;
    /* Register variable[6]: Result */
    variable[6] = ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/;
    (void)memcpy(UNBOX_NativeArray( variable[4] /*a*/), UNBOX_NativeArray(variable[5]), UNTAG_Int(variable[6])*sizeof(val_t));
  }
  ATTR_array___Array____items(variable[0]) /*Array::_items*/ =  variable[4] /*a*/;
  ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/ =  variable[3] /*c*/;
  return_label39: while(false);
  tracehead = trace.prev;
  return;
}
void array___Array___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 261, LOCATE_array___Array___init};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  /* Register variable[1]: Method return value and escape marker */
  ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/ =  TAG_Int(0);
  ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ =  TAG_Int(0);
  return_label41: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___Array___with_items(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 268, LOCATE_array___Array___with_items};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  /* check if p<Array[E] with p:E */
  if (( param0==NIT_NULL) || !VAL_ISA( param0, COLOR_Array, ID_Array)) { fprintf(stderr, "Cast failled"); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array___with_items, LOCATE_array, 269); nit_exit(1); } /*cast Array[E]*/;
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___Array____items( variable[1] /*objects*/) /*Array::_items*/;
  ATTR_array___Array____items(variable[0]) /*Array::_items*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___Array____capacity( variable[1] /*objects*/) /*Array::_capacity*/;
  ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/ = variable[3];
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___Collection___length( variable[1] /*objects*/)( variable[1] /*objects*/) /*AbstractArrayRead::length*/;
  ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ = variable[3];
  return_label42: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___Array___with_capacity(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 276, LOCATE_array___Array___with_capacity};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(UNTAG_Int( variable[1] /*cap*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", " 'positive' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array___with_capacity, LOCATE_array, 279); nit_exit(1);}
  /* Register variable[3]: Result */
  variable[3] = BOX_NativeArray((val_t*)malloc((UNTAG_Int( variable[1] /*cap*/) * sizeof(val_t))));
  ATTR_array___Array____items(variable[0]) /*Array::_items*/ = variable[3];
  ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/ =  variable[1] /*cap*/;
  ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ =  TAG_Int(0);
  return_label43: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___Array___filled_with(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 285, LOCATE_array___Array___filled_with};
  val_t variable[6];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*count*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", " 'positive' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array___filled_with, LOCATE_array, 288); nit_exit(1);}
  /* Register variable[4]: Result */
  variable[4] = BOX_NativeArray((val_t*)malloc((UNTAG_Int( variable[2] /*count*/) * sizeof(val_t))));
  ATTR_array___Array____items(variable[0]) /*Array::_items*/ = variable[4];
  ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/ =  variable[2] /*count*/;
  ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ =  variable[2] /*count*/;
  /* Register variable[4]: Local variable */
  variable[4] =  TAG_Int(0);
  while (true) { /*while*/
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int( variable[2] /*count*/));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    CALL_abstract_collection___Map_____braeq(variable[0])(variable[0],  variable[4] /*i*/,  variable[1] /*value*/) /*Array::[]=*/;
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_45: while(0);
  }
  break_45: while(0);
  return_label44: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___Array___with_native(val_t  self, val_t  param0, val_t  param1, int* init_table) {
  struct trace_t trace = {NULL, NULL, 299, LOCATE_array___Array___with_native};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i]) return;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[2] /*size*/)>=UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[4])) { fprintf(stderr, "Assert%s failed", " 'positive' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array___with_native, LOCATE_array, 302); nit_exit(1);}
  ATTR_array___Array____items(variable[0]) /*Array::_items*/ =  variable[1] /*nat*/;
  ATTR_array___Array____capacity(variable[0]) /*Array::_capacity*/ =  variable[2] /*size*/;
  ATTR_array___AbstractArrayRead____length(variable[0]) /*AbstractArrayRead::_length*/ =  variable[2] /*size*/;
  return_label46: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_Array].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___ArrayIterator___item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 318, LOCATE_array___ArrayIterator___item};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArrayIterator____array(variable[0]) /*ArrayIterator::_array*/;
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArrayIterator____index(variable[0]) /*ArrayIterator::_index*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___MapRead_____bra(variable[2])(variable[2], variable[3]) /*MapRead::[]*/;
  variable[1] = variable[2];
  goto return_label47;
  return_label47: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArrayIterator___next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 324, LOCATE_array___ArrayIterator___next};
  val_t variable[2];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  ATTR_array___ArrayIterator____index(variable[0]) /*ArrayIterator::_index*/ = TAG_Int(UNTAG_Int(ATTR_array___ArrayIterator____index(variable[0]) /*ArrayIterator::_index*/)+UNTAG_Int( TAG_Int(1)));
  return_label48: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 322, LOCATE_array___ArrayIterator___is_ok};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArrayIterator____index(variable[0]) /*ArrayIterator::_index*/;
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArrayIterator____array(variable[0]) /*ArrayIterator::_array*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___Collection___length(variable[3])(variable[3]) /*AbstractArrayRead::length*/;
  /* Register variable[2]: Result */
  variable[2] = TAG_Bool(UNTAG_Int(variable[2])<UNTAG_Int(variable[3]));
  variable[1] = variable[2];
  goto return_label49;
  return_label49: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayIterator___index(val_t  self) {
  struct trace_t trace = {NULL, NULL, 333, LOCATE_array___ArrayIterator___index};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return ATTR_array___ArrayIterator____index( self) /*ArrayIterator::_index*/;
}
void array___ArrayIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 326, LOCATE_array___ArrayIterator___init};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArrayIterator].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(!UNTAG_Bool(TAG_Bool(( variable[1] /*a*/ ==  NIT_NULL /*null*/) || (( variable[1] /*a*/ != NIT_NULL) && ((CALL_kernel___Object_____eqeq( variable[1] /*a*/)==kernel___Object_____eqeq)?(IS_EQUAL_NN( variable[1] /*a*/, NIT_NULL /*null*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq( variable[1] /*a*/)( variable[1] /*a*/,  NIT_NULL /*null*/) /*Object::==*/)))))));
  if (!UNTAG_Bool(variable[3])) { fprintf(stderr, "Assert%s failed", " 'not_nil' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___ArrayIterator___init, LOCATE_array, 328); nit_exit(1);}
  ATTR_array___ArrayIterator____array(variable[0]) /*ArrayIterator::_array*/ =  variable[1] /*a*/;
  ATTR_array___ArrayIterator____index(variable[0]) /*ArrayIterator::_index*/ =  TAG_Int(0);
  return_label50: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArrayIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___ArraySet___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 369, LOCATE_array___ArraySet___iterator};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___iterator(variable[2])(variable[2]) /*AbstractArrayRead::iterator*/;
  /* Register variable[2]: Result */
  variable[2] = NEW_ArraySetIterator_array___ArraySetIterator___init(variable[2]) /*new ArraySetIterator[E]*/;
  variable[1] = variable[2];
  goto return_label51;
  return_label51: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArraySet___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 349, LOCATE_array___ArraySet___is_empty};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[2])(variable[2]) /*AbstractArrayRead::is_empty*/;
  variable[1] = variable[2];
  goto return_label52;
  return_label52: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArraySet___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 351, LOCATE_array___ArraySet___length};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___length(variable[2])(variable[2]) /*AbstractArrayRead::length*/;
  variable[1] = variable[2];
  goto return_label53;
  return_label53: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArraySet___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 345, LOCATE_array___ArraySet___has};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___Collection___has(variable[3])(variable[3],  variable[1] /*e*/) /*AbstractArrayRead::has*/;
  variable[2] = variable[3];
  goto return_label54;
  return_label54: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArraySet___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 353, LOCATE_array___ArraySet___first};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___length(variable[2])(variable[2]) /*AbstractArrayRead::length*/;
  /* Register variable[2]: Result */
  variable[2] = TAG_Bool(UNTAG_Int(variable[2])>UNTAG_Int( TAG_Int(0)));
  if (!UNTAG_Bool(variable[2])) { fprintf(stderr, "Assert%s failed", ""); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___ArraySet___first, LOCATE_array, 355); nit_exit(1);}
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___first(variable[2])(variable[2]) /*IndexedCollectionRead::first*/;
  variable[1] = variable[2];
  goto return_label55;
  return_label55: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArraySet___clear(val_t  self) {
  struct trace_t trace = {NULL, NULL, 367, LOCATE_array___ArraySet___clear};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  CALL_abstract_collection___RemovableCollection___clear(variable[2])(variable[2]) /*AbstractArray::clear*/;
  return_label56: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 359, LOCATE_array___ArraySet___remove};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___IndexedCollectionRead___index_of(variable[4])(variable[4],  variable[1] /*item*/) /*AbstractArrayRead::index_of*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    CALL_array___ArraySet___remove_at(variable[0])(variable[0],  variable[3] /*i*/) /*ArraySet::remove_at*/;
  }
  return_label57: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 365, LOCATE_array___ArraySet___remove_all};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  CALL_abstract_collection___RemovableCollection___remove(variable[0])(variable[0],  variable[1] /*item*/) /*ArraySet::remove*/;
  return_label58: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___add(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 347, LOCATE_array___ArraySet___add};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[3]: Result */
  variable[3] = CALL_abstract_collection___Collection___has(variable[3])(variable[3],  variable[1] /*e*/) /*AbstractArrayRead::has*/;
  if (UNTAG_Bool( TAG_Bool(!UNTAG_Bool(variable[3])))) { /*if*/
    /* Register variable[3]: Result */
    variable[3] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
    CALL_abstract_collection___SimpleCollection___add(variable[3])(variable[3],  variable[1] /*e*/) /*AbstractArray::add*/;
  }
  return_label59: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 371, LOCATE_array___ArraySet___enlarge};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  CALL_array___AbstractArray___enlarge(variable[3])(variable[3],  variable[1] /*cap*/) /*Array::enlarge*/;
  return_label60: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 374, LOCATE_array___ArraySet___remove_at};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___IndexedCollectionRead___last(variable[4])(variable[4]) /*IndexedCollectionRead::last*/;
  CALL_abstract_collection___Map_____braeq(variable[3])(variable[3],  variable[1] /*i*/, variable[4]) /*Array::[]=*/;
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/;
  CALL_abstract_collection___IndexedCollection___pop(variable[3])(variable[3]) /*AbstractArray::pop*/;
  return_label61: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArraySet___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 380, LOCATE_array___ArraySet___init};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySet].i]) return;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = NEW_Array_array___Array___init() /*new Array[E]*/;
  ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/ = variable[2];
  return_label62: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySet].i] = 1;
  tracehead = trace.prev;
  return;
}
void array___ArraySet___with_capacity(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 383, LOCATE_array___ArraySet___with_capacity};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySet].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = NEW_Array_array___Array___with_capacity( variable[1] /*i*/) /*new Array[E]*/;
  ATTR_array___ArraySet____array(variable[0]) /*ArraySet::_array*/ = variable[3];
  return_label63: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySet].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___ArraySetIterator___item(val_t  self) {
  struct trace_t trace = {NULL, NULL, 395, LOCATE_array___ArraySetIterator___item};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySetIterator____iter(variable[0]) /*ArraySetIterator::_iter*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Iterator___item(variable[2])(variable[2]) /*ArrayIterator::item*/;
  variable[1] = variable[2];
  goto return_label64;
  return_label64: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArraySetIterator___next(val_t  self) {
  struct trace_t trace = {NULL, NULL, 393, LOCATE_array___ArraySetIterator___next};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySetIterator____iter(variable[0]) /*ArraySetIterator::_iter*/;
  CALL_abstract_collection___Iterator___next(variable[2])(variable[2]) /*ArrayIterator::next*/;
  return_label65: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArraySetIterator___is_ok(val_t  self) {
  struct trace_t trace = {NULL, NULL, 391, LOCATE_array___ArraySetIterator___is_ok};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArraySetIterator____iter(variable[0]) /*ArraySetIterator::_iter*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Iterator___is_ok(variable[2])(variable[2]) /*ArrayIterator::is_ok*/;
  variable[1] = variable[2];
  goto return_label66;
  return_label66: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArraySetIterator___init(val_t  self, val_t  param0, int* init_table) {
  struct trace_t trace = {NULL, NULL, 397, LOCATE_array___ArraySetIterator___init};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySetIterator].i]) return;
  /* Register variable[2]: Method return value and escape marker */
  ATTR_array___ArraySetIterator____iter(variable[0]) /*ArraySetIterator::_iter*/ =  variable[1] /*iter*/;
  return_label67: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArraySetIterator].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap___iterator(val_t  self) {
  struct trace_t trace = {NULL, NULL, 459, LOCATE_array___ArrayMap___iterator};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___iterator(variable[2])(variable[2]) /*AbstractArrayRead::iterator*/;
  /* Register variable[2]: Result */
  variable[2] = NEW_CoupleMapIterator_abstract_collection___CoupleMapIterator___init(variable[2]) /*new CoupleMapIterator[K, E]*/;
  variable[1] = variable[2];
  goto return_label68;
  return_label68: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayMap___is_empty(val_t  self) {
  struct trace_t trace = {NULL, NULL, 461, LOCATE_array___ArrayMap___is_empty};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___is_empty(variable[2])(variable[2]) /*AbstractArrayRead::is_empty*/;
  variable[1] = variable[2];
  goto return_label69;
  return_label69: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayMap___length(val_t  self) {
  struct trace_t trace = {NULL, NULL, 446, LOCATE_array___ArrayMap___length};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___length(variable[2])(variable[2]) /*AbstractArrayRead::length*/;
  variable[1] = variable[2];
  goto return_label70;
  return_label70: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayMap___has(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 432, LOCATE_array___ArrayMap___has};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[3]: For iterator */
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[3])(variable[3]) /*AbstractArrayRead::iterator*/;
  while (true) { /*for*/
    /* Register variable[4]: For 'is_ok' result */
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Result */
    variable[6] = CALL_abstract_collection___Couple___second( variable[5] /*i*/)( variable[5] /*i*/) /*Couple::second*/;
    /* Register variable[6]: Result */
    variable[6] = TAG_Bool((variable[6] ==  variable[1] /*item*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[2] =  TAG_Bool(true);
      goto return_label71;
    }
    continue_72: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*ArrayIterator::next*/;
  }
  break_72: while(0);
  variable[2] =  TAG_Bool(false);
  goto return_label71;
  return_label71: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArrayMap___has_only(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 439, LOCATE_array___ArrayMap___has_only};
  val_t variable[7];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[3]: For iterator */
  variable[3] = CALL_abstract_collection___Collection___iterator(variable[3])(variable[3]) /*AbstractArrayRead::iterator*/;
  while (true) { /*for*/
    /* Register variable[4]: For 'is_ok' result */
    variable[4] = CALL_abstract_collection___Iterator___is_ok(variable[3])(variable[3]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[4])) break; /*for*/
    variable[4] = CALL_abstract_collection___Iterator___item(variable[3])(variable[3]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Result */
    variable[6] = CALL_abstract_collection___Couple___second( variable[5] /*i*/)( variable[5] /*i*/) /*Couple::second*/;
    /* Register variable[6]: Result */
    variable[6] = TAG_Bool(!UNTAG_Bool(TAG_Bool((variable[6] ==  variable[1] /*item*/) || ((variable[6] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[6])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[6], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[6])(variable[6],  variable[1] /*item*/) /*Object::==*/)))))));
    if (UNTAG_Bool(variable[6])) { /*if*/
      variable[2] =  TAG_Bool(false);
      goto return_label73;
    }
    continue_74: while(0);
    CALL_abstract_collection___Iterator___next(variable[3])(variable[3]) /*ArrayIterator::next*/;
  }
  break_74: while(0);
  variable[2] =  TAG_Bool(true);
  goto return_label73;
  return_label73: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArrayMap___count(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 451, LOCATE_array___ArrayMap___count};
  val_t variable[8];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  variable[3] =  TAG_Int(0);
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[4]: For iterator */
  variable[4] = CALL_abstract_collection___Collection___iterator(variable[4])(variable[4]) /*AbstractArrayRead::iterator*/;
  while (true) { /*for*/
    /* Register variable[5]: For 'is_ok' result */
    variable[5] = CALL_abstract_collection___Iterator___is_ok(variable[4])(variable[4]) /*ArrayIterator::is_ok*/;
    if (!UNTAG_Bool(variable[5])) break; /*for*/
    variable[5] = CALL_abstract_collection___Iterator___item(variable[4])(variable[4]) /*ArrayIterator::item*/ /* Ensure var: For item*/;
    /* Register variable[6]: Local variable */
    variable[6] = variable[5];
    /* Register variable[7]: Result */
    variable[7] = CALL_abstract_collection___Couple___second( variable[6] /*i*/)( variable[6] /*i*/) /*Couple::second*/;
    /* Register variable[7]: Result */
    variable[7] = TAG_Bool((variable[7] ==  variable[1] /*item*/) || ((variable[7] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[7])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[7], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[7])(variable[7],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[7])) { /*if*/
      variable[3] = TAG_Int(UNTAG_Int(variable[3])+UNTAG_Int( TAG_Int(1))) /*nb*/;
    }
    continue_76: while(0);
    CALL_abstract_collection___Iterator___next(variable[4])(variable[4]) /*ArrayIterator::next*/;
  }
  break_76: while(0);
  variable[2] =  variable[3] /*nb*/;
  goto return_label75;
  return_label75: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArrayMap___first(val_t  self) {
  struct trace_t trace = {NULL, NULL, 449, LOCATE_array___ArrayMap___first};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___first(variable[2])(variable[2]) /*IndexedCollectionRead::first*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Couple___first(variable[2])(variable[2]) /*Couple::first*/;
  variable[1] = variable[2];
  goto return_label77;
  return_label77: while(false);
  tracehead = trace.prev;
  return variable[1];
}
void array___ArrayMap___clear(val_t  self) {
  struct trace_t trace = {NULL, NULL, 492, LOCATE_array___ArrayMap___clear};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  CALL_abstract_collection___RemovableCollection___clear(variable[2])(variable[2]) /*AbstractArray::clear*/;
  return_label78: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArrayMap___remove(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 463, LOCATE_array___ArrayMap___remove};
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArrayRead::length*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[4];
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    /* Register variable[4]: Result */
    variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Local variable */
    variable[6] =  variable[3] /*i*/;
    /* Register variable[7]: Method return value and escape marker */
    /* Register variable[8]: Result */
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    /* Ensure var variable[8]: Left 'and' operand*/
    if (UNTAG_Bool(variable[8])) { /* and */
      /* Register variable[8]: Result */
      variable[8] = ATTR_array___AbstractArrayRead____length(variable[5]) /*AbstractArrayRead::_length*/;
      /* Register variable[8]: Result */
      variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[8]));
    }
    /* Register variable[8]: Result */
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 234); nit_exit(1);}
    /* Register variable[8]: Result */
    variable[8] = ATTR_array___Array____items(variable[5]) /*Array::_items*/;
    /* Register variable[8]: Result */
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label81;
    return_label81: while(false);
    /* Register variable[4]: Result */
    variable[4] = variable[7];
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Couple___second(variable[4])(variable[4]) /*Couple::second*/;
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool((variable[4] ==  variable[1] /*item*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[4])) { /*if*/
      CALL_array___ArrayMap___remove_at_index(variable[0])(variable[0],  variable[3] /*i*/) /*ArrayMap::remove_at_index*/;
      goto return_label79;
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])-UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_80: while(0);
  }
  break_80: while(0);
  return_label79: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArrayMap___remove_all(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 475, LOCATE_array___ArrayMap___remove_all};
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArrayRead::length*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Int(UNTAG_Int(variable[4])-UNTAG_Int( TAG_Int(1)));
  variable[3] = variable[4];
  while (true) { /*while*/
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
    if (!UNTAG_Bool(variable[4])) break; /* while*/
    /* Register variable[4]: Result */
    variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Local variable */
    variable[6] =  variable[3] /*i*/;
    /* Register variable[7]: Method return value and escape marker */
    /* Register variable[8]: Result */
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    /* Ensure var variable[8]: Left 'and' operand*/
    if (UNTAG_Bool(variable[8])) { /* and */
      /* Register variable[8]: Result */
      variable[8] = ATTR_array___AbstractArrayRead____length(variable[5]) /*AbstractArrayRead::_length*/;
      /* Register variable[8]: Result */
      variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[8]));
    }
    /* Register variable[8]: Result */
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 234); nit_exit(1);}
    /* Register variable[8]: Result */
    variable[8] = ATTR_array___Array____items(variable[5]) /*Array::_items*/;
    /* Register variable[8]: Result */
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label84;
    return_label84: while(false);
    /* Register variable[4]: Result */
    variable[4] = variable[7];
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Couple___second(variable[4])(variable[4]) /*Couple::second*/;
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool((variable[4] ==  variable[1] /*item*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], variable[1] /*item*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  variable[1] /*item*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[4])) { /*if*/
      CALL_array___ArrayMap___remove_at_index(variable[0])(variable[0],  variable[3] /*i*/) /*ArrayMap::remove_at_index*/;
    }
    variable[3] = TAG_Int(UNTAG_Int(variable[3])-UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_83: while(0);
  }
  break_83: while(0);
  return_label82: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 407, LOCATE_array___ArrayMap_____bra};
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_array___ArrayMap___index(variable[0])(variable[0],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Local variable */
    variable[6] =  variable[3] /*i*/;
    /* Register variable[7]: Method return value and escape marker */
    /* Register variable[8]: Result */
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    /* Ensure var variable[8]: Left 'and' operand*/
    if (UNTAG_Bool(variable[8])) { /* and */
      /* Register variable[8]: Result */
      variable[8] = ATTR_array___AbstractArrayRead____length(variable[5]) /*AbstractArrayRead::_length*/;
      /* Register variable[8]: Result */
      variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[8]));
    }
    /* Register variable[8]: Result */
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 234); nit_exit(1);}
    /* Register variable[8]: Result */
    variable[8] = ATTR_array___Array____items(variable[5]) /*Array::_items*/;
    /* Register variable[8]: Result */
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label86;
    return_label86: while(false);
    /* Register variable[4]: Result */
    variable[4] = variable[7];
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Couple___second(variable[4])(variable[4]) /*Couple::second*/;
    variable[2] = variable[4];
    goto return_label85;
  } else { /*if*/
    fprintf(stderr, "Aborted"); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___ArrayMap_____bra, LOCATE_array, 414); nit_exit(1);
  }
  return_label85: while(false);
  tracehead = trace.prev;
  return variable[2];
}
val_t array___ArrayMap___has_key(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 429, LOCATE_array___ArrayMap___has_key};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = CALL_array___ArrayMap___index(variable[0])(variable[0],  variable[1] /*key*/) /*ArrayMap::index*/;
  /* Register variable[3]: Result */
  variable[3] = TAG_Bool(UNTAG_Int(variable[3])>=UNTAG_Int( TAG_Int(0)));
  variable[2] = variable[3];
  goto return_label87;
  return_label87: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___ArrayMap_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 418, LOCATE_array___ArrayMap_____braeq};
  val_t variable[10];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Local variable */
  variable[2] =  param1;
  /* Register variable[3]: Method return value and escape marker */
  /* Register variable[4]: Local variable */
  /* Register variable[5]: Result */
  variable[5] = CALL_array___ArrayMap___index(variable[0])(variable[0],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[4] = variable[5];
  /* Register variable[5]: Result */
  variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[5])) { /*if*/
    /* Register variable[5]: Result */
    variable[5] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[6]: Local variable */
    variable[6] = variable[5];
    /* Register variable[7]: Local variable */
    variable[7] =  variable[4] /*i*/;
    /* Register variable[8]: Method return value and escape marker */
    /* Register variable[9]: Result */
    variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    /* Ensure var variable[9]: Left 'and' operand*/
    if (UNTAG_Bool(variable[9])) { /* and */
      /* Register variable[9]: Result */
      variable[9] = ATTR_array___AbstractArrayRead____length(variable[6]) /*AbstractArrayRead::_length*/;
      /* Register variable[9]: Result */
      variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)<UNTAG_Int(variable[9]));
    }
    /* Register variable[9]: Result */
    if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 234); nit_exit(1);}
    /* Register variable[9]: Result */
    variable[9] = ATTR_array___Array____items(variable[6]) /*Array::_items*/;
    /* Register variable[9]: Result */
    variable[9] = UNBOX_NativeArray(variable[9])[UNTAG_Int( variable[7] /*index*/)];
    variable[8] = variable[9];
    goto return_label89;
    return_label89: while(false);
    /* Register variable[5]: Result */
    variable[5] = variable[8];
    CALL_abstract_collection___Couple___second__eq(variable[5])(variable[5],  variable[2] /*item*/) /*Couple::second=*/;
  } else { /*if*/
    /* Register variable[5]: Result */
    variable[5] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[6]: Result */
    variable[6] = NEW_Couple_abstract_collection___Couple___init( variable[1] /*key*/,  variable[2] /*item*/) /*new Couple[K, E]*/;
    CALL_abstract_collection___IndexedCollection___push(variable[5])(variable[5], variable[6]) /*AbstractArray::push*/;
  }
  return_label88: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArrayMap___remove_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 486, LOCATE_array___ArrayMap___remove_at};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_array___ArrayMap___index(variable[0])(variable[0],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    CALL_array___ArrayMap___remove_at_index(variable[0])(variable[0],  variable[3] /*i*/) /*ArrayMap::remove_at_index*/;
  }
  return_label90: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap___couple_at(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 497, LOCATE_array___ArrayMap___couple_at};
  val_t variable[9];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = CALL_array___ArrayMap___index(variable[0])(variable[0],  variable[1] /*key*/) /*ArrayMap::index*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*i*/)>=UNTAG_Int( TAG_Int(0)));
  if (UNTAG_Bool(variable[4])) { /*if*/
    /* Register variable[4]: Result */
    variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Local variable */
    variable[6] =  variable[3] /*i*/;
    /* Register variable[7]: Method return value and escape marker */
    /* Register variable[8]: Result */
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    /* Ensure var variable[8]: Left 'and' operand*/
    if (UNTAG_Bool(variable[8])) { /* and */
      /* Register variable[8]: Result */
      variable[8] = ATTR_array___AbstractArrayRead____length(variable[5]) /*AbstractArrayRead::_length*/;
      /* Register variable[8]: Result */
      variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[8]));
    }
    /* Register variable[8]: Result */
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 234); nit_exit(1);}
    /* Register variable[8]: Result */
    variable[8] = ATTR_array___Array____items(variable[5]) /*Array::_items*/;
    /* Register variable[8]: Result */
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label92;
    return_label92: while(false);
    /* Register variable[4]: Result */
    variable[4] = variable[7];
    variable[2] = variable[4];
    goto return_label91;
  } else { /*if*/
    variable[2] =  NIT_NULL /*null*/;
    goto return_label91;
  }
  return_label91: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___ArrayMap___enlarge(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 494, LOCATE_array___ArrayMap___enlarge};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  CALL_array___AbstractArray___enlarge(variable[3])(variable[3],  variable[1] /*cap*/) /*Array::enlarge*/;
  return_label93: while(false);
  tracehead = trace.prev;
  return;
}
void array___ArrayMap___remove_at_index(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 510, LOCATE_array___ArrayMap___remove_at_index};
  val_t variable[5];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___IndexedCollectionRead___last(variable[4])(variable[4]) /*IndexedCollectionRead::last*/;
  CALL_abstract_collection___Map_____braeq(variable[3])(variable[3],  variable[1] /*i*/, variable[4]) /*Array::[]=*/;
  /* Register variable[3]: Result */
  variable[3] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  CALL_abstract_collection___IndexedCollection___pop(variable[3])(variable[3]) /*AbstractArray::pop*/;
  return_label94: while(false);
  tracehead = trace.prev;
  return;
}
val_t array___ArrayMap___index(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 520, LOCATE_array___ArrayMap___index};
  val_t variable[10];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Local variable */
  variable[1] =  param0;
  /* Register variable[2]: Method return value and escape marker */
  /* Register variable[3]: Local variable */
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___ArrayMap____last_index(variable[0]) /*ArrayMap::_last_index*/;
  variable[3] = variable[4];
  /* Register variable[4]: Result */
  variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
  /* Register variable[4]: Result */
  variable[4] = CALL_abstract_collection___Collection___length(variable[4])(variable[4]) /*AbstractArrayRead::length*/;
  /* Register variable[4]: Result */
  variable[4] = TAG_Bool(UNTAG_Int( variable[3] /*l*/)<UNTAG_Int(variable[4]));
  /* Ensure var variable[4]: Left 'and' operand*/
  if (UNTAG_Bool(variable[4])) { /* and */
    /* Register variable[4]: Result */
    variable[4] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[5]: Local variable */
    variable[5] = variable[4];
    /* Register variable[6]: Local variable */
    variable[6] =  variable[3] /*l*/;
    /* Register variable[7]: Method return value and escape marker */
    /* Register variable[8]: Result */
    variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    /* Ensure var variable[8]: Left 'and' operand*/
    if (UNTAG_Bool(variable[8])) { /* and */
      /* Register variable[8]: Result */
      variable[8] = ATTR_array___AbstractArrayRead____length(variable[5]) /*AbstractArrayRead::_length*/;
      /* Register variable[8]: Result */
      variable[8] = TAG_Bool(UNTAG_Int( variable[6] /*index*/)<UNTAG_Int(variable[8]));
    }
    /* Register variable[8]: Result */
    if (!UNTAG_Bool(variable[8])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 234); nit_exit(1);}
    /* Register variable[8]: Result */
    variable[8] = ATTR_array___Array____items(variable[5]) /*Array::_items*/;
    /* Register variable[8]: Result */
    variable[8] = UNBOX_NativeArray(variable[8])[UNTAG_Int( variable[6] /*index*/)];
    variable[7] = variable[8];
    goto return_label96;
    return_label96: while(false);
    /* Register variable[4]: Result */
    variable[4] = variable[7];
    /* Register variable[4]: Result */
    variable[4] = CALL_abstract_collection___Couple___first(variable[4])(variable[4]) /*Couple::first*/;
    /* Register variable[4]: Result */
    variable[4] = TAG_Bool((variable[4] ==  variable[1] /*key*/) || ((variable[4] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[4])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[4], variable[1] /*key*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[4])(variable[4],  variable[1] /*key*/) /*Object::==*/)))));
  }
  /* Register variable[4]: Result */
  if (UNTAG_Bool(variable[4])) { /*if*/
    variable[2] =  variable[3] /*l*/;
    goto return_label95;
  }
  /* Register variable[4]: Local variable */
  variable[4] =  TAG_Int(0);
  while (true) { /*while*/
    /* Register variable[5]: Result */
    variable[5] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___Collection___length(variable[5])(variable[5]) /*AbstractArrayRead::length*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool(UNTAG_Int( variable[4] /*i*/)<UNTAG_Int(variable[5]));
    if (!UNTAG_Bool(variable[5])) break; /* while*/
    /* Register variable[5]: Result */
    variable[5] = ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/;
    /* Register variable[6]: Local variable */
    variable[6] = variable[5];
    /* Register variable[7]: Local variable */
    variable[7] =  variable[4] /*i*/;
    /* Register variable[8]: Method return value and escape marker */
    /* Register variable[9]: Result */
    variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)>=UNTAG_Int( TAG_Int(0)));
    /* Ensure var variable[9]: Left 'and' operand*/
    if (UNTAG_Bool(variable[9])) { /* and */
      /* Register variable[9]: Result */
      variable[9] = ATTR_array___AbstractArrayRead____length(variable[6]) /*AbstractArrayRead::_length*/;
      /* Register variable[9]: Result */
      variable[9] = TAG_Bool(UNTAG_Int( variable[7] /*index*/)<UNTAG_Int(variable[9]));
    }
    /* Register variable[9]: Result */
    if (!UNTAG_Bool(variable[9])) { fprintf(stderr, "Assert%s failed", " 'index' "); fprintf(stderr, " in %s (%s:%d)\n", LOCATE_array___Array_____bra, LOCATE_array, 234); nit_exit(1);}
    /* Register variable[9]: Result */
    variable[9] = ATTR_array___Array____items(variable[6]) /*Array::_items*/;
    /* Register variable[9]: Result */
    variable[9] = UNBOX_NativeArray(variable[9])[UNTAG_Int( variable[7] /*index*/)];
    variable[8] = variable[9];
    goto return_label98;
    return_label98: while(false);
    /* Register variable[5]: Result */
    variable[5] = variable[8];
    /* Register variable[5]: Result */
    variable[5] = CALL_abstract_collection___Couple___first(variable[5])(variable[5]) /*Couple::first*/;
    /* Register variable[5]: Result */
    variable[5] = TAG_Bool((variable[5] ==  variable[1] /*key*/) || ((variable[5] != NIT_NULL) && ((CALL_kernel___Object_____eqeq(variable[5])==kernel___Object_____eqeq)?(IS_EQUAL_NN(variable[5], variable[1] /*key*/)):(UNTAG_Bool(CALL_kernel___Object_____eqeq(variable[5])(variable[5],  variable[1] /*key*/) /*Object::==*/)))));
    if (UNTAG_Bool(variable[5])) { /*if*/
      ATTR_array___ArrayMap____last_index(variable[0]) /*ArrayMap::_last_index*/ =  variable[4] /*i*/;
      variable[2] =  variable[4] /*i*/;
      goto return_label95;
    }
    variable[4] = TAG_Int(UNTAG_Int(variable[4])+UNTAG_Int( TAG_Int(1))) /*i*/;
    continue_97: while(0);
  }
  break_97: while(0);
  /* Register variable[5]: Result */
  variable[5] = TAG_Int(-UNTAG_Int( TAG_Int(1)));
  variable[2] = variable[5];
  goto return_label95;
  return_label95: while(false);
  tracehead = trace.prev;
  return variable[2];
}
void array___ArrayMap___init(val_t  self, int* init_table) {
  struct trace_t trace = {NULL, NULL, 538, LOCATE_array___ArrayMap___init};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  if (init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArrayMap].i]) return;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = NEW_Array_array___Array___init() /*new Array[Couple[K, E]]*/;
  ATTR_array___ArrayMap____items(variable[0]) /*ArrayMap::_items*/ = variable[2];
  return_label99: while(false);
  init_table[VAL2OBJ(variable[0])->vft[INIT_TABLE_POS_ArrayMap].i] = 1;
  tracehead = trace.prev;
  return;
}
val_t array___Iterator___to_a(val_t  self) {
  struct trace_t trace = {NULL, NULL, 548, LOCATE_array___Iterator___to_a};
  val_t variable[4];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Local variable */
  /* Register variable[3]: Result */
  variable[3] = NEW_Array_array___Array___init() /*new Array[E]*/;
  variable[2] = variable[3];
  while (true) { /*while*/
    /* Register variable[3]: Result */
    variable[3] = CALL_abstract_collection___Iterator___is_ok(variable[0])(variable[0]) /*Iterator::is_ok*/;
    if (!UNTAG_Bool(variable[3])) break; /* while*/
    /* Register variable[3]: Result */
    variable[3] = CALL_abstract_collection___Iterator___item(variable[0])(variable[0]) /*Iterator::item*/;
    CALL_abstract_collection___SimpleCollection___add( variable[2] /*res*/)( variable[2] /*res*/, variable[3]) /*AbstractArray::add*/;
    CALL_abstract_collection___Iterator___next(variable[0])(variable[0]) /*Iterator::next*/;
    continue_101: while(0);
  }
  break_101: while(0);
  variable[1] =  variable[2] /*res*/;
  goto return_label100;
  return_label100: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___Collection___to_a(val_t  self) {
  struct trace_t trace = {NULL, NULL, 561, LOCATE_array___Collection___to_a};
  val_t variable[3];
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  /* Register variable[0]: Local variable */
  variable[0] =  self;
  /* Register variable[1]: Method return value and escape marker */
  /* Register variable[2]: Result */
  variable[2] = CALL_abstract_collection___Collection___iterator(variable[0])(variable[0]) /*Collection::iterator*/;
  /* Register variable[2]: Result */
  variable[2] = CALL_array___Iterator___to_a(variable[2])(variable[2]) /*Iterator::to_a*/;
  variable[1] = variable[2];
  goto return_label102;
  return_label102: while(false);
  tracehead = trace.prev;
  return variable[1];
}
val_t array___ArrayCapable___calloc_array(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 572, LOCATE_array___ArrayCapable___calloc_array};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return BOX_NativeArray((val_t*)malloc((UNTAG_Int( param0) * sizeof(val_t))));
}
val_t array___NativeArray_____bra(val_t  self, val_t  param0) {
  struct trace_t trace = {NULL, NULL, 578, LOCATE_array___NativeArray_____bra};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  tracehead = trace.prev;
  return UNBOX_NativeArray( self)[UNTAG_Int( param0)];
}
void array___NativeArray_____braeq(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 579, LOCATE_array___NativeArray_____braeq};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  UNBOX_NativeArray( self)[UNTAG_Int( param0)]= param1;
  tracehead = trace.prev;
  return;
}
void array___NativeArray___copy_to(val_t  self, val_t  param0, val_t  param1) {
  struct trace_t trace = {NULL, NULL, 580, LOCATE_array___NativeArray___copy_to};
  val_t *variable = NULL;
  struct WBT_ **closurevariable = NULL;
  trace.prev = tracehead; tracehead = &trace;
  trace.file = LOCATE_array;
  (void)memcpy(UNBOX_NativeArray( param0), UNBOX_NativeArray( self), UNTAG_Int( param1)*sizeof(val_t));
  tracehead = trace.prev;
  return;
}
